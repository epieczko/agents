{
  "total_count": 5,
  "category": "security",
  "commands": [
    {
      "name": "security-hardening",
      "title": "security-hardening",
      "description": "Implement comprehensive security hardening with defense-in-depth strategy through coordinated multi-agent orchestration:",
      "plugin": "security-scanning",
      "source_path": "plugins/security-scanning/commands/security-hardening.md",
      "category": "security",
      "keywords": [
        "security",
        "sast",
        "vulnerability-scanning",
        "owasp",
        "devsecops"
      ],
      "content": "Implement comprehensive security hardening with defense-in-depth strategy through coordinated multi-agent orchestration:\n\n[Extended thinking: This workflow implements a defense-in-depth security strategy across all application layers. It coordinates specialized security agents to perform comprehensive assessments, implement layered security controls, and establish continuous security monitoring. The approach follows modern DevSecOps principles with shift-left security, automated scanning, and compliance validation. Each phase builds upon previous findings to create a resilient security posture that addresses both current vulnerabilities and future threats.]\n\n## Phase 1: Comprehensive Security Assessment\n\n### 1. Initial Vulnerability Scanning\n- Use Task tool with subagent_type=\"security-auditor\"\n- Prompt: \"Perform comprehensive security assessment on: $ARGUMENTS. Execute SAST analysis with Semgrep/SonarQube, DAST scanning with OWASP ZAP, dependency audit with Snyk/Trivy, secrets detection with GitLeaks/TruffleHog. Generate SBOM for supply chain analysis. Identify OWASP Top 10 vulnerabilities, CWE weaknesses, and CVE exposures.\"\n- Output: Detailed vulnerability report with CVSS scores, exploitability analysis, attack surface mapping, secrets exposure report, SBOM inventory\n- Context: Initial baseline for all remediation efforts\n\n### 2. Threat Modeling and Risk Analysis\n- Use Task tool with subagent_type=\"security-auditor\"\n- Prompt: \"Conduct threat modeling using STRIDE methodology for: $ARGUMENTS. Analyze attack vectors, create attack trees, assess business impact of identified vulnerabilities. Map threats to MITRE ATT&CK framework. Prioritize risks based on likelihood and impact.\"\n- Output: Threat model diagrams, risk matrix with prioritized vulnerabilities, attack scenario documentation, business impact analysis\n- Context: Uses vulnerability scan results to inform threat priorities\n\n### 3. Architecture Security Review\n- Use Task tool with subagent_type=\"backend-api-security::backend-architect\"\n- Prompt: \"Review architecture for security weaknesses in: $ARGUMENTS. Evaluate service boundaries, data flow security, authentication/authorization architecture, encryption implementation, network segmentation. Design zero-trust architecture patterns. Reference threat model and vulnerability findings.\"\n- Output: Security architecture assessment, zero-trust design recommendations, service mesh security requirements, data classification matrix\n- Context: Incorporates threat model to address architectural vulnerabilities\n\n## Phase 2: Vulnerability Remediation\n\n### 4. Critical Vulnerability Fixes\n- Use Task tool with subagent_type=\"security-auditor\"\n- Prompt: \"Coordinate immediate remediation of critical vulnerabilities (CVSS 7+) in: $ARGUMENTS. Fix SQL injections with parameterized queries, XSS with output encoding, authentication bypasses with secure session management, insecure deserialization with input validation. Apply security patches for CVEs.\"\n- Output: Patched code with vulnerability fixes, security patch documentation, regression test requirements\n- Context: Addresses high-priority items from vulnerability assessment\n\n### 5. Backend Security Hardening\n- Use Task tool with subagent_type=\"backend-api-security::backend-security-coder\"\n- Prompt: \"Implement comprehensive backend security controls for: $ARGUMENTS. Add input validation with OWASP ESAPI, implement rate limiting and DDoS protection, secure API endpoints with OAuth2/JWT validation, add encryption for data at rest/transit using AES-256/TLS 1.3. Implement secure logging without PII exposure.\"\n- Output: Hardened API endpoints, validation middleware, encryption implementation, secure configuration templates\n- Context: Builds upon vulnerability fixes with preventive controls\n\n### 6. Frontend Security Implementation\n- Use Task tool with subagent_type=\"frontend-mobile-security::frontend-security-coder\"\n- Prompt: \"Implement frontend security measures for: $ARGUMENTS. Configure CSP headers with nonce-based policies, implement XSS prevention with DOMPurify, secure authentication flows with PKCE OAuth2, add SRI for external resources, implement secure cookie handling with SameSite/HttpOnly/Secure flags.\"\n- Output: Secure frontend components, CSP policy configuration, authentication flow implementation, security headers configuration\n- Context: Complements backend security with client-side protections\n\n### 7. Mobile Security Hardening\n- Use Task tool with subagent_type=\"frontend-mobile-security::mobile-security-coder\"\n- Prompt: \"Implement mobile app security for: $ARGUMENTS. Add certificate pinning, implement biometric authentication, secure local storage with encryption, obfuscate code with ProGuard/R8, implement anti-tampering and root/jailbreak detection, secure IPC communications.\"\n- Output: Hardened mobile application, security configuration files, obfuscation rules, certificate pinning implementation\n- Context: Extends security to mobile platforms if applicable\n\n## Phase 3: Security Controls Implementation\n\n### 8. Authentication and Authorization Enhancement\n- Use Task tool with subagent_type=\"security-auditor\"\n- Prompt: \"Implement modern authentication system for: $ARGUMENTS. Deploy OAuth2/OIDC with PKCE, implement MFA with TOTP/WebAuthn/FIDO2, add risk-based authentication, implement RBAC/ABAC with principle of least privilege, add session management with secure token rotation.\"\n- Output: Authentication service configuration, MFA implementation, authorization policies, session management system\n- Context: Strengthens access controls based on architecture review\n\n### 9. Infrastructure Security Controls\n- Use Task tool with subagent_type=\"deployment-strategies::deployment-engineer\"\n- Prompt: \"Deploy infrastructure security controls for: $ARGUMENTS. Configure WAF rules for OWASP protection, implement network segmentation with micro-segmentation, deploy IDS/IPS systems, configure cloud security groups and NACLs, implement DDoS protection with rate limiting and geo-blocking.\"\n- Output: WAF configuration, network security policies, IDS/IPS rules, cloud security configurations\n- Context: Implements network-level defenses\n\n### 10. Secrets Management Implementation\n- Use Task tool with subagent_type=\"deployment-strategies::deployment-engineer\"\n- Prompt: \"Implement enterprise secrets management for: $ARGUMENTS. Deploy HashiCorp Vault or AWS Secrets Manager, implement secret rotation policies, remove hardcoded secrets, configure least-privilege IAM roles, implement encryption key management with HSM support.\"\n- Output: Secrets management configuration, rotation policies, IAM role definitions, key management procedures\n- Context: Eliminates secrets exposure vulnerabilities\n\n## Phase 4: Validation and Compliance\n\n### 11. Penetration Testing and Validation\n- Use Task tool with subagent_type=\"security-auditor\"\n- Prompt: \"Execute comprehensive penetration testing for: $ARGUMENTS. Perform authenticated and unauthenticated testing, API security testing, business logic testing, privilege escalation attempts. Use Burp Suite, Metasploit, and custom exploits. Validate all security controls effectiveness.\"\n- Output: Penetration test report, proof-of-concept exploits, remediation validation, security control effectiveness metrics\n- Context: Validates all implemented security measures\n\n### 12. Compliance and Standards Verification\n- Use Task tool with subagent_type=\"security-auditor\"\n- Prompt: \"Verify compliance with security frameworks for: $ARGUMENTS. Validate against OWASP ASVS Level 2, CIS Benchmarks, SOC2 Type II requirements, GDPR/CCPA privacy controls, HIPAA/PCI-DSS if applicable. Generate compliance attestation reports.\"\n- Output: Compliance assessment report, gap analysis, remediation requirements, audit evidence collection\n- Context: Ensures regulatory and industry standard compliance\n\n### 13. Security Monitoring and SIEM Integration\n- Use Task tool with subagent_type=\"incident-response::devops-troubleshooter\"\n- Prompt: \"Implement security monitoring and SIEM for: $ARGUMENTS. Deploy Splunk/ELK/Sentinel integration, configure security event correlation, implement behavioral analytics for anomaly detection, set up automated incident response playbooks, create security dashboards and alerting.\"\n- Output: SIEM configuration, correlation rules, incident response playbooks, security dashboards, alert definitions\n- Context: Establishes continuous security monitoring\n\n## Configuration Options\n- scanning_depth: \"quick\" | \"standard\" | \"comprehensive\" (default: comprehensive)\n- compliance_frameworks: [\"OWASP\", \"CIS\", \"SOC2\", \"GDPR\", \"HIPAA\", \"PCI-DSS\"]\n- remediation_priority: \"cvss_score\" | \"exploitability\" | \"business_impact\"\n- monitoring_integration: \"splunk\" | \"elastic\" | \"sentinel\" | \"custom\"\n- authentication_methods: [\"oauth2\", \"saml\", \"mfa\", \"biometric\", \"passwordless\"]\n\n## Success Criteria\n- All critical vulnerabilities (CVSS 7+) remediated\n- OWASP Top 10 vulnerabilities addressed\n- Zero high-risk findings in penetration testing\n- Compliance frameworks validation passed\n- Security monitoring detecting and alerting on threats\n- Incident response time < 15 minutes for critical alerts\n- SBOM generated and vulnerabilities tracked\n- All secrets managed through secure vault\n- Authentication implements MFA and secure session management\n- Security tests integrated into CI/CD pipeline\n\n## Coordination Notes\n- Each phase provides detailed findings that inform subsequent phases\n- Security-auditor agent coordinates with domain-specific agents for fixes\n- All code changes undergo security review before implementation\n- Continuous feedback loop between assessment and remediation\n- Security findings tracked in centralized vulnerability management system\n- Regular security reviews scheduled post-implementation\n\nSecurity hardening target: $ARGUMENTS"
    },
    {
      "name": "security-sast",
      "title": "SAST Security Plugin",
      "description": "---",
      "plugin": "security-scanning",
      "source_path": "plugins/security-scanning/commands/security-sast.md",
      "category": "security",
      "keywords": [
        "security",
        "sast",
        "vulnerability-scanning",
        "owasp",
        "devsecops"
      ],
      "content": "---\ndescription: Static Application Security Testing (SAST) for code vulnerability analysis across multiple languages and frameworks\nglobs: ['**/*.py', '**/*.js', '**/*.ts', '**/*.java', '**/*.rb', '**/*.go', '**/*.rs', '**/*.php']\nkeywords: [sast, static analysis, code security, vulnerability scanning, bandit, semgrep, eslint, sonarqube, codeql, security patterns, code review, ast analysis]\n---\n\n# SAST Security Plugin\n\nStatic Application Security Testing (SAST) for comprehensive code vulnerability detection across multiple languages, frameworks, and security patterns.\n\n## Capabilities\n\n- **Multi-language SAST**: Python, JavaScript/TypeScript, Java, Ruby, PHP, Go, Rust\n- **Tool integration**: Bandit, Semgrep, ESLint Security, SonarQube, CodeQL, PMD, SpotBugs, Brakeman, gosec, cargo-clippy\n- **Vulnerability patterns**: SQL injection, XSS, hardcoded secrets, path traversal, IDOR, CSRF, insecure deserialization\n- **Framework analysis**: Django, Flask, React, Express, Spring Boot, Rails, Laravel\n- **Custom rule authoring**: Semgrep pattern development for organization-specific security policies\n\n## When to Use This Tool\n\nUse for code review security analysis, injection vulnerabilities, hardcoded secrets, framework-specific patterns, custom security policy enforcement, pre-deployment validation, legacy code assessment, and compliance (OWASP, PCI-DSS, SOC2).\n\n**Specialized tools**: Use `security-secrets.md` for advanced credential scanning, `security-owasp.md` for Top 10 mapping, `security-api.md` for REST/GraphQL endpoints.\n\n## SAST Tool Selection\n\n### Python: Bandit\n\n```bash\n# Installation & scan\npip install bandit\nbandit -r . -f json -o bandit-report.json\nbandit -r . -ll -ii -f json  # High/Critical only\n```\n\n**Configuration**: `.bandit`\n```yaml\nexclude_dirs: ['/tests/', '/venv/', '/.tox/', '/build/']\ntests: [B201, B301, B302, B303, B304, B305, B307, B308, B312, B323, B324, B501, B502, B506, B602, B608]\nskips: [B101]\n```\n\n### JavaScript/TypeScript: ESLint Security\n\n```bash\nnpm install --save-dev eslint @eslint/plugin-security eslint-plugin-no-secrets\neslint . --ext .js,.jsx,.ts,.tsx --format json > eslint-security.json\n```\n\n**Configuration**: `.eslintrc-security.json`\n```json\n{\n  \"plugins\": [\"@eslint/plugin-security\", \"eslint-plugin-no-secrets\"],\n  \"extends\": [\"plugin:security/recommended\"],\n  \"rules\": {\n    \"security/detect-object-injection\": \"error\",\n    \"security/detect-non-literal-fs-filename\": \"error\",\n    \"security/detect-eval-with-expression\": \"error\",\n    \"security/detect-pseudo-random-prng\": \"error\",\n    \"no-secrets/no-secrets\": \"error\"\n  }\n}\n```\n\n### Multi-Language: Semgrep\n\n```bash\npip install semgrep\nsemgrep --config=auto --json --output=semgrep-report.json\nsemgrep --config=p/security-audit --json\nsemgrep --config=p/owasp-top-ten --json\nsemgrep ci --config=auto  # CI mode\n```\n\n**Custom Rules**: `.semgrep.yml`\n```yaml\nrules:\n  - id: sql-injection-format-string\n    pattern: cursor.execute(\"... %s ...\" % $VAR)\n    message: SQL injection via string formatting\n    severity: ERROR\n    languages: [python]\n    metadata:\n      cwe: \"CWE-89\"\n      owasp: \"A03:2021-Injection\"\n\n  - id: dangerous-innerHTML\n    pattern: $ELEM.innerHTML = $VAR\n    message: XSS via innerHTML assignment\n    severity: ERROR\n    languages: [javascript, typescript]\n    metadata:\n      cwe: \"CWE-79\"\n\n  - id: hardcoded-aws-credentials\n    patterns:\n      - pattern: $KEY = \"AKIA...\"\n      - metavariable-regex:\n          metavariable: $KEY\n          regex: \"(aws_access_key_id|AWS_ACCESS_KEY_ID)\"\n    message: Hardcoded AWS credentials detected\n    severity: ERROR\n    languages: [python, javascript, java]\n\n  - id: path-traversal-open\n    patterns:\n      - pattern: open($PATH, ...)\n      - pattern-not: open(os.path.join(SAFE_DIR, ...), ...)\n      - metavariable-pattern:\n          metavariable: $PATH\n          patterns:\n            - pattern: $REQ.get(...)\n    message: Path traversal via user input\n    severity: ERROR\n    languages: [python]\n\n  - id: command-injection\n    patterns:\n      - pattern-either:\n          - pattern: os.system($CMD)\n          - pattern: subprocess.call($CMD, shell=True)\n      - metavariable-pattern:\n          metavariable: $CMD\n          patterns:\n            - pattern-either:\n                - pattern: $X + $Y\n                - pattern: f\"...{$VAR}...\"\n    message: Command injection via shell=True\n    severity: ERROR\n    languages: [python]\n```\n\n### Other Language Tools\n\n**Java**: `mvn spotbugs:check`\n**Ruby**: `brakeman -o report.json -f json`\n**Go**: `gosec -fmt=json -out=gosec.json ./...`\n**Rust**: `cargo clippy -- -W clippy::unwrap_used`\n\n## Vulnerability Patterns\n\n### SQL Injection\n\n**VULNERABLE**: String formatting/concatenation with user input in SQL queries\n\n**SECURE**:\n```python\n# Parameterized queries\ncursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\nUser.objects.filter(id=user_id)  # ORM\n```\n\n### Cross-Site Scripting (XSS)\n\n**VULNERABLE**: Direct HTML manipulation with unsanitized user input (innerHTML, outerHTML, document.write)\n\n**SECURE**:\n```javascript\n// Use textContent for plain text\nelement.textContent = userInput;\n\n// React auto-escapes\n<div>{userInput}</div>\n\n// Sanitize when HTML required\nimport DOMPurify from 'dompurify';\nelement.innerHTML = DOMPurify.sanitize(userInput);\n```\n\n### Hardcoded Secrets\n\n**VULNERABLE**: Hardcoded API keys, passwords, tokens in source code\n\n**SECURE**:\n```python\nimport os\nAPI_KEY = os.environ.get('API_KEY')\nPASSWORD = os.getenv('DB_PASSWORD')\n```\n\n### Path Traversal\n\n**VULNERABLE**: Opening files using unsanitized user input\n\n**SECURE**:\n```python\nimport os\nALLOWED_DIR = '/var/www/uploads'\nfile_name = request.args.get('file')\nfile_path = os.path.join(ALLOWED_DIR, file_name)\nfile_path = os.path.realpath(file_path)\nif not file_path.startswith(os.path.realpath(ALLOWED_DIR)):\n    raise ValueError(\"Invalid file path\")\nwith open(file_path, 'r') as f:\n    content = f.read()\n```\n\n### Insecure Deserialization\n\n**VULNERABLE**: pickle.loads(), yaml.load() with untrusted data\n\n**SECURE**:\n```python\nimport json\ndata = json.loads(user_input)  # SECURE\nimport yaml\nconfig = yaml.safe_load(user_input)  # SECURE\n```\n\n### Command Injection\n\n**VULNERABLE**: os.system() or subprocess with shell=True and user input\n\n**SECURE**:\n```python\nsubprocess.run(['ping', '-c', '4', user_input])  # Array args\nimport shlex\nsafe_input = shlex.quote(user_input)  # Input validation\n```\n\n### Insecure Random\n\n**VULNERABLE**: random module for security-critical operations\n\n**SECURE**:\n```python\nimport secrets\ntoken = secrets.token_hex(16)\nsession_id = secrets.token_urlsafe(32)\n```\n\n## Framework Security\n\n### Django\n\n**VULNERABLE**: @csrf_exempt, DEBUG=True, weak SECRET_KEY, missing security middleware\n\n**SECURE**:\n```python\n# settings.py\nDEBUG = False\nSECRET_KEY = os.environ.get('DJANGO_SECRET_KEY')\n\nMIDDLEWARE = [\n    'django.middleware.security.SecurityMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\nSECURE_SSL_REDIRECT = True\nSESSION_COOKIE_SECURE = True\nCSRF_COOKIE_SECURE = True\nX_FRAME_OPTIONS = 'DENY'\n```\n\n### Flask\n\n**VULNERABLE**: debug=True, weak secret_key, CORS wildcard\n\n**SECURE**:\n```python\nimport os\nfrom flask_talisman import Talisman\n\napp.secret_key = os.environ.get('FLASK_SECRET_KEY')\nTalisman(app, force_https=True)\nCORS(app, origins=['https://example.com'])\n```\n\n### Express.js\n\n**VULNERABLE**: Missing helmet, CORS wildcard, no rate limiting\n\n**SECURE**:\n```javascript\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\n\napp.use(helmet());\napp.use(cors({ origin: 'https://example.com' }));\napp.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 100 }));\n```\n\n## Multi-Language Scanner Implementation\n\n```python\nimport json\nimport subprocess\nfrom pathlib import Path\nfrom typing import Dict, List, Any\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass SASTFinding:\n    tool: str\n    severity: str\n    category: str\n    title: str\n    description: str\n    file_path: str\n    line_number: int\n    cwe: str\n    owasp: str\n    confidence: str\n\nclass MultiLanguageSASTScanner:\n    def __init__(self, project_path: str):\n        self.project_path = Path(project_path)\n        self.findings: List[SASTFinding] = []\n\n    def detect_languages(self) -> List[str]:\n        \"\"\"Auto-detect languages\"\"\"\n        languages = []\n        indicators = {\n            'python': ['*.py', 'requirements.txt'],\n            'javascript': ['*.js', 'package.json'],\n            'typescript': ['*.ts', 'tsconfig.json'],\n            'java': ['*.java', 'pom.xml'],\n            'ruby': ['*.rb', 'Gemfile'],\n            'go': ['*.go', 'go.mod'],\n            'rust': ['*.rs', 'Cargo.toml'],\n        }\n        for lang, patterns in indicators.items():\n            for pattern in patterns:\n                if list(self.project_path.glob(f'**/{pattern}')):\n                    languages.append(lang)\n                    break\n        return languages\n\n    def run_comprehensive_sast(self) -> Dict[str, Any]:\n        \"\"\"Execute all applicable SAST tools\"\"\"\n        languages = self.detect_languages()\n\n        scan_results = {\n            'timestamp': datetime.now().isoformat(),\n            'languages': languages,\n            'tools_executed': [],\n            'findings': []\n        }\n\n        self.run_semgrep_scan()\n        scan_results['tools_executed'].append('semgrep')\n\n        if 'python' in languages:\n            self.run_bandit_scan()\n            scan_results['tools_executed'].append('bandit')\n        if 'javascript' in languages or 'typescript' in languages:\n            self.run_eslint_security_scan()\n            scan_results['tools_executed'].append('eslint-security')\n\n        scan_results['findings'] = [vars(f) for f in self.findings]\n        scan_results['summary'] = self.generate_summary()\n        return scan_results\n\n    def run_semgrep_scan(self):\n        \"\"\"Run Semgrep\"\"\"\n        for ruleset in ['auto', 'p/security-audit', 'p/owasp-top-ten']:\n            try:\n                result = subprocess.run([\n                    'semgrep', '--config', ruleset, '--json', '--quiet',\n                    str(self.project_path)\n                ], capture_output=True, text=True, timeout=300)\n\n                if result.stdout:\n                    data = json.loads(result.stdout)\n                    for f in data.get('results', []):\n                        self.findings.append(SASTFinding(\n                            tool='semgrep',\n                            severity=f.get('extra', {}).get('severity', 'MEDIUM').upper(),\n                            category='sast',\n                            title=f.get('check_id', ''),\n                            description=f.get('extra', {}).get('message', ''),\n                            file_path=f.get('path', ''),\n                            line_number=f.get('start', {}).get('line', 0),\n                            cwe=f.get('extra', {}).get('metadata', {}).get('cwe', ''),\n                            owasp=f.get('extra', {}).get('metadata', {}).get('owasp', ''),\n                            confidence=f.get('extra', {}).get('metadata', {}).get('confidence', 'MEDIUM')\n                        ))\n            except Exception as e:\n                print(f\"Semgrep {ruleset} failed: {e}\")\n\n    def generate_summary(self) -> Dict[str, Any]:\n        \"\"\"Generate statistics\"\"\"\n        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}\n        for f in self.findings:\n            severity_counts[f.severity] = severity_counts.get(f.severity, 0) + 1\n\n        return {\n            'total_findings': len(self.findings),\n            'severity_breakdown': severity_counts,\n            'risk_score': self.calculate_risk_score(severity_counts)\n        }\n\n    def calculate_risk_score(self, severity_counts: Dict[str, int]) -> int:\n        \"\"\"Risk score 0-100\"\"\"\n        weights = {'CRITICAL': 10, 'HIGH': 7, 'MEDIUM': 4, 'LOW': 1}\n        total = sum(weights[s] * c for s, c in severity_counts.items())\n        return min(100, int((total / 50) * 100))\n```\n\n## CI/CD Integration\n\n### GitHub Actions\n\n```yaml\nname: SAST Scan\non:\n  pull_request:\n    branches: [main]\n\njobs:\n  sast:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n\n      - name: Install tools\n        run: |\n          pip install bandit semgrep\n          npm install -g eslint @eslint/plugin-security\n\n      - name: Run scans\n        run: |\n          bandit -r . -f json -o bandit.json || true\n          semgrep --config=auto --json --output=semgrep.json || true\n\n      - name: Upload reports\n        uses: actions/upload-artifact@v3\n        with:\n          name: sast-reports\n          path: |\n            bandit.json\n            semgrep.json\n```\n\n### GitLab CI\n\n```yaml\nsast:\n  stage: test\n  image: python:3.11\n  script:\n    - pip install bandit semgrep\n    - bandit -r . -f json -o bandit.json || true\n    - semgrep --config=auto --json --output=semgrep.json || true\n  artifacts:\n    reports:\n      sast: bandit.json\n```\n\n## Best Practices\n\n1. **Run early and often** - Pre-commit hooks and CI/CD\n2. **Combine multiple tools** - Different tools catch different vulnerabilities\n3. **Tune false positives** - Configure exclusions and thresholds\n4. **Prioritize findings** - Focus on CRITICAL/HIGH first\n5. **Framework-aware scanning** - Use specific rulesets\n6. **Custom rules** - Organization-specific patterns\n7. **Developer training** - Secure coding practices\n8. **Incremental remediation** - Fix gradually\n9. **Baseline management** - Track known issues\n10. **Regular updates** - Keep tools current\n\n## Related Tools\n\n- **security-secrets.md** - Advanced credential detection\n- **security-owasp.md** - OWASP Top 10 assessment\n- **security-api.md** - API security testing\n- **security-scan.md** - Comprehensive security scanning\n"
    },
    {
      "name": "security-dependencies",
      "title": "Dependency Vulnerability Scanning",
      "description": "You are a security expert specializing in dependency vulnerability analysis, SBOM generation, and supply chain security. Scan project dependencies across multiple ecosystems to identify vulnerabilitie",
      "plugin": "security-scanning",
      "source_path": "plugins/security-scanning/commands/security-dependencies.md",
      "category": "security",
      "keywords": [
        "security",
        "sast",
        "vulnerability-scanning",
        "owasp",
        "devsecops"
      ],
      "content": "# Dependency Vulnerability Scanning\n\nYou are a security expert specializing in dependency vulnerability analysis, SBOM generation, and supply chain security. Scan project dependencies across multiple ecosystems to identify vulnerabilities, assess risks, and provide automated remediation strategies.\n\n## Context\nThe user needs comprehensive dependency security analysis to identify vulnerable packages, outdated dependencies, and license compliance issues. Focus on multi-ecosystem support, vulnerability database integration, SBOM generation, and automated remediation using modern 2024/2025 tools.\n\n## Requirements\n$ARGUMENTS\n\n## Instructions\n\n### 1. Multi-Ecosystem Dependency Scanner\n\n```python\nimport subprocess\nimport json\nimport requests\nfrom pathlib import Path\nfrom typing import Dict, List, Any\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass Vulnerability:\n    package: str\n    version: str\n    vulnerability_id: str\n    severity: str\n    cve: List[str]\n    cvss_score: float\n    fixed_versions: List[str]\n    source: str\n\nclass DependencyScanner:\n    def __init__(self, project_path: str):\n        self.project_path = Path(project_path)\n        self.ecosystem_scanners = {\n            'npm': self.scan_npm,\n            'pip': self.scan_python,\n            'go': self.scan_go,\n            'cargo': self.scan_rust\n        }\n\n    def detect_ecosystems(self) -> List[str]:\n        ecosystem_files = {\n            'npm': ['package.json', 'package-lock.json'],\n            'pip': ['requirements.txt', 'pyproject.toml'],\n            'go': ['go.mod'],\n            'cargo': ['Cargo.toml']\n        }\n\n        detected = []\n        for ecosystem, patterns in ecosystem_files.items():\n            if any(list(self.project_path.glob(f\"**/{p}\")) for p in patterns):\n                detected.append(ecosystem)\n        return detected\n\n    def scan_all_dependencies(self) -> Dict[str, Any]:\n        ecosystems = self.detect_ecosystems()\n        results = {\n            'timestamp': datetime.now().isoformat(),\n            'ecosystems': {},\n            'vulnerabilities': [],\n            'summary': {\n                'total_vulnerabilities': 0,\n                'critical': 0,\n                'high': 0,\n                'medium': 0,\n                'low': 0\n            }\n        }\n\n        for ecosystem in ecosystems:\n            scanner = self.ecosystem_scanners.get(ecosystem)\n            if scanner:\n                ecosystem_results = scanner()\n                results['ecosystems'][ecosystem] = ecosystem_results\n                results['vulnerabilities'].extend(ecosystem_results.get('vulnerabilities', []))\n\n        self._update_summary(results)\n        results['remediation_plan'] = self.generate_remediation_plan(results['vulnerabilities'])\n        results['sbom'] = self.generate_sbom(results['ecosystems'])\n\n        return results\n\n    def scan_npm(self) -> Dict[str, Any]:\n        results = {\n            'ecosystem': 'npm',\n            'vulnerabilities': []\n        }\n\n        try:\n            npm_result = subprocess.run(\n                ['npm', 'audit', '--json'],\n                cwd=self.project_path,\n                capture_output=True,\n                text=True,\n                timeout=120\n            )\n\n            if npm_result.stdout:\n                audit_data = json.loads(npm_result.stdout)\n                for vuln_id, vuln in audit_data.get('vulnerabilities', {}).items():\n                    results['vulnerabilities'].append({\n                        'package': vuln.get('name', vuln_id),\n                        'version': vuln.get('range', ''),\n                        'vulnerability_id': vuln_id,\n                        'severity': vuln.get('severity', 'UNKNOWN').upper(),\n                        'cve': vuln.get('cves', []),\n                        'fixed_in': vuln.get('fixAvailable', {}).get('version', 'N/A'),\n                        'source': 'npm_audit'\n                    })\n        except Exception as e:\n            results['error'] = str(e)\n\n        return results\n\n    def scan_python(self) -> Dict[str, Any]:\n        results = {\n            'ecosystem': 'python',\n            'vulnerabilities': []\n        }\n\n        try:\n            safety_result = subprocess.run(\n                ['safety', 'check', '--json'],\n                cwd=self.project_path,\n                capture_output=True,\n                text=True,\n                timeout=120\n            )\n\n            if safety_result.stdout:\n                safety_data = json.loads(safety_result.stdout)\n                for vuln in safety_data:\n                    results['vulnerabilities'].append({\n                        'package': vuln.get('package_name', ''),\n                        'version': vuln.get('analyzed_version', ''),\n                        'vulnerability_id': vuln.get('vulnerability_id', ''),\n                        'severity': 'HIGH',\n                        'fixed_in': vuln.get('fixed_version', ''),\n                        'source': 'safety'\n                    })\n        except Exception as e:\n            results['error'] = str(e)\n\n        return results\n\n    def scan_go(self) -> Dict[str, Any]:\n        results = {\n            'ecosystem': 'go',\n            'vulnerabilities': []\n        }\n\n        try:\n            govuln_result = subprocess.run(\n                ['govulncheck', '-json', './...'],\n                cwd=self.project_path,\n                capture_output=True,\n                text=True,\n                timeout=180\n            )\n\n            if govuln_result.stdout:\n                for line in govuln_result.stdout.strip().split('\\n'):\n                    if line:\n                        vuln_data = json.loads(line)\n                        if vuln_data.get('finding'):\n                            finding = vuln_data['finding']\n                            results['vulnerabilities'].append({\n                                'package': finding.get('osv', ''),\n                                'vulnerability_id': finding.get('osv', ''),\n                                'severity': 'HIGH',\n                                'source': 'govulncheck'\n                            })\n        except Exception as e:\n            results['error'] = str(e)\n\n        return results\n\n    def scan_rust(self) -> Dict[str, Any]:\n        results = {\n            'ecosystem': 'rust',\n            'vulnerabilities': []\n        }\n\n        try:\n            audit_result = subprocess.run(\n                ['cargo', 'audit', '--json'],\n                cwd=self.project_path,\n                capture_output=True,\n                text=True,\n                timeout=120\n            )\n\n            if audit_result.stdout:\n                audit_data = json.loads(audit_result.stdout)\n                for vuln in audit_data.get('vulnerabilities', {}).get('list', []):\n                    advisory = vuln.get('advisory', {})\n                    results['vulnerabilities'].append({\n                        'package': vuln.get('package', {}).get('name', ''),\n                        'version': vuln.get('package', {}).get('version', ''),\n                        'vulnerability_id': advisory.get('id', ''),\n                        'severity': 'HIGH',\n                        'source': 'cargo_audit'\n                    })\n        except Exception as e:\n            results['error'] = str(e)\n\n        return results\n\n    def _update_summary(self, results: Dict[str, Any]):\n        vulnerabilities = results['vulnerabilities']\n        results['summary']['total_vulnerabilities'] = len(vulnerabilities)\n\n        for vuln in vulnerabilities:\n            severity = vuln.get('severity', '').upper()\n            if severity == 'CRITICAL':\n                results['summary']['critical'] += 1\n            elif severity == 'HIGH':\n                results['summary']['high'] += 1\n            elif severity == 'MEDIUM':\n                results['summary']['medium'] += 1\n            elif severity == 'LOW':\n                results['summary']['low'] += 1\n\n    def generate_remediation_plan(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:\n        plan = {\n            'immediate_actions': [],\n            'short_term': [],\n            'automation_scripts': {}\n        }\n\n        critical_high = [v for v in vulnerabilities if v.get('severity', '').upper() in ['CRITICAL', 'HIGH']]\n\n        for vuln in critical_high[:20]:\n            plan['immediate_actions'].append({\n                'package': vuln.get('package', ''),\n                'current_version': vuln.get('version', ''),\n                'fixed_version': vuln.get('fixed_in', 'latest'),\n                'severity': vuln.get('severity', ''),\n                'priority': 1\n            })\n\n        plan['automation_scripts'] = {\n            'npm_fix': 'npm audit fix && npm update',\n            'pip_fix': 'pip-audit --fix && safety check',\n            'go_fix': 'go get -u ./... && go mod tidy',\n            'cargo_fix': 'cargo update && cargo audit'\n        }\n\n        return plan\n\n    def generate_sbom(self, ecosystems: Dict[str, Any]) -> Dict[str, Any]:\n        sbom = {\n            'bomFormat': 'CycloneDX',\n            'specVersion': '1.5',\n            'version': 1,\n            'metadata': {\n                'timestamp': datetime.now().isoformat()\n            },\n            'components': []\n        }\n\n        for ecosystem_name, ecosystem_data in ecosystems.items():\n            for vuln in ecosystem_data.get('vulnerabilities', []):\n                sbom['components'].append({\n                    'type': 'library',\n                    'name': vuln.get('package', ''),\n                    'version': vuln.get('version', ''),\n                    'purl': f\"pkg:{ecosystem_name}/{vuln.get('package', '')}@{vuln.get('version', '')}\"\n                })\n\n        return sbom\n```\n\n### 2. Vulnerability Prioritization\n\n```python\nclass VulnerabilityPrioritizer:\n    def calculate_priority_score(self, vulnerability: Dict) -> float:\n        cvss_score = vulnerability.get('cvss_score', 0) or 0\n        exploitability = 1.0 if vulnerability.get('exploit_available') else 0.5\n        fix_available = 1.0 if vulnerability.get('fixed_in') else 0.3\n\n        priority_score = (\n            cvss_score * 0.4 +\n            exploitability * 2.0 +\n            fix_available * 1.0\n        )\n\n        return round(priority_score, 2)\n\n    def prioritize_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:\n        for vuln in vulnerabilities:\n            vuln['priority_score'] = self.calculate_priority_score(vuln)\n\n        return sorted(vulnerabilities, key=lambda x: x['priority_score'], reverse=True)\n```\n\n### 3. CI/CD Integration\n\n```yaml\nname: Dependency Security Scan\n\non:\n  push:\n    branches: [main]\n  schedule:\n    - cron: '0 2 * * *'\n\njobs:\n  scan-dependencies:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        ecosystem: [npm, python, go]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: NPM Audit\n        if: matrix.ecosystem == 'npm'\n        run: |\n          npm ci\n          npm audit --json > npm-audit.json || true\n          npm audit --audit-level=moderate\n\n      - name: Python Safety\n        if: matrix.ecosystem == 'python'\n        run: |\n          pip install safety pip-audit\n          safety check --json --output safety.json || true\n          pip-audit --format=json --output=pip-audit.json || true\n\n      - name: Go Vulnerability Check\n        if: matrix.ecosystem == 'go'\n        run: |\n          go install golang.org/x/vuln/cmd/govulncheck@latest\n          govulncheck -json ./... > govulncheck.json || true\n\n      - name: Upload Results\n        uses: actions/upload-artifact@v4\n        with:\n          name: scan-${{ matrix.ecosystem }}\n          path: '*.json'\n\n      - name: Check Thresholds\n        run: |\n          CRITICAL=$(grep -o '\"severity\":\"CRITICAL\"' *.json 2>/dev/null | wc -l || echo 0)\n          if [ \"$CRITICAL\" -gt 0 ]; then\n            echo \"\u274c Found $CRITICAL critical vulnerabilities!\"\n            exit 1\n          fi\n```\n\n### 4. Automated Updates\n\n```bash\n#!/bin/bash\n# automated-dependency-update.sh\n\nset -euo pipefail\n\nECOSYSTEM=\"$1\"\nUPDATE_TYPE=\"${2:-patch}\"\n\nupdate_npm() {\n    npm audit --audit-level=moderate || true\n\n    if [ \"$UPDATE_TYPE\" = \"patch\" ]; then\n        npm update --save\n    elif [ \"$UPDATE_TYPE\" = \"minor\" ]; then\n        npx npm-check-updates -u --target minor\n        npm install\n    fi\n\n    npm test\n    npm audit --audit-level=moderate\n}\n\nupdate_python() {\n    pip install --upgrade pip\n    pip-audit --fix\n    safety check\n    pytest\n}\n\nupdate_go() {\n    go get -u ./...\n    go mod tidy\n    govulncheck ./...\n    go test ./...\n}\n\ncase \"$ECOSYSTEM\" in\n    npm) update_npm ;;\n    python) update_python ;;\n    go) update_go ;;\n    *)\n        echo \"Unknown ecosystem: $ECOSYSTEM\"\n        exit 1\n        ;;\nesac\n```\n\n### 5. Reporting\n\n```python\nclass VulnerabilityReporter:\n    def generate_markdown_report(self, scan_results: Dict[str, Any]) -> str:\n        report = f\"\"\"# Dependency Vulnerability Report\n\n**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n## Executive Summary\n\n- **Total Vulnerabilities:** {scan_results['summary']['total_vulnerabilities']}\n- **Critical:** {scan_results['summary']['critical']} \ud83d\udd34\n- **High:** {scan_results['summary']['high']} \ud83d\udfe0\n- **Medium:** {scan_results['summary']['medium']} \ud83d\udfe1\n- **Low:** {scan_results['summary']['low']} \ud83d\udfe2\n\n## Critical & High Severity\n\n\"\"\"\n\n        critical_high = [v for v in scan_results['vulnerabilities']\n                        if v.get('severity', '').upper() in ['CRITICAL', 'HIGH']]\n\n        for vuln in critical_high[:20]:\n            report += f\"\"\"\n### {vuln.get('package', 'Unknown')} - {vuln.get('vulnerability_id', '')}\n\n- **Severity:** {vuln.get('severity', 'UNKNOWN')}\n- **Current Version:** {vuln.get('version', '')}\n- **Fixed In:** {vuln.get('fixed_in', 'N/A')}\n- **CVE:** {', '.join(vuln.get('cve', []))}\n\n\"\"\"\n\n        return report\n\n    def generate_sarif(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:\n        return {\n            \"version\": \"2.1.0\",\n            \"$schema\": \"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json\",\n            \"runs\": [{\n                \"tool\": {\n                    \"driver\": {\n                        \"name\": \"Dependency Scanner\",\n                        \"version\": \"1.0.0\"\n                    }\n                },\n                \"results\": [\n                    {\n                        \"ruleId\": vuln.get('vulnerability_id', 'unknown'),\n                        \"level\": self._map_severity(vuln.get('severity', '')),\n                        \"message\": {\n                            \"text\": f\"{vuln.get('package', '')} has known vulnerability\"\n                        }\n                    }\n                    for vuln in scan_results['vulnerabilities']\n                ]\n            }]\n        }\n\n    def _map_severity(self, severity: str) -> str:\n        mapping = {\n            'CRITICAL': 'error',\n            'HIGH': 'error',\n            'MEDIUM': 'warning',\n            'LOW': 'note'\n        }\n        return mapping.get(severity.upper(), 'warning')\n```\n\n## Best Practices\n\n1. **Regular Scanning**: Run dependency scans daily via scheduled CI/CD\n2. **Prioritize by CVSS**: Focus on high CVSS scores and exploit availability\n3. **Staged Updates**: Auto-update patch versions, manual for major versions\n4. **Test Coverage**: Always run full test suite after updates\n5. **SBOM Generation**: Maintain up-to-date Software Bill of Materials\n6. **License Compliance**: Check for restrictive licenses\n7. **Rollback Strategy**: Create backup branches before major updates\n\n## Tool Installation\n\n```bash\n# Python\npip install safety pip-audit pipenv pip-licenses\n\n# JavaScript\nnpm install -g snyk npm-check-updates\n\n# Go\ngo install golang.org/x/vuln/cmd/govulncheck@latest\n\n# Rust\ncargo install cargo-audit\n```\n\n## Usage Examples\n\n```bash\n# Scan all dependencies\npython dependency_scanner.py scan --path .\n\n# Generate SBOM\npython dependency_scanner.py sbom --format cyclonedx\n\n# Auto-fix vulnerabilities\n./automated-dependency-update.sh npm patch\n\n# CI/CD integration\npython dependency_scanner.py scan --fail-on critical,high\n```\n\nFocus on automated vulnerability detection, risk assessment, and remediation across all major package ecosystems.\n"
    },
    {
      "name": "compliance-check",
      "title": "Regulatory Compliance Check",
      "description": "You are a compliance expert specializing in regulatory requirements for software systems including GDPR, HIPAA, SOC2, PCI-DSS, and other industry standards. Perform comprehensive compliance audits and",
      "plugin": "security-compliance",
      "source_path": "plugins/security-compliance/commands/compliance-check.md",
      "category": "security",
      "keywords": [
        "compliance",
        "soc2",
        "hipaa",
        "gdpr",
        "secrets",
        "regulatory"
      ],
      "content": "# Regulatory Compliance Check\n\nYou are a compliance expert specializing in regulatory requirements for software systems including GDPR, HIPAA, SOC2, PCI-DSS, and other industry standards. Perform comprehensive compliance audits and provide implementation guidance for achieving and maintaining compliance.\n\n## Context\nThe user needs to ensure their application meets regulatory requirements and industry standards. Focus on practical implementation of compliance controls, automated monitoring, and audit trail generation.\n\n## Requirements\n$ARGUMENTS\n\n## Instructions\n\n### 1. Compliance Framework Analysis\n\nIdentify applicable regulations and standards:\n\n**Regulatory Mapping**\n```python\nclass ComplianceAnalyzer:\n    def __init__(self):\n        self.regulations = {\n            'GDPR': {\n                'scope': 'EU data protection',\n                'applies_if': [\n                    'Processing EU residents data',\n                    'Offering goods/services to EU',\n                    'Monitoring EU residents behavior'\n                ],\n                'key_requirements': [\n                    'Privacy by design',\n                    'Data minimization',\n                    'Right to erasure',\n                    'Data portability',\n                    'Consent management',\n                    'DPO appointment',\n                    'Privacy notices',\n                    'Data breach notification (72hrs)'\n                ]\n            },\n            'HIPAA': {\n                'scope': 'Healthcare data protection (US)',\n                'applies_if': [\n                    'Healthcare providers',\n                    'Health plan providers', \n                    'Healthcare clearinghouses',\n                    'Business associates'\n                ],\n                'key_requirements': [\n                    'PHI encryption',\n                    'Access controls',\n                    'Audit logs',\n                    'Business Associate Agreements',\n                    'Risk assessments',\n                    'Employee training',\n                    'Incident response',\n                    'Physical safeguards'\n                ]\n            },\n            'SOC2': {\n                'scope': 'Service organization controls',\n                'applies_if': [\n                    'SaaS providers',\n                    'Data processors',\n                    'Cloud services'\n                ],\n                'trust_principles': [\n                    'Security',\n                    'Availability', \n                    'Processing integrity',\n                    'Confidentiality',\n                    'Privacy'\n                ]\n            },\n            'PCI-DSS': {\n                'scope': 'Payment card data security',\n                'applies_if': [\n                    'Accept credit/debit cards',\n                    'Process card payments',\n                    'Store card data',\n                    'Transmit card data'\n                ],\n                'compliance_levels': {\n                    'Level 1': '>6M transactions/year',\n                    'Level 2': '1M-6M transactions/year',\n                    'Level 3': '20K-1M transactions/year',\n                    'Level 4': '<20K transactions/year'\n                }\n            }\n        }\n    \n    def determine_applicable_regulations(self, business_info):\n        \"\"\"\n        Determine which regulations apply based on business context\n        \"\"\"\n        applicable = []\n        \n        # Check each regulation\n        for reg_name, reg_info in self.regulations.items():\n            if self._check_applicability(business_info, reg_info):\n                applicable.append({\n                    'regulation': reg_name,\n                    'reason': self._get_applicability_reason(business_info, reg_info),\n                    'priority': self._calculate_priority(business_info, reg_name)\n                })\n        \n        return sorted(applicable, key=lambda x: x['priority'], reverse=True)\n```\n\n### 2. Data Privacy Compliance\n\nImplement privacy controls:\n\n**GDPR Implementation**\n```python\nclass GDPRCompliance:\n    def implement_privacy_controls(self):\n        \"\"\"\n        Implement GDPR-required privacy controls\n        \"\"\"\n        controls = {}\n        \n        # 1. Consent Management\n        controls['consent_management'] = '''\nclass ConsentManager:\n    def __init__(self):\n        self.consent_types = [\n            'marketing_emails',\n            'analytics_tracking',\n            'third_party_sharing',\n            'profiling'\n        ]\n    \n    def record_consent(self, user_id, consent_type, granted):\n        \"\"\"\n        Record user consent with full audit trail\n        \"\"\"\n        consent_record = {\n            'user_id': user_id,\n            'consent_type': consent_type,\n            'granted': granted,\n            'timestamp': datetime.utcnow(),\n            'ip_address': request.remote_addr,\n            'user_agent': request.headers.get('User-Agent'),\n            'version': self.get_current_privacy_policy_version(),\n            'method': 'explicit_checkbox'  # Not pre-ticked\n        }\n        \n        # Store in append-only audit log\n        self.consent_audit_log.append(consent_record)\n        \n        # Update current consent status\n        self.update_user_consents(user_id, consent_type, granted)\n        \n        return consent_record\n    \n    def verify_consent(self, user_id, consent_type):\n        \"\"\"\n        Verify if user has given consent for specific processing\n        \"\"\"\n        consent = self.get_user_consent(user_id, consent_type)\n        return consent and consent['granted'] and not consent.get('withdrawn')\n'''\n\n        # 2. Right to Erasure (Right to be Forgotten)\n        controls['right_to_erasure'] = '''\nclass DataErasureService:\n    def process_erasure_request(self, user_id, verification_token):\n        \"\"\"\n        Process GDPR Article 17 erasure request\n        \"\"\"\n        # Verify request authenticity\n        if not self.verify_erasure_token(user_id, verification_token):\n            raise ValueError(\"Invalid erasure request\")\n        \n        erasure_log = {\n            'user_id': user_id,\n            'requested_at': datetime.utcnow(),\n            'data_categories': []\n        }\n        \n        # 1. Personal data\n        self.erase_user_profile(user_id)\n        erasure_log['data_categories'].append('profile')\n        \n        # 2. User-generated content (anonymize instead of delete)\n        self.anonymize_user_content(user_id)\n        erasure_log['data_categories'].append('content_anonymized')\n        \n        # 3. Analytics data\n        self.remove_from_analytics(user_id)\n        erasure_log['data_categories'].append('analytics')\n        \n        # 4. Backup data (schedule deletion)\n        self.schedule_backup_deletion(user_id)\n        erasure_log['data_categories'].append('backups_scheduled')\n        \n        # 5. Notify third parties\n        self.notify_processors_of_erasure(user_id)\n        \n        # Keep minimal record for legal compliance\n        self.store_erasure_record(erasure_log)\n        \n        return {\n            'status': 'completed',\n            'erasure_id': erasure_log['id'],\n            'categories_erased': erasure_log['data_categories']\n        }\n'''\n\n        # 3. Data Portability\n        controls['data_portability'] = '''\nclass DataPortabilityService:\n    def export_user_data(self, user_id, format='json'):\n        \"\"\"\n        GDPR Article 20 - Data portability\n        \"\"\"\n        user_data = {\n            'export_date': datetime.utcnow().isoformat(),\n            'user_id': user_id,\n            'format_version': '2.0',\n            'data': {}\n        }\n        \n        # Collect all user data\n        user_data['data']['profile'] = self.get_user_profile(user_id)\n        user_data['data']['preferences'] = self.get_user_preferences(user_id)\n        user_data['data']['content'] = self.get_user_content(user_id)\n        user_data['data']['activity'] = self.get_user_activity(user_id)\n        user_data['data']['consents'] = self.get_consent_history(user_id)\n        \n        # Format based on request\n        if format == 'json':\n            return json.dumps(user_data, indent=2)\n        elif format == 'csv':\n            return self.convert_to_csv(user_data)\n        elif format == 'xml':\n            return self.convert_to_xml(user_data)\n'''\n        \n        return controls\n\n**Privacy by Design**\n```python\n# Implement privacy by design principles\nclass PrivacyByDesign:\n    def implement_data_minimization(self):\n        \"\"\"\n        Collect only necessary data\n        \"\"\"\n        # Before (collecting too much)\n        bad_user_model = {\n            'email': str,\n            'password': str,\n            'full_name': str,\n            'date_of_birth': date,\n            'ssn': str,  # Unnecessary\n            'address': str,  # Unnecessary for basic service\n            'phone': str,  # Unnecessary\n            'gender': str,  # Unnecessary\n            'income': int  # Unnecessary\n        }\n        \n        # After (data minimization)\n        good_user_model = {\n            'email': str,  # Required for authentication\n            'password_hash': str,  # Never store plain text\n            'display_name': str,  # Optional, user-provided\n            'created_at': datetime,\n            'last_login': datetime\n        }\n        \n        return good_user_model\n    \n    def implement_pseudonymization(self):\n        \"\"\"\n        Replace identifying fields with pseudonyms\n        \"\"\"\n        def pseudonymize_record(record):\n            # Generate consistent pseudonym\n            user_pseudonym = hashlib.sha256(\n                f\"{record['user_id']}{SECRET_SALT}\".encode()\n            ).hexdigest()[:16]\n            \n            return {\n                'pseudonym': user_pseudonym,\n                'data': {\n                    # Remove direct identifiers\n                    'age_group': self._get_age_group(record['age']),\n                    'region': self._get_region(record['ip_address']),\n                    'activity': record['activity_data']\n                }\n            }\n```\n\n### 3. Security Compliance\n\nImplement security controls for various standards:\n\n**SOC2 Security Controls**\n```python\nclass SOC2SecurityControls:\n    def implement_access_controls(self):\n        \"\"\"\n        SOC2 CC6.1 - Logical and physical access controls\n        \"\"\"\n        controls = {\n            'authentication': '''\n# Multi-factor authentication\nclass MFAEnforcement:\n    def enforce_mfa(self, user, resource_sensitivity):\n        if resource_sensitivity == 'high':\n            return self.require_mfa(user)\n        elif resource_sensitivity == 'medium' and user.is_admin:\n            return self.require_mfa(user)\n        return self.standard_auth(user)\n    \n    def require_mfa(self, user):\n        factors = []\n        \n        # Factor 1: Password (something you know)\n        factors.append(self.verify_password(user))\n        \n        # Factor 2: TOTP/SMS (something you have)\n        if user.mfa_method == 'totp':\n            factors.append(self.verify_totp(user))\n        elif user.mfa_method == 'sms':\n            factors.append(self.verify_sms_code(user))\n            \n        # Factor 3: Biometric (something you are) - optional\n        if user.biometric_enabled:\n            factors.append(self.verify_biometric(user))\n            \n        return all(factors)\n''',\n            'authorization': '''\n# Role-based access control\nclass RBACAuthorization:\n    def __init__(self):\n        self.roles = {\n            'admin': ['read', 'write', 'delete', 'admin'],\n            'user': ['read', 'write:own'],\n            'viewer': ['read']\n        }\n        \n    def check_permission(self, user, resource, action):\n        user_permissions = self.get_user_permissions(user)\n        \n        # Check explicit permissions\n        if action in user_permissions:\n            return True\n            \n        # Check ownership-based permissions\n        if f\"{action}:own\" in user_permissions:\n            return self.user_owns_resource(user, resource)\n            \n        # Log denied access attempt\n        self.log_access_denied(user, resource, action)\n        return False\n''',\n            'encryption': '''\n# Encryption at rest and in transit\nclass EncryptionControls:\n    def __init__(self):\n        self.kms = KeyManagementService()\n        \n    def encrypt_at_rest(self, data, classification):\n        if classification == 'sensitive':\n            # Use envelope encryption\n            dek = self.kms.generate_data_encryption_key()\n            encrypted_data = self.encrypt_with_key(data, dek)\n            encrypted_dek = self.kms.encrypt_key(dek)\n            \n            return {\n                'data': encrypted_data,\n                'encrypted_key': encrypted_dek,\n                'algorithm': 'AES-256-GCM',\n                'key_id': self.kms.get_current_key_id()\n            }\n    \n    def configure_tls(self):\n        return {\n            'min_version': 'TLS1.2',\n            'ciphers': [\n                'ECDHE-RSA-AES256-GCM-SHA384',\n                'ECDHE-RSA-AES128-GCM-SHA256'\n            ],\n            'hsts': 'max-age=31536000; includeSubDomains',\n            'certificate_pinning': True\n        }\n'''\n        }\n        \n        return controls\n```\n\n### 4. Audit Logging and Monitoring\n\nImplement comprehensive audit trails:\n\n**Audit Log System**\n```python\nclass ComplianceAuditLogger:\n    def __init__(self):\n        self.required_events = {\n            'authentication': [\n                'login_success',\n                'login_failure',\n                'logout',\n                'password_change',\n                'mfa_enabled',\n                'mfa_disabled'\n            ],\n            'authorization': [\n                'access_granted',\n                'access_denied',\n                'permission_changed',\n                'role_assigned',\n                'role_revoked'\n            ],\n            'data_access': [\n                'data_viewed',\n                'data_exported',\n                'data_modified',\n                'data_deleted',\n                'bulk_operation'\n            ],\n            'compliance': [\n                'consent_given',\n                'consent_withdrawn',\n                'data_request',\n                'data_erasure',\n                'privacy_settings_changed'\n            ]\n        }\n    \n    def log_event(self, event_type, details):\n        \"\"\"\n        Create tamper-proof audit log entry\n        \"\"\"\n        log_entry = {\n            'id': str(uuid.uuid4()),\n            'timestamp': datetime.utcnow().isoformat(),\n            'event_type': event_type,\n            'user_id': details.get('user_id'),\n            'ip_address': self._get_ip_address(),\n            'user_agent': request.headers.get('User-Agent'),\n            'session_id': session.get('id'),\n            'details': details,\n            'compliance_flags': self._get_compliance_flags(event_type)\n        }\n        \n        # Add integrity check\n        log_entry['checksum'] = self._calculate_checksum(log_entry)\n        \n        # Store in immutable log\n        self._store_audit_log(log_entry)\n        \n        # Real-time alerting for critical events\n        if self._is_critical_event(event_type):\n            self._send_security_alert(log_entry)\n        \n        return log_entry\n    \n    def _calculate_checksum(self, entry):\n        \"\"\"\n        Create tamper-evident checksum\n        \"\"\"\n        # Include previous entry hash for blockchain-like integrity\n        previous_hash = self._get_previous_entry_hash()\n        \n        content = json.dumps(entry, sort_keys=True)\n        return hashlib.sha256(\n            f\"{previous_hash}{content}{SECRET_KEY}\".encode()\n        ).hexdigest()\n```\n\n**Compliance Reporting**\n```python\ndef generate_compliance_report(self, regulation, period):\n    \"\"\"\n    Generate compliance report for auditors\n    \"\"\"\n    report = {\n        'regulation': regulation,\n        'period': period,\n        'generated_at': datetime.utcnow(),\n        'sections': {}\n    }\n    \n    if regulation == 'GDPR':\n        report['sections'] = {\n            'data_processing_activities': self._get_processing_activities(period),\n            'consent_metrics': self._get_consent_metrics(period),\n            'data_requests': {\n                'access_requests': self._count_access_requests(period),\n                'erasure_requests': self._count_erasure_requests(period),\n                'portability_requests': self._count_portability_requests(period),\n                'response_times': self._calculate_response_times(period)\n            },\n            'data_breaches': self._get_breach_reports(period),\n            'third_party_processors': self._list_processors(),\n            'privacy_impact_assessments': self._get_dpias(period)\n        }\n    \n    elif regulation == 'HIPAA':\n        report['sections'] = {\n            'access_controls': self._audit_access_controls(period),\n            'phi_access_log': self._get_phi_access_log(period),\n            'risk_assessments': self._get_risk_assessments(period),\n            'training_records': self._get_training_compliance(period),\n            'business_associates': self._list_bas_with_agreements(),\n            'incident_response': self._get_incident_reports(period)\n        }\n    \n    return report\n```\n\n### 5. Healthcare Compliance (HIPAA)\n\nImplement HIPAA-specific controls:\n\n**PHI Protection**\n```python\nclass HIPAACompliance:\n    def protect_phi(self):\n        \"\"\"\n        Implement HIPAA safeguards for Protected Health Information\n        \"\"\"\n        # Technical Safeguards\n        technical_controls = {\n            'access_control': '''\nclass PHIAccessControl:\n    def __init__(self):\n        self.minimum_necessary_rule = True\n        \n    def grant_phi_access(self, user, patient_id, purpose):\n        \"\"\"\n        Implement minimum necessary standard\n        \"\"\"\n        # Verify legitimate purpose\n        if not self._verify_treatment_relationship(user, patient_id, purpose):\n            self._log_denied_access(user, patient_id, purpose)\n            raise PermissionError(\"No treatment relationship\")\n        \n        # Grant limited access based on role and purpose\n        access_scope = self._determine_access_scope(user.role, purpose)\n        \n        # Time-limited access\n        access_token = {\n            'user_id': user.id,\n            'patient_id': patient_id,\n            'scope': access_scope,\n            'purpose': purpose,\n            'expires_at': datetime.utcnow() + timedelta(hours=24),\n            'audit_id': str(uuid.uuid4())\n        }\n        \n        # Log all access\n        self._log_phi_access(access_token)\n        \n        return access_token\n''',\n            'encryption': '''\nclass PHIEncryption:\n    def encrypt_phi_at_rest(self, phi_data):\n        \"\"\"\n        HIPAA-compliant encryption for PHI\n        \"\"\"\n        # Use FIPS 140-2 validated encryption\n        encryption_config = {\n            'algorithm': 'AES-256-CBC',\n            'key_derivation': 'PBKDF2',\n            'iterations': 100000,\n            'validation': 'FIPS-140-2-Level-2'\n        }\n        \n        # Encrypt PHI fields\n        encrypted_phi = {}\n        for field, value in phi_data.items():\n            if self._is_phi_field(field):\n                encrypted_phi[field] = self._encrypt_field(value, encryption_config)\n            else:\n                encrypted_phi[field] = value\n        \n        return encrypted_phi\n    \n    def secure_phi_transmission(self):\n        \"\"\"\n        Secure PHI during transmission\n        \"\"\"\n        return {\n            'protocols': ['TLS 1.2+'],\n            'vpn_required': True,\n            'email_encryption': 'S/MIME or PGP required',\n            'fax_alternative': 'Secure messaging portal'\n        }\n'''\n        }\n        \n        # Administrative Safeguards\n        admin_controls = {\n            'workforce_training': '''\nclass HIPAATraining:\n    def track_training_compliance(self, employee):\n        \"\"\"\n        Ensure workforce HIPAA training compliance\n        \"\"\"\n        required_modules = [\n            'HIPAA Privacy Rule',\n            'HIPAA Security Rule', \n            'PHI Handling Procedures',\n            'Breach Notification',\n            'Patient Rights',\n            'Minimum Necessary Standard'\n        ]\n        \n        training_status = {\n            'employee_id': employee.id,\n            'completed_modules': [],\n            'pending_modules': [],\n            'last_training_date': None,\n            'next_due_date': None\n        }\n        \n        for module in required_modules:\n            completion = self._check_module_completion(employee.id, module)\n            if completion and completion['date'] > datetime.now() - timedelta(days=365):\n                training_status['completed_modules'].append(module)\n            else:\n                training_status['pending_modules'].append(module)\n        \n        return training_status\n'''\n        }\n        \n        return {\n            'technical': technical_controls,\n            'administrative': admin_controls\n        }\n```\n\n### 6. Payment Card Compliance (PCI-DSS)\n\nImplement PCI-DSS requirements:\n\n**PCI-DSS Controls**\n```python\nclass PCIDSSCompliance:\n    def implement_pci_controls(self):\n        \"\"\"\n        Implement PCI-DSS v4.0 requirements\n        \"\"\"\n        controls = {\n            'cardholder_data_protection': '''\nclass CardDataProtection:\n    def __init__(self):\n        # Never store these\n        self.prohibited_data = ['cvv', 'cvv2', 'cvc2', 'cid', 'pin', 'pin_block']\n        \n    def handle_card_data(self, card_info):\n        \"\"\"\n        PCI-DSS compliant card data handling\n        \"\"\"\n        # Immediately tokenize\n        token = self.tokenize_card(card_info)\n        \n        # If must store, only store allowed fields\n        stored_data = {\n            'token': token,\n            'last_four': card_info['number'][-4:],\n            'exp_month': card_info['exp_month'],\n            'exp_year': card_info['exp_year'],\n            'cardholder_name': self._encrypt(card_info['name'])\n        }\n        \n        # Never log full card number\n        self._log_transaction(token, 'XXXX-XXXX-XXXX-' + stored_data['last_four'])\n        \n        return stored_data\n    \n    def tokenize_card(self, card_info):\n        \"\"\"\n        Replace PAN with token\n        \"\"\"\n        # Use payment processor tokenization\n        response = payment_processor.tokenize({\n            'number': card_info['number'],\n            'exp_month': card_info['exp_month'],\n            'exp_year': card_info['exp_year']\n        })\n        \n        return response['token']\n''',\n            'network_segmentation': '''\n# Network segmentation for PCI compliance\nclass PCINetworkSegmentation:\n    def configure_network_zones(self):\n        \"\"\"\n        Implement network segmentation\n        \"\"\"\n        zones = {\n            'cde': {  # Cardholder Data Environment\n                'description': 'Systems that process, store, or transmit CHD',\n                'controls': [\n                    'Firewall required',\n                    'IDS/IPS monitoring',\n                    'No direct internet access',\n                    'Quarterly vulnerability scans',\n                    'Annual penetration testing'\n                ]\n            },\n            'dmz': {\n                'description': 'Public-facing systems',\n                'controls': [\n                    'Web application firewall',\n                    'No CHD storage allowed',\n                    'Regular security scanning'\n                ]\n            },\n            'internal': {\n                'description': 'Internal corporate network',\n                'controls': [\n                    'Segmented from CDE',\n                    'Limited CDE access',\n                    'Standard security controls'\n                ]\n            }\n        }\n        \n        return zones\n''',\n            'vulnerability_management': '''\nclass PCIVulnerabilityManagement:\n    def quarterly_scan_requirements(self):\n        \"\"\"\n        PCI-DSS quarterly scan requirements\n        \"\"\"\n        scan_config = {\n            'internal_scans': {\n                'frequency': 'quarterly',\n                'scope': 'all CDE systems',\n                'tool': 'PCI-approved scanning vendor',\n                'passing_criteria': 'No high-risk vulnerabilities'\n            },\n            'external_scans': {\n                'frequency': 'quarterly', \n                'performed_by': 'ASV (Approved Scanning Vendor)',\n                'scope': 'All external-facing IP addresses',\n                'passing_criteria': 'Clean scan with no failures'\n            },\n            'remediation_timeline': {\n                'critical': '24 hours',\n                'high': '7 days',\n                'medium': '30 days',\n                'low': '90 days'\n            }\n        }\n        \n        return scan_config\n'''\n        }\n        \n        return controls\n```\n\n### 7. Continuous Compliance Monitoring\n\nSet up automated compliance monitoring:\n\n**Compliance Dashboard**\n```python\nclass ComplianceDashboard:\n    def generate_realtime_dashboard(self):\n        \"\"\"\n        Real-time compliance status dashboard\n        \"\"\"\n        dashboard = {\n            'timestamp': datetime.utcnow(),\n            'overall_compliance_score': 0,\n            'regulations': {}\n        }\n        \n        # GDPR Compliance Metrics\n        dashboard['regulations']['GDPR'] = {\n            'score': self.calculate_gdpr_score(),\n            'status': 'COMPLIANT',\n            'metrics': {\n                'consent_rate': '87%',\n                'data_requests_sla': '98% within 30 days',\n                'privacy_policy_version': '2.1',\n                'last_dpia': '2025-06-15',\n                'encryption_coverage': '100%',\n                'third_party_agreements': '12/12 signed'\n            },\n            'issues': [\n                {\n                    'severity': 'medium',\n                    'issue': 'Cookie consent banner update needed',\n                    'due_date': '2025-08-01'\n                }\n            ]\n        }\n        \n        # HIPAA Compliance Metrics\n        dashboard['regulations']['HIPAA'] = {\n            'score': self.calculate_hipaa_score(),\n            'status': 'NEEDS_ATTENTION',\n            'metrics': {\n                'risk_assessment_current': True,\n                'workforce_training_compliance': '94%',\n                'baa_agreements': '8/8 current',\n                'encryption_status': 'All PHI encrypted',\n                'access_reviews': 'Completed 2025-06-30',\n                'incident_response_tested': '2025-05-15'\n            },\n            'issues': [\n                {\n                    'severity': 'high',\n                    'issue': '3 employees overdue for training',\n                    'due_date': '2025-07-25'\n                }\n            ]\n        }\n        \n        return dashboard\n```\n\n**Automated Compliance Checks**\n```yaml\n# .github/workflows/compliance-check.yml\nname: Compliance Checks\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n  schedule:\n    - cron: '0 0 * * *'  # Daily compliance check\n\njobs:\n  compliance-scan:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: GDPR Compliance Check\n      run: |\n        python scripts/compliance/gdpr_checker.py\n        \n    - name: Security Headers Check\n      run: |\n        python scripts/compliance/security_headers.py\n        \n    - name: Dependency License Check\n      run: |\n        license-checker --onlyAllow 'MIT;Apache-2.0;BSD-3-Clause;ISC'\n        \n    - name: PII Detection Scan\n      run: |\n        # Scan for hardcoded PII\n        python scripts/compliance/pii_scanner.py\n        \n    - name: Encryption Verification\n      run: |\n        # Verify all sensitive data is encrypted\n        python scripts/compliance/encryption_checker.py\n        \n    - name: Generate Compliance Report\n      if: always()\n      run: |\n        python scripts/compliance/generate_report.py > compliance-report.json\n        \n    - name: Upload Compliance Report\n      uses: actions/upload-artifact@v3\n      with:\n        name: compliance-report\n        path: compliance-report.json\n```\n\n### 8. Compliance Documentation\n\nGenerate required documentation:\n\n**Privacy Policy Generator**\n```python\ndef generate_privacy_policy(company_info, data_practices):\n    \"\"\"\n    Generate GDPR-compliant privacy policy\n    \"\"\"\n    policy = f\"\"\"\n# Privacy Policy\n\n**Last Updated**: {datetime.now().strftime('%B %d, %Y')}\n\n## 1. Data Controller\n{company_info['name']}\n{company_info['address']}\nEmail: {company_info['privacy_email']}\nDPO: {company_info.get('dpo_contact', 'privacy@company.com')}\n\n## 2. Data We Collect\n{generate_data_collection_section(data_practices['data_types'])}\n\n## 3. Legal Basis for Processing\n{generate_legal_basis_section(data_practices['purposes'])}\n\n## 4. Your Rights\nUnder GDPR, you have the following rights:\n- Right to access your personal data\n- Right to rectification \n- Right to erasure ('right to be forgotten')\n- Right to restrict processing\n- Right to data portability\n- Right to object\n- Rights related to automated decision making\n\n## 5. Data Retention\n{generate_retention_policy(data_practices['retention_periods'])}\n\n## 6. International Transfers\n{generate_transfer_section(data_practices['international_transfers'])}\n\n## 7. Contact Us\nTo exercise your rights, contact: {company_info['privacy_email']}\n\"\"\"\n    \n    return policy\n```\n\n## Output Format\n\n1. **Compliance Assessment**: Current compliance status across all applicable regulations\n2. **Gap Analysis**: Specific areas needing attention with severity ratings\n3. **Implementation Plan**: Prioritized roadmap for achieving compliance\n4. **Technical Controls**: Code implementations for required controls\n5. **Policy Templates**: Privacy policies, consent forms, and notices\n6. **Audit Procedures**: Scripts for continuous compliance monitoring\n7. **Documentation**: Required records and evidence for auditors\n8. **Training Materials**: Workforce compliance training resources\n\nFocus on practical implementation that balances compliance requirements with business operations and user experience."
    },
    {
      "name": "xss-scan",
      "title": "XSS Vulnerability Scanner for Frontend Code",
      "description": "You are a frontend security specialist focusing on Cross-Site Scripting (XSS) vulnerability detection and prevention. Analyze React, Vue, Angular, and vanilla JavaScript code to identify injection poi",
      "plugin": "frontend-mobile-security",
      "source_path": "plugins/frontend-mobile-security/commands/xss-scan.md",
      "category": "security",
      "keywords": [
        "frontend-security",
        "mobile-security",
        "xss",
        "csrf",
        "csp"
      ],
      "content": "# XSS Vulnerability Scanner for Frontend Code\n\nYou are a frontend security specialist focusing on Cross-Site Scripting (XSS) vulnerability detection and prevention. Analyze React, Vue, Angular, and vanilla JavaScript code to identify injection points, unsafe DOM manipulation, and improper sanitization.\n\n## Context\n\nThe user needs comprehensive XSS vulnerability scanning for client-side code, identifying dangerous patterns like unsafe HTML manipulation, URL handling issues, and improper user input rendering. Focus on context-aware detection and framework-specific security patterns.\n\n## Requirements\n\n$ARGUMENTS\n\n## Instructions\n\n### 1. XSS Vulnerability Detection\n\nScan codebase for XSS vulnerabilities using static analysis:\n\n```typescript\ninterface XSSFinding {\n  file: string;\n  line: number;\n  severity: 'critical' | 'high' | 'medium' | 'low';\n  type: string;\n  vulnerable_code: string;\n  description: string;\n  fix: string;\n  cwe: string;\n}\n\nclass XSSScanner {\n  private vulnerablePatterns = [\n    'innerHTML', 'outerHTML', 'document.write',\n    'insertAdjacentHTML', 'location.href', 'window.open'\n  ];\n\n  async scanDirectory(path: string): Promise<XSSFinding[]> {\n    const files = await this.findJavaScriptFiles(path);\n    const findings: XSSFinding[] = [];\n\n    for (const file of files) {\n      const content = await fs.readFile(file, 'utf-8');\n      findings.push(...this.scanFile(file, content));\n    }\n\n    return findings;\n  }\n\n  scanFile(filePath: string, content: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n\n    findings.push(...this.detectHTMLManipulation(filePath, content));\n    findings.push(...this.detectReactVulnerabilities(filePath, content));\n    findings.push(...this.detectURLVulnerabilities(filePath, content));\n    findings.push(...this.detectEventHandlerIssues(filePath, content));\n\n    return findings;\n  }\n\n  detectHTMLManipulation(file: string, content: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n    const lines = content.split('\\n');\n\n    lines.forEach((line, index) => {\n      if (line.includes('innerHTML') && this.hasUserInput(line)) {\n        findings.push({\n          file,\n          line: index + 1,\n          severity: 'critical',\n          type: 'Unsafe HTML manipulation',\n          vulnerable_code: line.trim(),\n          description: 'User-controlled data in HTML manipulation creates XSS risk',\n          fix: 'Use textContent for plain text or sanitize with DOMPurify library',\n          cwe: 'CWE-79'\n        });\n      }\n    });\n\n    return findings;\n  }\n\n  detectReactVulnerabilities(file: string, content: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n    const lines = content.split('\\n');\n\n    lines.forEach((line, index) => {\n      if (line.includes('dangerously') && !this.hasSanitization(content)) {\n        findings.push({\n          file,\n          line: index + 1,\n          severity: 'high',\n          type: 'React unsafe HTML rendering',\n          vulnerable_code: line.trim(),\n          description: 'Unsanitized HTML in React component creates XSS vulnerability',\n          fix: 'Apply DOMPurify.sanitize() before rendering or use safe alternatives',\n          cwe: 'CWE-79'\n        });\n      }\n    });\n\n    return findings;\n  }\n\n  detectURLVulnerabilities(file: string, content: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n    const lines = content.split('\\n');\n\n    lines.forEach((line, index) => {\n      if (line.includes('location.') && this.hasUserInput(line)) {\n        findings.push({\n          file,\n          line: index + 1,\n          severity: 'high',\n          type: 'URL injection',\n          vulnerable_code: line.trim(),\n          description: 'User input in URL assignment can execute malicious code',\n          fix: 'Validate URLs and enforce http/https protocols only',\n          cwe: 'CWE-79'\n        });\n      }\n    });\n\n    return findings;\n  }\n\n  hasUserInput(line: string): boolean {\n    const indicators = ['props', 'state', 'params', 'query', 'input', 'formData'];\n    return indicators.some(indicator => line.includes(indicator));\n  }\n\n  hasSanitization(content: string): boolean {\n    return content.includes('DOMPurify') || content.includes('sanitize');\n  }\n}\n```\n\n### 2. Framework-Specific Detection\n\n```typescript\nclass ReactXSSScanner {\n  scanReactComponent(code: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n\n    // Check for unsafe React patterns\n    const unsafePatterns = [\n      'dangerouslySetInnerHTML',\n      'createMarkup',\n      'rawHtml'\n    ];\n\n    unsafePatterns.forEach(pattern => {\n      if (code.includes(pattern) && !code.includes('DOMPurify')) {\n        findings.push({\n          severity: 'high',\n          type: 'React XSS risk',\n          description: `Pattern ${pattern} used without sanitization`,\n          fix: 'Apply proper HTML sanitization'\n        });\n      }\n    });\n\n    return findings;\n  }\n}\n\nclass VueXSSScanner {\n  scanVueTemplate(template: string): XSSFinding[] {\n    const findings: XSSFinding[] = [];\n\n    if (template.includes('v-html')) {\n      findings.push({\n        severity: 'high',\n        type: 'Vue HTML injection',\n        description: 'v-html directive renders raw HTML',\n        fix: 'Use v-text for plain text or sanitize HTML'\n      });\n    }\n\n    return findings;\n  }\n}\n```\n\n### 3. Secure Coding Examples\n\n```typescript\nclass SecureCodingGuide {\n  getSecurePattern(vulnerability: string): string {\n    const patterns = {\n      html_manipulation: `\n// SECURE: Use textContent for plain text\nelement.textContent = userInput;\n\n// SECURE: Sanitize HTML when needed\nimport DOMPurify from 'dompurify';\nconst clean = DOMPurify.sanitize(userInput);\nelement.innerHTML = clean;`,\n\n      url_handling: `\n// SECURE: Validate and sanitize URLs\nfunction sanitizeURL(url: string): string {\n  try {\n    const parsed = new URL(url);\n    if (['http:', 'https:'].includes(parsed.protocol)) {\n      return parsed.href;\n    }\n  } catch {}\n  return '#';\n}`,\n\n      react_rendering: `\n// SECURE: Sanitize before rendering\nimport DOMPurify from 'dompurify';\n\nconst Component = ({ html }) => (\n  <div dangerouslySetInnerHTML={{\n    __html: DOMPurify.sanitize(html)\n  }} />\n);`\n    };\n\n    return patterns[vulnerability] || 'No secure pattern available';\n  }\n}\n```\n\n### 4. Automated Scanning Integration\n\n```bash\n# ESLint with security plugin\nnpm install --save-dev eslint-plugin-security\neslint . --plugin security\n\n# Semgrep for XSS patterns\nsemgrep --config=p/xss --json\n\n# Custom XSS scanner\nnode xss-scanner.js --path=src --format=json\n```\n\n### 5. Report Generation\n\n```typescript\nclass XSSReportGenerator {\n  generateReport(findings: XSSFinding[]): string {\n    const grouped = this.groupBySeverity(findings);\n\n    let report = '# XSS Vulnerability Scan Report\\n\\n';\n    report += `Total Findings: ${findings.length}\\n\\n`;\n\n    for (const [severity, issues] of Object.entries(grouped)) {\n      report += `## ${severity.toUpperCase()} (${issues.length})\\n\\n`;\n\n      for (const issue of issues) {\n        report += `- **${issue.type}**\\n`;\n        report += `  File: ${issue.file}:${issue.line}\\n`;\n        report += `  Fix: ${issue.fix}\\n\\n`;\n      }\n    }\n\n    return report;\n  }\n\n  groupBySeverity(findings: XSSFinding[]): Record<string, XSSFinding[]> {\n    return findings.reduce((acc, finding) => {\n      if (!acc[finding.severity]) acc[finding.severity] = [];\n      acc[finding.severity].push(finding);\n      return acc;\n    }, {} as Record<string, XSSFinding[]>);\n  }\n}\n```\n\n### 6. Prevention Checklist\n\n**HTML Manipulation**\n- Never use innerHTML with user input\n- Prefer textContent for text content\n- Sanitize with DOMPurify before rendering HTML\n- Avoid document.write entirely\n\n**URL Handling**\n- Validate all URLs before assignment\n- Block javascript: and data: protocols\n- Use URL constructor for validation\n- Sanitize href attributes\n\n**Event Handlers**\n- Use addEventListener instead of inline handlers\n- Sanitize all event handler input\n- Avoid string-to-code patterns\n\n**Framework-Specific**\n- React: Sanitize before using unsafe APIs\n- Vue: Prefer v-text over v-html\n- Angular: Use built-in sanitization\n- Avoid bypassing framework security features\n\n## Output Format\n\n1. **Vulnerability Report**: Detailed findings with severity levels\n2. **Risk Analysis**: Impact assessment for each vulnerability\n3. **Fix Recommendations**: Secure code examples\n4. **Sanitization Guide**: DOMPurify usage patterns\n5. **Prevention Checklist**: Best practices for XSS prevention\n\nFocus on identifying XSS attack vectors, providing actionable fixes, and establishing secure coding patterns.\n"
    }
  ]
}