{
  "plugin": "developer-essentials",
  "agents": [],
  "commands": [],
  "skills": [
    {
      "name": "git-advanced-workflows",
      "description": "Master advanced Git workflows including rebasing, cherry-picking, bisect, worktrees, and reflog to maintain clean history and recover from any situation. Use when managing complex Git histories, collaborating on feature branches, or troubleshooting repository issues.",
      "plugin": "developer-essentials",
      "source_path": "plugins/developer-essentials/skills/git-advanced-workflows/SKILL.md",
      "category": "development",
      "keywords": [
        "git",
        "sql",
        "debugging",
        "testing",
        "authentication",
        "code-review",
        "monorepo",
        "essential"
      ],
      "content": "---\nname: git-advanced-workflows\ndescription: Master advanced Git workflows including rebasing, cherry-picking, bisect, worktrees, and reflog to maintain clean history and recover from any situation. Use when managing complex Git histories, collaborating on feature branches, or troubleshooting repository issues.\n---\n\n# Git Advanced Workflows\n\nMaster advanced Git techniques to maintain clean history, collaborate effectively, and recover from any situation with confidence.\n\n## When to Use This Skill\n\n- Cleaning up commit history before merging\n- Applying specific commits across branches\n- Finding commits that introduced bugs\n- Working on multiple features simultaneously\n- Recovering from Git mistakes or lost commits\n- Managing complex branch workflows\n- Preparing clean PRs for review\n- Synchronizing diverged branches\n\n## Core Concepts\n\n### 1. Interactive Rebase\n\nInteractive rebase is the Swiss Army knife of Git history editing.\n\n**Common Operations:**\n- `pick`: Keep commit as-is\n- `reword`: Change commit message\n- `edit`: Amend commit content\n- `squash`: Combine with previous commit\n- `fixup`: Like squash but discard message\n- `drop`: Remove commit entirely\n\n**Basic Usage:**\n```bash\n# Rebase last 5 commits\ngit rebase -i HEAD~5\n\n# Rebase all commits on current branch\ngit rebase -i $(git merge-base HEAD main)\n\n# Rebase onto specific commit\ngit rebase -i abc123\n```\n\n### 2. Cherry-Picking\n\nApply specific commits from one branch to another without merging entire branches.\n\n```bash\n# Cherry-pick single commit\ngit cherry-pick abc123\n\n# Cherry-pick range of commits (exclusive start)\ngit cherry-pick abc123..def456\n\n# Cherry-pick without committing (stage changes only)\ngit cherry-pick -n abc123\n\n# Cherry-pick and edit commit message\ngit cherry-pick -e abc123\n```\n\n### 3. Git Bisect\n\nBinary search through commit history to find the commit that introduced a bug.\n\n```bash\n# Start bisect\ngit bisect start\n\n# Mark current commit as bad\ngit bisect bad\n\n# Mark known good commit\ngit bisect good v1.0.0\n\n# Git will checkout middle commit - test it\n# Then mark as good or bad\ngit bisect good  # or: git bisect bad\n\n# Continue until bug found\n# When done\ngit bisect reset\n```\n\n**Automated Bisect:**\n```bash\n# Use script to test automatically\ngit bisect start HEAD v1.0.0\ngit bisect run ./test.sh\n\n# test.sh should exit 0 for good, 1-127 (except 125) for bad\n```\n\n### 4. Worktrees\n\nWork on multiple branches simultaneously without stashing or switching.\n\n```bash\n# List existing worktrees\ngit worktree list\n\n# Add new worktree for feature branch\ngit worktree add ../project-feature feature/new-feature\n\n# Add worktree and create new branch\ngit worktree add -b bugfix/urgent ../project-hotfix main\n\n# Remove worktree\ngit worktree remove ../project-feature\n\n# Prune stale worktrees\ngit worktree prune\n```\n\n### 5. Reflog\n\nYour safety net - tracks all ref movements, even deleted commits.\n\n```bash\n# View reflog\ngit reflog\n\n# View reflog for specific branch\ngit reflog show feature/branch\n\n# Restore deleted commit\ngit reflog\n# Find commit hash\ngit checkout abc123\ngit branch recovered-branch\n\n# Restore deleted branch\ngit reflog\ngit branch deleted-branch abc123\n```\n\n## Practical Workflows\n\n### Workflow 1: Clean Up Feature Branch Before PR\n\n```bash\n# Start with feature branch\ngit checkout feature/user-auth\n\n# Interactive rebase to clean history\ngit rebase -i main\n\n# Example rebase operations:\n# - Squash \"fix typo\" commits\n# - Reword commit messages for clarity\n# - Reorder commits logically\n# - Drop unnecessary commits\n\n# Force push cleaned branch (safe if no one else is using it)\ngit push --force-with-lease origin feature/user-auth\n```\n\n### Workflow 2: Apply Hotfix to Multiple Releases\n\n```bash\n# Create fix on main\ngit checkout main\ngit commit -m \"fix: critical security patch\"\n\n# Apply to release branches\ngit checkout release/2.0\ngit cherry-pick abc123\n\ngit checkout release/1.9\ngit cherry-pick abc123\n\n# Handle conflicts if they arise\ngit cherry-pick --continue\n# or\ngit cherry-pick --abort\n```\n\n### Workflow 3: Find Bug Introduction\n\n```bash\n# Start bisect\ngit bisect start\ngit bisect bad HEAD\ngit bisect good v2.1.0\n\n# Git checks out middle commit - run tests\nnpm test\n\n# If tests fail\ngit bisect bad\n\n# If tests pass\ngit bisect good\n\n# Git will automatically checkout next commit to test\n# Repeat until bug found\n\n# Automated version\ngit bisect start HEAD v2.1.0\ngit bisect run npm test\n```\n\n### Workflow 4: Multi-Branch Development\n\n```bash\n# Main project directory\ncd ~/projects/myapp\n\n# Create worktree for urgent bugfix\ngit worktree add ../myapp-hotfix hotfix/critical-bug\n\n# Work on hotfix in separate directory\ncd ../myapp-hotfix\n# Make changes, commit\ngit commit -m \"fix: resolve critical bug\"\ngit push origin hotfix/critical-bug\n\n# Return to main work without interruption\ncd ~/projects/myapp\ngit fetch origin\ngit cherry-pick hotfix/critical-bug\n\n# Clean up when done\ngit worktree remove ../myapp-hotfix\n```\n\n### Workflow 5: Recover from Mistakes\n\n```bash\n# Accidentally reset to wrong commit\ngit reset --hard HEAD~5  # Oh no!\n\n# Use reflog to find lost commits\ngit reflog\n# Output shows:\n# abc123 HEAD@{0}: reset: moving to HEAD~5\n# def456 HEAD@{1}: commit: my important changes\n\n# Recover lost commits\ngit reset --hard def456\n\n# Or create branch from lost commit\ngit branch recovery def456\n```\n\n## Advanced Techniques\n\n### Rebase vs Merge Strategy\n\n**When to Rebase:**\n- Cleaning up local commits before pushing\n- Keeping feature branch up-to-date with main\n- Creating linear history for easier review\n\n**When to Merge:**\n- Integrating completed features into main\n- Preserving exact history of collaboration\n- Public branches used by others\n\n```bash\n# Update feature branch with main changes (rebase)\ngit checkout feature/my-feature\ngit fetch origin\ngit rebase origin/main\n\n# Handle conflicts\ngit status\n# Fix conflicts in files\ngit add .\ngit rebase --continue\n\n# Or merge instead\ngit merge origin/main\n```\n\n### Autosquash Workflow\n\nAutomatically squash fixup commits during rebase.\n\n```bash\n# Make initial commit\ngit commit -m \"feat: add user authentication\"\n\n# Later, fix something in that commit\n# Stage changes\ngit commit --fixup HEAD  # or specify commit hash\n\n# Make more changes\ngit commit --fixup abc123\n\n# Rebase with autosquash\ngit rebase -i --autosquash main\n\n# Git automatically marks fixup commits\n```\n\n### Split Commit\n\nBreak one commit into multiple logical commits.\n\n```bash\n# Start interactive rebase\ngit rebase -i HEAD~3\n\n# Mark commit to split with 'edit'\n# Git will stop at that commit\n\n# Reset commit but keep changes\ngit reset HEAD^\n\n# Stage and commit in logical chunks\ngit add file1.py\ngit commit -m \"feat: add validation\"\n\ngit add file2.py\ngit commit -m \"feat: add error handling\"\n\n# Continue rebase\ngit rebase --continue\n```\n\n### Partial Cherry-Pick\n\nCherry-pick only specific files from a commit.\n\n```bash\n# Show files in commit\ngit show --name-only abc123\n\n# Checkout specific files from commit\ngit checkout abc123 -- path/to/file1.py path/to/file2.py\n\n# Stage and commit\ngit commit -m \"cherry-pick: apply specific changes from abc123\"\n```\n\n## Best Practices\n\n1. **Always Use --force-with-lease**: Safer than --force, prevents overwriting others' work\n2. **Rebase Only Local Commits**: Don't rebase commits that have been pushed and shared\n3. **Descriptive Commit Messages**: Future you will thank present you\n4. **Atomic Commits**: Each commit should be a single logical change\n5. **Test Before Force Push**: Ensure history rewrite didn't break anything\n6. **Keep Reflog Aware**: Remember reflog is your safety net for 90 days\n7. **Branch Before Risky Operations**: Create backup branch before complex rebases\n\n```bash\n# Safe force push\ngit push --force-with-lease origin feature/branch\n\n# Create backup before risky operation\ngit branch backup-branch\ngit rebase -i main\n# If something goes wrong\ngit reset --hard backup-branch\n```\n\n## Common Pitfalls\n\n- **Rebasing Public Branches**: Causes history conflicts for collaborators\n- **Force Pushing Without Lease**: Can overwrite teammate's work\n- **Losing Work in Rebase**: Resolve conflicts carefully, test after rebase\n- **Forgetting Worktree Cleanup**: Orphaned worktrees consume disk space\n- **Not Backing Up Before Experiment**: Always create safety branch\n- **Bisect on Dirty Working Directory**: Commit or stash before bisecting\n\n## Recovery Commands\n\n```bash\n# Abort operations in progress\ngit rebase --abort\ngit merge --abort\ngit cherry-pick --abort\ngit bisect reset\n\n# Restore file to version from specific commit\ngit restore --source=abc123 path/to/file\n\n# Undo last commit but keep changes\ngit reset --soft HEAD^\n\n# Undo last commit and discard changes\ngit reset --hard HEAD^\n\n# Recover deleted branch (within 90 days)\ngit reflog\ngit branch recovered-branch abc123\n```\n\n## Resources\n\n- **references/git-rebase-guide.md**: Deep dive into interactive rebase\n- **references/git-conflict-resolution.md**: Advanced conflict resolution strategies\n- **references/git-history-rewriting.md**: Safely rewriting Git history\n- **assets/git-workflow-checklist.md**: Pre-PR cleanup checklist\n- **assets/git-aliases.md**: Useful Git aliases for advanced workflows\n- **scripts/git-clean-branches.sh**: Clean up merged and stale branches\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "sql-optimization-patterns",
      "description": "Master SQL query optimization, indexing strategies, and EXPLAIN analysis to dramatically improve database performance and eliminate slow queries. Use when debugging slow queries, designing database schemas, or optimizing application performance.",
      "plugin": "developer-essentials",
      "source_path": "plugins/developer-essentials/skills/sql-optimization-patterns/SKILL.md",
      "category": "development",
      "keywords": [
        "git",
        "sql",
        "debugging",
        "testing",
        "authentication",
        "code-review",
        "monorepo",
        "essential"
      ],
      "content": "---\nname: sql-optimization-patterns\ndescription: Master SQL query optimization, indexing strategies, and EXPLAIN analysis to dramatically improve database performance and eliminate slow queries. Use when debugging slow queries, designing database schemas, or optimizing application performance.\n---\n\n# SQL Optimization Patterns\n\nTransform slow database queries into lightning-fast operations through systematic optimization, proper indexing, and query plan analysis.\n\n## When to Use This Skill\n\n- Debugging slow-running queries\n- Designing performant database schemas\n- Optimizing application response times\n- Reducing database load and costs\n- Improving scalability for growing datasets\n- Analyzing EXPLAIN query plans\n- Implementing efficient indexes\n- Resolving N+1 query problems\n\n## Core Concepts\n\n### 1. Query Execution Plans (EXPLAIN)\n\nUnderstanding EXPLAIN output is fundamental to optimization.\n\n**PostgreSQL EXPLAIN:**\n```sql\n-- Basic explain\nEXPLAIN SELECT * FROM users WHERE email = 'user@example.com';\n\n-- With actual execution stats\nEXPLAIN ANALYZE\nSELECT * FROM users WHERE email = 'user@example.com';\n\n-- Verbose output with more details\nEXPLAIN (ANALYZE, BUFFERS, VERBOSE)\nSELECT u.*, o.order_total\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE u.created_at > NOW() - INTERVAL '30 days';\n```\n\n**Key Metrics to Watch:**\n- **Seq Scan**: Full table scan (usually slow for large tables)\n- **Index Scan**: Using index (good)\n- **Index Only Scan**: Using index without touching table (best)\n- **Nested Loop**: Join method (okay for small datasets)\n- **Hash Join**: Join method (good for larger datasets)\n- **Merge Join**: Join method (good for sorted data)\n- **Cost**: Estimated query cost (lower is better)\n- **Rows**: Estimated rows returned\n- **Actual Time**: Real execution time\n\n### 2. Index Strategies\n\nIndexes are the most powerful optimization tool.\n\n**Index Types:**\n- **B-Tree**: Default, good for equality and range queries\n- **Hash**: Only for equality (=) comparisons\n- **GIN**: Full-text search, array queries, JSONB\n- **GiST**: Geometric data, full-text search\n- **BRIN**: Block Range INdex for very large tables with correlation\n\n```sql\n-- Standard B-Tree index\nCREATE INDEX idx_users_email ON users(email);\n\n-- Composite index (order matters!)\nCREATE INDEX idx_orders_user_status ON orders(user_id, status);\n\n-- Partial index (index subset of rows)\nCREATE INDEX idx_active_users ON users(email)\nWHERE status = 'active';\n\n-- Expression index\nCREATE INDEX idx_users_lower_email ON users(LOWER(email));\n\n-- Covering index (include additional columns)\nCREATE INDEX idx_users_email_covering ON users(email)\nINCLUDE (name, created_at);\n\n-- Full-text search index\nCREATE INDEX idx_posts_search ON posts\nUSING GIN(to_tsvector('english', title || ' ' || body));\n\n-- JSONB index\nCREATE INDEX idx_metadata ON events USING GIN(metadata);\n```\n\n### 3. Query Optimization Patterns\n\n**Avoid SELECT \\*:**\n```sql\n-- Bad: Fetches unnecessary columns\nSELECT * FROM users WHERE id = 123;\n\n-- Good: Fetch only what you need\nSELECT id, email, name FROM users WHERE id = 123;\n```\n\n**Use WHERE Clause Efficiently:**\n```sql\n-- Bad: Function prevents index usage\nSELECT * FROM users WHERE LOWER(email) = 'user@example.com';\n\n-- Good: Create functional index or use exact match\nCREATE INDEX idx_users_email_lower ON users(LOWER(email));\n-- Then:\nSELECT * FROM users WHERE LOWER(email) = 'user@example.com';\n\n-- Or store normalized data\nSELECT * FROM users WHERE email = 'user@example.com';\n```\n\n**Optimize JOINs:**\n```sql\n-- Bad: Cartesian product then filter\nSELECT u.name, o.total\nFROM users u, orders o\nWHERE u.id = o.user_id AND u.created_at > '2024-01-01';\n\n-- Good: Filter before join\nSELECT u.name, o.total\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE u.created_at > '2024-01-01';\n\n-- Better: Filter both tables\nSELECT u.name, o.total\nFROM (SELECT * FROM users WHERE created_at > '2024-01-01') u\nJOIN orders o ON u.id = o.user_id;\n```\n\n## Optimization Patterns\n\n### Pattern 1: Eliminate N+1 Queries\n\n**Problem: N+1 Query Anti-Pattern**\n```python\n# Bad: Executes N+1 queries\nusers = db.query(\"SELECT * FROM users LIMIT 10\")\nfor user in users:\n    orders = db.query(\"SELECT * FROM orders WHERE user_id = ?\", user.id)\n    # Process orders\n```\n\n**Solution: Use JOINs or Batch Loading**\n```sql\n-- Solution 1: JOIN\nSELECT\n    u.id, u.name,\n    o.id as order_id, o.total\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE u.id IN (1, 2, 3, 4, 5);\n\n-- Solution 2: Batch query\nSELECT * FROM orders\nWHERE user_id IN (1, 2, 3, 4, 5);\n```\n\n```python\n# Good: Single query with JOIN or batch load\n# Using JOIN\nresults = db.query(\"\"\"\n    SELECT u.id, u.name, o.id as order_id, o.total\n    FROM users u\n    LEFT JOIN orders o ON u.id = o.user_id\n    WHERE u.id IN (1, 2, 3, 4, 5)\n\"\"\")\n\n# Or batch load\nusers = db.query(\"SELECT * FROM users LIMIT 10\")\nuser_ids = [u.id for u in users]\norders = db.query(\n    \"SELECT * FROM orders WHERE user_id IN (?)\",\n    user_ids\n)\n# Group orders by user_id\norders_by_user = {}\nfor order in orders:\n    orders_by_user.setdefault(order.user_id, []).append(order)\n```\n\n### Pattern 2: Optimize Pagination\n\n**Bad: OFFSET on Large Tables**\n```sql\n-- Slow for large offsets\nSELECT * FROM users\nORDER BY created_at DESC\nLIMIT 20 OFFSET 100000;  -- Very slow!\n```\n\n**Good: Cursor-Based Pagination**\n```sql\n-- Much faster: Use cursor (last seen ID)\nSELECT * FROM users\nWHERE created_at < '2024-01-15 10:30:00'  -- Last cursor\nORDER BY created_at DESC\nLIMIT 20;\n\n-- With composite sorting\nSELECT * FROM users\nWHERE (created_at, id) < ('2024-01-15 10:30:00', 12345)\nORDER BY created_at DESC, id DESC\nLIMIT 20;\n\n-- Requires index\nCREATE INDEX idx_users_cursor ON users(created_at DESC, id DESC);\n```\n\n### Pattern 3: Aggregate Efficiently\n\n**Optimize COUNT Queries:**\n```sql\n-- Bad: Counts all rows\nSELECT COUNT(*) FROM orders;  -- Slow on large tables\n\n-- Good: Use estimates for approximate counts\nSELECT reltuples::bigint AS estimate\nFROM pg_class\nWHERE relname = 'orders';\n\n-- Good: Filter before counting\nSELECT COUNT(*) FROM orders\nWHERE created_at > NOW() - INTERVAL '7 days';\n\n-- Better: Use index-only scan\nCREATE INDEX idx_orders_created ON orders(created_at);\nSELECT COUNT(*) FROM orders\nWHERE created_at > NOW() - INTERVAL '7 days';\n```\n\n**Optimize GROUP BY:**\n```sql\n-- Bad: Group by then filter\nSELECT user_id, COUNT(*) as order_count\nFROM orders\nGROUP BY user_id\nHAVING COUNT(*) > 10;\n\n-- Better: Filter first, then group (if possible)\nSELECT user_id, COUNT(*) as order_count\nFROM orders\nWHERE status = 'completed'\nGROUP BY user_id\nHAVING COUNT(*) > 10;\n\n-- Best: Use covering index\nCREATE INDEX idx_orders_user_status ON orders(user_id, status);\n```\n\n### Pattern 4: Subquery Optimization\n\n**Transform Correlated Subqueries:**\n```sql\n-- Bad: Correlated subquery (runs for each row)\nSELECT u.name, u.email,\n    (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) as order_count\nFROM users u;\n\n-- Good: JOIN with aggregation\nSELECT u.name, u.email, COUNT(o.id) as order_count\nFROM users u\nLEFT JOIN orders o ON o.user_id = u.id\nGROUP BY u.id, u.name, u.email;\n\n-- Better: Use window functions\nSELECT DISTINCT ON (u.id)\n    u.name, u.email,\n    COUNT(o.id) OVER (PARTITION BY u.id) as order_count\nFROM users u\nLEFT JOIN orders o ON o.user_id = u.id;\n```\n\n**Use CTEs for Clarity:**\n```sql\n-- Using Common Table Expressions\nWITH recent_users AS (\n    SELECT id, name, email\n    FROM users\n    WHERE created_at > NOW() - INTERVAL '30 days'\n),\nuser_order_counts AS (\n    SELECT user_id, COUNT(*) as order_count\n    FROM orders\n    WHERE created_at > NOW() - INTERVAL '30 days'\n    GROUP BY user_id\n)\nSELECT ru.name, ru.email, COALESCE(uoc.order_count, 0) as orders\nFROM recent_users ru\nLEFT JOIN user_order_counts uoc ON ru.id = uoc.user_id;\n```\n\n### Pattern 5: Batch Operations\n\n**Batch INSERT:**\n```sql\n-- Bad: Multiple individual inserts\nINSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');\nINSERT INTO users (name, email) VALUES ('Bob', 'bob@example.com');\nINSERT INTO users (name, email) VALUES ('Carol', 'carol@example.com');\n\n-- Good: Batch insert\nINSERT INTO users (name, email) VALUES\n    ('Alice', 'alice@example.com'),\n    ('Bob', 'bob@example.com'),\n    ('Carol', 'carol@example.com');\n\n-- Better: Use COPY for bulk inserts (PostgreSQL)\nCOPY users (name, email) FROM '/tmp/users.csv' CSV HEADER;\n```\n\n**Batch UPDATE:**\n```sql\n-- Bad: Update in loop\nUPDATE users SET status = 'active' WHERE id = 1;\nUPDATE users SET status = 'active' WHERE id = 2;\n-- ... repeat for many IDs\n\n-- Good: Single UPDATE with IN clause\nUPDATE users\nSET status = 'active'\nWHERE id IN (1, 2, 3, 4, 5, ...);\n\n-- Better: Use temporary table for large batches\nCREATE TEMP TABLE temp_user_updates (id INT, new_status VARCHAR);\nINSERT INTO temp_user_updates VALUES (1, 'active'), (2, 'active'), ...;\n\nUPDATE users u\nSET status = t.new_status\nFROM temp_user_updates t\nWHERE u.id = t.id;\n```\n\n## Advanced Techniques\n\n### Materialized Views\n\nPre-compute expensive queries.\n\n```sql\n-- Create materialized view\nCREATE MATERIALIZED VIEW user_order_summary AS\nSELECT\n    u.id,\n    u.name,\n    COUNT(o.id) as total_orders,\n    SUM(o.total) as total_spent,\n    MAX(o.created_at) as last_order_date\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.name;\n\n-- Add index to materialized view\nCREATE INDEX idx_user_summary_spent ON user_order_summary(total_spent DESC);\n\n-- Refresh materialized view\nREFRESH MATERIALIZED VIEW user_order_summary;\n\n-- Concurrent refresh (PostgreSQL)\nREFRESH MATERIALIZED VIEW CONCURRENTLY user_order_summary;\n\n-- Query materialized view (very fast)\nSELECT * FROM user_order_summary\nWHERE total_spent > 1000\nORDER BY total_spent DESC;\n```\n\n### Partitioning\n\nSplit large tables for better performance.\n\n```sql\n-- Range partitioning by date (PostgreSQL)\nCREATE TABLE orders (\n    id SERIAL,\n    user_id INT,\n    total DECIMAL,\n    created_at TIMESTAMP\n) PARTITION BY RANGE (created_at);\n\n-- Create partitions\nCREATE TABLE orders_2024_q1 PARTITION OF orders\n    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');\n\nCREATE TABLE orders_2024_q2 PARTITION OF orders\n    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');\n\n-- Queries automatically use appropriate partition\nSELECT * FROM orders\nWHERE created_at BETWEEN '2024-02-01' AND '2024-02-28';\n-- Only scans orders_2024_q1 partition\n```\n\n### Query Hints and Optimization\n\n```sql\n-- Force index usage (MySQL)\nSELECT * FROM users\nUSE INDEX (idx_users_email)\nWHERE email = 'user@example.com';\n\n-- Parallel query (PostgreSQL)\nSET max_parallel_workers_per_gather = 4;\nSELECT * FROM large_table WHERE condition;\n\n-- Join hints (PostgreSQL)\nSET enable_nestloop = OFF;  -- Force hash or merge join\n```\n\n## Best Practices\n\n1. **Index Selectively**: Too many indexes slow down writes\n2. **Monitor Query Performance**: Use slow query logs\n3. **Keep Statistics Updated**: Run ANALYZE regularly\n4. **Use Appropriate Data Types**: Smaller types = better performance\n5. **Normalize Thoughtfully**: Balance normalization vs performance\n6. **Cache Frequently Accessed Data**: Use application-level caching\n7. **Connection Pooling**: Reuse database connections\n8. **Regular Maintenance**: VACUUM, ANALYZE, rebuild indexes\n\n```sql\n-- Update statistics\nANALYZE users;\nANALYZE VERBOSE orders;\n\n-- Vacuum (PostgreSQL)\nVACUUM ANALYZE users;\nVACUUM FULL users;  -- Reclaim space (locks table)\n\n-- Reindex\nREINDEX INDEX idx_users_email;\nREINDEX TABLE users;\n```\n\n## Common Pitfalls\n\n- **Over-Indexing**: Each index slows down INSERT/UPDATE/DELETE\n- **Unused Indexes**: Waste space and slow writes\n- **Missing Indexes**: Slow queries, full table scans\n- **Implicit Type Conversion**: Prevents index usage\n- **OR Conditions**: Can't use indexes efficiently\n- **LIKE with Leading Wildcard**: `LIKE '%abc'` can't use index\n- **Function in WHERE**: Prevents index usage unless functional index exists\n\n## Monitoring Queries\n\n```sql\n-- Find slow queries (PostgreSQL)\nSELECT query, calls, total_time, mean_time\nFROM pg_stat_statements\nORDER BY mean_time DESC\nLIMIT 10;\n\n-- Find missing indexes (PostgreSQL)\nSELECT\n    schemaname,\n    tablename,\n    seq_scan,\n    seq_tup_read,\n    idx_scan,\n    seq_tup_read / seq_scan AS avg_seq_tup_read\nFROM pg_stat_user_tables\nWHERE seq_scan > 0\nORDER BY seq_tup_read DESC\nLIMIT 10;\n\n-- Find unused indexes (PostgreSQL)\nSELECT\n    schemaname,\n    tablename,\n    indexname,\n    idx_scan,\n    idx_tup_read,\n    idx_tup_fetch\nFROM pg_stat_user_indexes\nWHERE idx_scan = 0\nORDER BY pg_relation_size(indexrelid) DESC;\n```\n\n## Resources\n\n- **references/postgres-optimization-guide.md**: PostgreSQL-specific optimization\n- **references/mysql-optimization-guide.md**: MySQL/MariaDB optimization\n- **references/query-plan-analysis.md**: Deep dive into EXPLAIN plans\n- **assets/index-strategy-checklist.md**: When and how to create indexes\n- **assets/query-optimization-checklist.md**: Step-by-step optimization guide\n- **scripts/analyze-slow-queries.sql**: Identify slow queries in your database\n- **scripts/index-recommendations.sql**: Generate index recommendations\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "error-handling-patterns",
      "description": "Master error handling patterns across languages including exceptions, Result types, error propagation, and graceful degradation to build resilient applications. Use when implementing error handling, designing APIs, or improving application reliability.",
      "plugin": "developer-essentials",
      "source_path": "plugins/developer-essentials/skills/error-handling-patterns/SKILL.md",
      "category": "development",
      "keywords": [
        "git",
        "sql",
        "debugging",
        "testing",
        "authentication",
        "code-review",
        "monorepo",
        "essential"
      ],
      "content": "---\nname: error-handling-patterns\ndescription: Master error handling patterns across languages including exceptions, Result types, error propagation, and graceful degradation to build resilient applications. Use when implementing error handling, designing APIs, or improving application reliability.\n---\n\n# Error Handling Patterns\n\nBuild resilient applications with robust error handling strategies that gracefully handle failures and provide excellent debugging experiences.\n\n## When to Use This Skill\n\n- Implementing error handling in new features\n- Designing error-resilient APIs\n- Debugging production issues\n- Improving application reliability\n- Creating better error messages for users and developers\n- Implementing retry and circuit breaker patterns\n- Handling async/concurrent errors\n- Building fault-tolerant distributed systems\n\n## Core Concepts\n\n### 1. Error Handling Philosophies\n\n**Exceptions vs Result Types:**\n- **Exceptions**: Traditional try-catch, disrupts control flow\n- **Result Types**: Explicit success/failure, functional approach\n- **Error Codes**: C-style, requires discipline\n- **Option/Maybe Types**: For nullable values\n\n**When to Use Each:**\n- Exceptions: Unexpected errors, exceptional conditions\n- Result Types: Expected errors, validation failures\n- Panics/Crashes: Unrecoverable errors, programming bugs\n\n### 2. Error Categories\n\n**Recoverable Errors:**\n- Network timeouts\n- Missing files\n- Invalid user input\n- API rate limits\n\n**Unrecoverable Errors:**\n- Out of memory\n- Stack overflow\n- Programming bugs (null pointer, etc.)\n\n## Language-Specific Patterns\n\n### Python Error Handling\n\n**Custom Exception Hierarchy:**\n```python\nclass ApplicationError(Exception):\n    \"\"\"Base exception for all application errors.\"\"\"\n    def __init__(self, message: str, code: str = None, details: dict = None):\n        super().__init__(message)\n        self.code = code\n        self.details = details or {}\n        self.timestamp = datetime.utcnow()\n\nclass ValidationError(ApplicationError):\n    \"\"\"Raised when validation fails.\"\"\"\n    pass\n\nclass NotFoundError(ApplicationError):\n    \"\"\"Raised when resource not found.\"\"\"\n    pass\n\nclass ExternalServiceError(ApplicationError):\n    \"\"\"Raised when external service fails.\"\"\"\n    def __init__(self, message: str, service: str, **kwargs):\n        super().__init__(message, **kwargs)\n        self.service = service\n\n# Usage\ndef get_user(user_id: str) -> User:\n    user = db.query(User).filter_by(id=user_id).first()\n    if not user:\n        raise NotFoundError(\n            f\"User not found\",\n            code=\"USER_NOT_FOUND\",\n            details={\"user_id\": user_id}\n        )\n    return user\n```\n\n**Context Managers for Cleanup:**\n```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef database_transaction(session):\n    \"\"\"Ensure transaction is committed or rolled back.\"\"\"\n    try:\n        yield session\n        session.commit()\n    except Exception as e:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n\n# Usage\nwith database_transaction(db.session) as session:\n    user = User(name=\"Alice\")\n    session.add(user)\n    # Automatic commit or rollback\n```\n\n**Retry with Exponential Backoff:**\n```python\nimport time\nfrom functools import wraps\nfrom typing import TypeVar, Callable\n\nT = TypeVar('T')\n\ndef retry(\n    max_attempts: int = 3,\n    backoff_factor: float = 2.0,\n    exceptions: tuple = (Exception,)\n):\n    \"\"\"Retry decorator with exponential backoff.\"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> T:\n            last_exception = None\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    if attempt < max_attempts - 1:\n                        sleep_time = backoff_factor ** attempt\n                        time.sleep(sleep_time)\n                        continue\n                    raise\n            raise last_exception\n        return wrapper\n    return decorator\n\n# Usage\n@retry(max_attempts=3, exceptions=(NetworkError,))\ndef fetch_data(url: str) -> dict:\n    response = requests.get(url, timeout=5)\n    response.raise_for_status()\n    return response.json()\n```\n\n### TypeScript/JavaScript Error Handling\n\n**Custom Error Classes:**\n```typescript\n// Custom error classes\nclass ApplicationError extends Error {\n    constructor(\n        message: string,\n        public code: string,\n        public statusCode: number = 500,\n        public details?: Record<string, any>\n    ) {\n        super(message);\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n\nclass ValidationError extends ApplicationError {\n    constructor(message: string, details?: Record<string, any>) {\n        super(message, 'VALIDATION_ERROR', 400, details);\n    }\n}\n\nclass NotFoundError extends ApplicationError {\n    constructor(resource: string, id: string) {\n        super(\n            `${resource} not found`,\n            'NOT_FOUND',\n            404,\n            { resource, id }\n        );\n    }\n}\n\n// Usage\nfunction getUser(id: string): User {\n    const user = users.find(u => u.id === id);\n    if (!user) {\n        throw new NotFoundError('User', id);\n    }\n    return user;\n}\n```\n\n**Result Type Pattern:**\n```typescript\n// Result type for explicit error handling\ntype Result<T, E = Error> =\n    | { ok: true; value: T }\n    | { ok: false; error: E };\n\n// Helper functions\nfunction Ok<T>(value: T): Result<T, never> {\n    return { ok: true, value };\n}\n\nfunction Err<E>(error: E): Result<never, E> {\n    return { ok: false, error };\n}\n\n// Usage\nfunction parseJSON<T>(json: string): Result<T, SyntaxError> {\n    try {\n        const value = JSON.parse(json) as T;\n        return Ok(value);\n    } catch (error) {\n        return Err(error as SyntaxError);\n    }\n}\n\n// Consuming Result\nconst result = parseJSON<User>(userJson);\nif (result.ok) {\n    console.log(result.value.name);\n} else {\n    console.error('Parse failed:', result.error.message);\n}\n\n// Chaining Results\nfunction chain<T, U, E>(\n    result: Result<T, E>,\n    fn: (value: T) => Result<U, E>\n): Result<U, E> {\n    return result.ok ? fn(result.value) : result;\n}\n```\n\n**Async Error Handling:**\n```typescript\n// Async/await with proper error handling\nasync function fetchUserOrders(userId: string): Promise<Order[]> {\n    try {\n        const user = await getUser(userId);\n        const orders = await getOrders(user.id);\n        return orders;\n    } catch (error) {\n        if (error instanceof NotFoundError) {\n            return [];  // Return empty array for not found\n        }\n        if (error instanceof NetworkError) {\n            // Retry logic\n            return retryFetchOrders(userId);\n        }\n        // Re-throw unexpected errors\n        throw error;\n    }\n}\n\n// Promise error handling\nfunction fetchData(url: string): Promise<Data> {\n    return fetch(url)\n        .then(response => {\n            if (!response.ok) {\n                throw new NetworkError(`HTTP ${response.status}`);\n            }\n            return response.json();\n        })\n        .catch(error => {\n            console.error('Fetch failed:', error);\n            throw error;\n        });\n}\n```\n\n### Rust Error Handling\n\n**Result and Option Types:**\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\n\n// Result type for operations that can fail\nfn read_file(path: &str) -> Result<String, io::Error> {\n    let mut file = File::open(path)?;  // ? operator propagates errors\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    Ok(contents)\n}\n\n// Custom error types\n#[derive(Debug)]\nenum AppError {\n    Io(io::Error),\n    Parse(std::num::ParseIntError),\n    NotFound(String),\n    Validation(String),\n}\n\nimpl From<io::Error> for AppError {\n    fn from(error: io::Error) -> Self {\n        AppError::Io(error)\n    }\n}\n\n// Using custom error type\nfn read_number_from_file(path: &str) -> Result<i32, AppError> {\n    let contents = read_file(path)?;  // Auto-converts io::Error\n    let number = contents.trim().parse()\n        .map_err(AppError::Parse)?;   // Explicitly convert ParseIntError\n    Ok(number)\n}\n\n// Option for nullable values\nfn find_user(id: &str) -> Option<User> {\n    users.iter().find(|u| u.id == id).cloned()\n}\n\n// Combining Option and Result\nfn get_user_age(id: &str) -> Result<u32, AppError> {\n    find_user(id)\n        .ok_or_else(|| AppError::NotFound(id.to_string()))\n        .map(|user| user.age)\n}\n```\n\n### Go Error Handling\n\n**Explicit Error Returns:**\n```go\n// Basic error handling\nfunc getUser(id string) (*User, error) {\n    user, err := db.QueryUser(id)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to query user: %w\", err)\n    }\n    if user == nil {\n        return nil, errors.New(\"user not found\")\n    }\n    return user, nil\n}\n\n// Custom error types\ntype ValidationError struct {\n    Field   string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"validation failed for %s: %s\", e.Field, e.Message)\n}\n\n// Sentinel errors for comparison\nvar (\n    ErrNotFound     = errors.New(\"not found\")\n    ErrUnauthorized = errors.New(\"unauthorized\")\n    ErrInvalidInput = errors.New(\"invalid input\")\n)\n\n// Error checking\nuser, err := getUser(\"123\")\nif err != nil {\n    if errors.Is(err, ErrNotFound) {\n        // Handle not found\n    } else {\n        // Handle other errors\n    }\n}\n\n// Error wrapping and unwrapping\nfunc processUser(id string) error {\n    user, err := getUser(id)\n    if err != nil {\n        return fmt.Errorf(\"process user failed: %w\", err)\n    }\n    // Process user\n    return nil\n}\n\n// Unwrap errors\nerr := processUser(\"123\")\nif err != nil {\n    var valErr *ValidationError\n    if errors.As(err, &valErr) {\n        fmt.Printf(\"Validation error: %s\\n\", valErr.Field)\n    }\n}\n```\n\n## Universal Patterns\n\n### Pattern 1: Circuit Breaker\n\nPrevent cascading failures in distributed systems.\n\n```python\nfrom enum import Enum\nfrom datetime import datetime, timedelta\nfrom typing import Callable, TypeVar\n\nT = TypeVar('T')\n\nclass CircuitState(Enum):\n    CLOSED = \"closed\"       # Normal operation\n    OPEN = \"open\"          # Failing, reject requests\n    HALF_OPEN = \"half_open\"  # Testing if recovered\n\nclass CircuitBreaker:\n    def __init__(\n        self,\n        failure_threshold: int = 5,\n        timeout: timedelta = timedelta(seconds=60),\n        success_threshold: int = 2\n    ):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.success_threshold = success_threshold\n        self.failure_count = 0\n        self.success_count = 0\n        self.state = CircuitState.CLOSED\n        self.last_failure_time = None\n\n    def call(self, func: Callable[[], T]) -> T:\n        if self.state == CircuitState.OPEN:\n            if datetime.now() - self.last_failure_time > self.timeout:\n                self.state = CircuitState.HALF_OPEN\n                self.success_count = 0\n            else:\n                raise Exception(\"Circuit breaker is OPEN\")\n\n        try:\n            result = func()\n            self.on_success()\n            return result\n        except Exception as e:\n            self.on_failure()\n            raise\n\n    def on_success(self):\n        self.failure_count = 0\n        if self.state == CircuitState.HALF_OPEN:\n            self.success_count += 1\n            if self.success_count >= self.success_threshold:\n                self.state = CircuitState.CLOSED\n                self.success_count = 0\n\n    def on_failure(self):\n        self.failure_count += 1\n        self.last_failure_time = datetime.now()\n        if self.failure_count >= self.failure_threshold:\n            self.state = CircuitState.OPEN\n\n# Usage\ncircuit_breaker = CircuitBreaker()\n\ndef fetch_data():\n    return circuit_breaker.call(lambda: external_api.get_data())\n```\n\n### Pattern 2: Error Aggregation\n\nCollect multiple errors instead of failing on first error.\n\n```typescript\nclass ErrorCollector {\n    private errors: Error[] = [];\n\n    add(error: Error): void {\n        this.errors.push(error);\n    }\n\n    hasErrors(): boolean {\n        return this.errors.length > 0;\n    }\n\n    getErrors(): Error[] {\n        return [...this.errors];\n    }\n\n    throw(): never {\n        if (this.errors.length === 1) {\n            throw this.errors[0];\n        }\n        throw new AggregateError(\n            this.errors,\n            `${this.errors.length} errors occurred`\n        );\n    }\n}\n\n// Usage: Validate multiple fields\nfunction validateUser(data: any): User {\n    const errors = new ErrorCollector();\n\n    if (!data.email) {\n        errors.add(new ValidationError('Email is required'));\n    } else if (!isValidEmail(data.email)) {\n        errors.add(new ValidationError('Email is invalid'));\n    }\n\n    if (!data.name || data.name.length < 2) {\n        errors.add(new ValidationError('Name must be at least 2 characters'));\n    }\n\n    if (!data.age || data.age < 18) {\n        errors.add(new ValidationError('Age must be 18 or older'));\n    }\n\n    if (errors.hasErrors()) {\n        errors.throw();\n    }\n\n    return data as User;\n}\n```\n\n### Pattern 3: Graceful Degradation\n\nProvide fallback functionality when errors occur.\n\n```python\nfrom typing import Optional, Callable, TypeVar\n\nT = TypeVar('T')\n\ndef with_fallback(\n    primary: Callable[[], T],\n    fallback: Callable[[], T],\n    log_error: bool = True\n) -> T:\n    \"\"\"Try primary function, fall back to fallback on error.\"\"\"\n    try:\n        return primary()\n    except Exception as e:\n        if log_error:\n            logger.error(f\"Primary function failed: {e}\")\n        return fallback()\n\n# Usage\ndef get_user_profile(user_id: str) -> UserProfile:\n    return with_fallback(\n        primary=lambda: fetch_from_cache(user_id),\n        fallback=lambda: fetch_from_database(user_id)\n    )\n\n# Multiple fallbacks\ndef get_exchange_rate(currency: str) -> float:\n    return (\n        try_function(lambda: api_provider_1.get_rate(currency))\n        or try_function(lambda: api_provider_2.get_rate(currency))\n        or try_function(lambda: cache.get_rate(currency))\n        or DEFAULT_RATE\n    )\n\ndef try_function(func: Callable[[], Optional[T]]) -> Optional[T]:\n    try:\n        return func()\n    except Exception:\n        return None\n```\n\n## Best Practices\n\n1. **Fail Fast**: Validate input early, fail quickly\n2. **Preserve Context**: Include stack traces, metadata, timestamps\n3. **Meaningful Messages**: Explain what happened and how to fix it\n4. **Log Appropriately**: Error = log, expected failure = don't spam logs\n5. **Handle at Right Level**: Catch where you can meaningfully handle\n6. **Clean Up Resources**: Use try-finally, context managers, defer\n7. **Don't Swallow Errors**: Log or re-throw, don't silently ignore\n8. **Type-Safe Errors**: Use typed errors when possible\n\n```python\n# Good error handling example\ndef process_order(order_id: str) -> Order:\n    \"\"\"Process order with comprehensive error handling.\"\"\"\n    try:\n        # Validate input\n        if not order_id:\n            raise ValidationError(\"Order ID is required\")\n\n        # Fetch order\n        order = db.get_order(order_id)\n        if not order:\n            raise NotFoundError(\"Order\", order_id)\n\n        # Process payment\n        try:\n            payment_result = payment_service.charge(order.total)\n        except PaymentServiceError as e:\n            # Log and wrap external service error\n            logger.error(f\"Payment failed for order {order_id}: {e}\")\n            raise ExternalServiceError(\n                f\"Payment processing failed\",\n                service=\"payment_service\",\n                details={\"order_id\": order_id, \"amount\": order.total}\n            ) from e\n\n        # Update order\n        order.status = \"completed\"\n        order.payment_id = payment_result.id\n        db.save(order)\n\n        return order\n\n    except ApplicationError:\n        # Re-raise known application errors\n        raise\n    except Exception as e:\n        # Log unexpected errors\n        logger.exception(f\"Unexpected error processing order {order_id}\")\n        raise ApplicationError(\n            \"Order processing failed\",\n            code=\"INTERNAL_ERROR\"\n        ) from e\n```\n\n## Common Pitfalls\n\n- **Catching Too Broadly**: `except Exception` hides bugs\n- **Empty Catch Blocks**: Silently swallowing errors\n- **Logging and Re-throwing**: Creates duplicate log entries\n- **Not Cleaning Up**: Forgetting to close files, connections\n- **Poor Error Messages**: \"Error occurred\" is not helpful\n- **Returning Error Codes**: Use exceptions or Result types\n- **Ignoring Async Errors**: Unhandled promise rejections\n\n## Resources\n\n- **references/exception-hierarchy-design.md**: Designing error class hierarchies\n- **references/error-recovery-strategies.md**: Recovery patterns for different scenarios\n- **references/async-error-handling.md**: Handling errors in concurrent code\n- **assets/error-handling-checklist.md**: Review checklist for error handling\n- **assets/error-message-guide.md**: Writing helpful error messages\n- **scripts/error-analyzer.py**: Analyze error patterns in logs\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "code-review-excellence",
      "description": "Master effective code review practices to provide constructive feedback, catch bugs early, and foster knowledge sharing while maintaining team morale. Use when reviewing pull requests, establishing review standards, or mentoring developers.",
      "plugin": "developer-essentials",
      "source_path": "plugins/developer-essentials/skills/code-review-excellence/SKILL.md",
      "category": "development",
      "keywords": [
        "git",
        "sql",
        "debugging",
        "testing",
        "authentication",
        "code-review",
        "monorepo",
        "essential"
      ],
      "content": "---\nname: code-review-excellence\ndescription: Master effective code review practices to provide constructive feedback, catch bugs early, and foster knowledge sharing while maintaining team morale. Use when reviewing pull requests, establishing review standards, or mentoring developers.\n---\n\n# Code Review Excellence\n\nTransform code reviews from gatekeeping to knowledge sharing through constructive feedback, systematic analysis, and collaborative improvement.\n\n## When to Use This Skill\n\n- Reviewing pull requests and code changes\n- Establishing code review standards for teams\n- Mentoring junior developers through reviews\n- Conducting architecture reviews\n- Creating review checklists and guidelines\n- Improving team collaboration\n- Reducing code review cycle time\n- Maintaining code quality standards\n\n## Core Principles\n\n### 1. The Review Mindset\n\n**Goals of Code Review:**\n- Catch bugs and edge cases\n- Ensure code maintainability\n- Share knowledge across team\n- Enforce coding standards\n- Improve design and architecture\n- Build team culture\n\n**Not the Goals:**\n- Show off knowledge\n- Nitpick formatting (use linters)\n- Block progress unnecessarily\n- Rewrite to your preference\n\n### 2. Effective Feedback\n\n**Good Feedback is:**\n- Specific and actionable\n- Educational, not judgmental\n- Focused on the code, not the person\n- Balanced (praise good work too)\n- Prioritized (critical vs nice-to-have)\n\n```markdown\n\u274c Bad: \"This is wrong.\"\n\u2705 Good: \"This could cause a race condition when multiple users\n         access simultaneously. Consider using a mutex here.\"\n\n\u274c Bad: \"Why didn't you use X pattern?\"\n\u2705 Good: \"Have you considered the Repository pattern? It would\n         make this easier to test. Here's an example: [link]\"\n\n\u274c Bad: \"Rename this variable.\"\n\u2705 Good: \"[nit] Consider `userCount` instead of `uc` for\n         clarity. Not blocking if you prefer to keep it.\"\n```\n\n### 3. Review Scope\n\n**What to Review:**\n- Logic correctness and edge cases\n- Security vulnerabilities\n- Performance implications\n- Test coverage and quality\n- Error handling\n- Documentation and comments\n- API design and naming\n- Architectural fit\n\n**What Not to Review Manually:**\n- Code formatting (use Prettier, Black, etc.)\n- Import organization\n- Linting violations\n- Simple typos\n\n## Review Process\n\n### Phase 1: Context Gathering (2-3 minutes)\n\n```markdown\nBefore diving into code, understand:\n\n1. Read PR description and linked issue\n2. Check PR size (>400 lines? Ask to split)\n3. Review CI/CD status (tests passing?)\n4. Understand the business requirement\n5. Note any relevant architectural decisions\n```\n\n### Phase 2: High-Level Review (5-10 minutes)\n\n```markdown\n1. **Architecture & Design**\n   - Does the solution fit the problem?\n   - Are there simpler approaches?\n   - Is it consistent with existing patterns?\n   - Will it scale?\n\n2. **File Organization**\n   - Are new files in the right places?\n   - Is code grouped logically?\n   - Are there duplicate files?\n\n3. **Testing Strategy**\n   - Are there tests?\n   - Do tests cover edge cases?\n   - Are tests readable?\n```\n\n### Phase 3: Line-by-Line Review (10-20 minutes)\n\n```markdown\nFor each file:\n\n1. **Logic & Correctness**\n   - Edge cases handled?\n   - Off-by-one errors?\n   - Null/undefined checks?\n   - Race conditions?\n\n2. **Security**\n   - Input validation?\n   - SQL injection risks?\n   - XSS vulnerabilities?\n   - Sensitive data exposure?\n\n3. **Performance**\n   - N+1 queries?\n   - Unnecessary loops?\n   - Memory leaks?\n   - Blocking operations?\n\n4. **Maintainability**\n   - Clear variable names?\n   - Functions doing one thing?\n   - Complex code commented?\n   - Magic numbers extracted?\n```\n\n### Phase 4: Summary & Decision (2-3 minutes)\n\n```markdown\n1. Summarize key concerns\n2. Highlight what you liked\n3. Make clear decision:\n   - \u2705 Approve\n   - \ud83d\udcac Comment (minor suggestions)\n   - \ud83d\udd04 Request Changes (must address)\n4. Offer to pair if complex\n```\n\n## Review Techniques\n\n### Technique 1: The Checklist Method\n\n```markdown\n## Security Checklist\n- [ ] User input validated and sanitized\n- [ ] SQL queries use parameterization\n- [ ] Authentication/authorization checked\n- [ ] Secrets not hardcoded\n- [ ] Error messages don't leak info\n\n## Performance Checklist\n- [ ] No N+1 queries\n- [ ] Database queries indexed\n- [ ] Large lists paginated\n- [ ] Expensive operations cached\n- [ ] No blocking I/O in hot paths\n\n## Testing Checklist\n- [ ] Happy path tested\n- [ ] Edge cases covered\n- [ ] Error cases tested\n- [ ] Test names are descriptive\n- [ ] Tests are deterministic\n```\n\n### Technique 2: The Question Approach\n\nInstead of stating problems, ask questions to encourage thinking:\n\n```markdown\n\u274c \"This will fail if the list is empty.\"\n\u2705 \"What happens if `items` is an empty array?\"\n\n\u274c \"You need error handling here.\"\n\u2705 \"How should this behave if the API call fails?\"\n\n\u274c \"This is inefficient.\"\n\u2705 \"I see this loops through all users. Have we considered\n    the performance impact with 100k users?\"\n```\n\n### Technique 3: Suggest, Don't Command\n\n```markdown\n## Use Collaborative Language\n\n\u274c \"You must change this to use async/await\"\n\u2705 \"Suggestion: async/await might make this more readable:\n    ```typescript\n    async function fetchUser(id: string) {\n        const user = await db.query('SELECT * FROM users WHERE id = ?', id);\n        return user;\n    }\n    ```\n    What do you think?\"\n\n\u274c \"Extract this into a function\"\n\u2705 \"This logic appears in 3 places. Would it make sense to\n    extract it into a shared utility function?\"\n```\n\n### Technique 4: Differentiate Severity\n\n```markdown\nUse labels to indicate priority:\n\n\ud83d\udd34 [blocking] - Must fix before merge\n\ud83d\udfe1 [important] - Should fix, discuss if disagree\n\ud83d\udfe2 [nit] - Nice to have, not blocking\n\ud83d\udca1 [suggestion] - Alternative approach to consider\n\ud83d\udcda [learning] - Educational comment, no action needed\n\ud83c\udf89 [praise] - Good work, keep it up!\n\nExample:\n\"\ud83d\udd34 [blocking] This SQL query is vulnerable to injection.\n Please use parameterized queries.\"\n\n\"\ud83d\udfe2 [nit] Consider renaming `data` to `userData` for clarity.\"\n\n\"\ud83c\udf89 [praise] Excellent test coverage! This will catch edge cases.\"\n```\n\n## Language-Specific Patterns\n\n### Python Code Review\n\n```python\n# Check for Python-specific issues\n\n# \u274c Mutable default arguments\ndef add_item(item, items=[]):  # Bug! Shared across calls\n    items.append(item)\n    return items\n\n# \u2705 Use None as default\ndef add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\n# \u274c Catching too broad\ntry:\n    result = risky_operation()\nexcept:  # Catches everything, even KeyboardInterrupt!\n    pass\n\n# \u2705 Catch specific exceptions\ntry:\n    result = risky_operation()\nexcept ValueError as e:\n    logger.error(f\"Invalid value: {e}\")\n    raise\n\n# \u274c Using mutable class attributes\nclass User:\n    permissions = []  # Shared across all instances!\n\n# \u2705 Initialize in __init__\nclass User:\n    def __init__(self):\n        self.permissions = []\n```\n\n### TypeScript/JavaScript Code Review\n\n```typescript\n// Check for TypeScript-specific issues\n\n// \u274c Using any defeats type safety\nfunction processData(data: any) {  // Avoid any\n    return data.value;\n}\n\n// \u2705 Use proper types\ninterface DataPayload {\n    value: string;\n}\nfunction processData(data: DataPayload) {\n    return data.value;\n}\n\n// \u274c Not handling async errors\nasync function fetchUser(id: string) {\n    const response = await fetch(`/api/users/${id}`);\n    return response.json();  // What if network fails?\n}\n\n// \u2705 Handle errors properly\nasync function fetchUser(id: string): Promise<User> {\n    try {\n        const response = await fetch(`/api/users/${id}`);\n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}`);\n        }\n        return await response.json();\n    } catch (error) {\n        console.error('Failed to fetch user:', error);\n        throw error;\n    }\n}\n\n// \u274c Mutation of props\nfunction UserProfile({ user }: Props) {\n    user.lastViewed = new Date();  // Mutating prop!\n    return <div>{user.name}</div>;\n}\n\n// \u2705 Don't mutate props\nfunction UserProfile({ user, onView }: Props) {\n    useEffect(() => {\n        onView(user.id);  // Notify parent to update\n    }, [user.id]);\n    return <div>{user.name}</div>;\n}\n```\n\n## Advanced Review Patterns\n\n### Pattern 1: Architectural Review\n\n```markdown\nWhen reviewing significant changes:\n\n1. **Design Document First**\n   - For large features, request design doc before code\n   - Review design with team before implementation\n   - Agree on approach to avoid rework\n\n2. **Review in Stages**\n   - First PR: Core abstractions and interfaces\n   - Second PR: Implementation\n   - Third PR: Integration and tests\n   - Easier to review, faster to iterate\n\n3. **Consider Alternatives**\n   - \"Have we considered using [pattern/library]?\"\n   - \"What's the tradeoff vs. the simpler approach?\"\n   - \"How will this evolve as requirements change?\"\n```\n\n### Pattern 2: Test Quality Review\n\n```typescript\n// \u274c Poor test: Implementation detail testing\ntest('increments counter variable', () => {\n    const component = render(<Counter />);\n    const button = component.getByRole('button');\n    fireEvent.click(button);\n    expect(component.state.counter).toBe(1);  // Testing internal state\n});\n\n// \u2705 Good test: Behavior testing\ntest('displays incremented count when clicked', () => {\n    render(<Counter />);\n    const button = screen.getByRole('button', { name: /increment/i });\n    fireEvent.click(button);\n    expect(screen.getByText('Count: 1')).toBeInTheDocument();\n});\n\n// Review questions for tests:\n// - Do tests describe behavior, not implementation?\n// - Are test names clear and descriptive?\n// - Do tests cover edge cases?\n// - Are tests independent (no shared state)?\n// - Can tests run in any order?\n```\n\n### Pattern 3: Security Review\n\n```markdown\n## Security Review Checklist\n\n### Authentication & Authorization\n- [ ] Is authentication required where needed?\n- [ ] Are authorization checks before every action?\n- [ ] Is JWT validation proper (signature, expiry)?\n- [ ] Are API keys/secrets properly secured?\n\n### Input Validation\n- [ ] All user inputs validated?\n- [ ] File uploads restricted (size, type)?\n- [ ] SQL queries parameterized?\n- [ ] XSS protection (escape output)?\n\n### Data Protection\n- [ ] Passwords hashed (bcrypt/argon2)?\n- [ ] Sensitive data encrypted at rest?\n- [ ] HTTPS enforced for sensitive data?\n- [ ] PII handled according to regulations?\n\n### Common Vulnerabilities\n- [ ] No eval() or similar dynamic execution?\n- [ ] No hardcoded secrets?\n- [ ] CSRF protection for state-changing operations?\n- [ ] Rate limiting on public endpoints?\n```\n\n## Giving Difficult Feedback\n\n### Pattern: The Sandwich Method (Modified)\n\n```markdown\nTraditional: Praise + Criticism + Praise (feels fake)\n\nBetter: Context + Specific Issue + Helpful Solution\n\nExample:\n\"I noticed the payment processing logic is inline in the\ncontroller. This makes it harder to test and reuse.\n\n[Specific Issue]\nThe calculateTotal() function mixes tax calculation,\ndiscount logic, and database queries, making it difficult\nto unit test and reason about.\n\n[Helpful Solution]\nCould we extract this into a PaymentService class? That\nwould make it testable and reusable. I can pair with you\non this if helpful.\"\n```\n\n### Handling Disagreements\n\n```markdown\nWhen author disagrees with your feedback:\n\n1. **Seek to Understand**\n   \"Help me understand your approach. What led you to\n    choose this pattern?\"\n\n2. **Acknowledge Valid Points**\n   \"That's a good point about X. I hadn't considered that.\"\n\n3. **Provide Data**\n   \"I'm concerned about performance. Can we add a benchmark\n    to validate the approach?\"\n\n4. **Escalate if Needed**\n   \"Let's get [architect/senior dev] to weigh in on this.\"\n\n5. **Know When to Let Go**\n   If it's working and not a critical issue, approve it.\n   Perfection is the enemy of progress.\n```\n\n## Best Practices\n\n1. **Review Promptly**: Within 24 hours, ideally same day\n2. **Limit PR Size**: 200-400 lines max for effective review\n3. **Review in Time Blocks**: 60 minutes max, take breaks\n4. **Use Review Tools**: GitHub, GitLab, or dedicated tools\n5. **Automate What You Can**: Linters, formatters, security scans\n6. **Build Rapport**: Emoji, praise, and empathy matter\n7. **Be Available**: Offer to pair on complex issues\n8. **Learn from Others**: Review others' review comments\n\n## Common Pitfalls\n\n- **Perfectionism**: Blocking PRs for minor style preferences\n- **Scope Creep**: \"While you're at it, can you also...\"\n- **Inconsistency**: Different standards for different people\n- **Delayed Reviews**: Letting PRs sit for days\n- **Ghosting**: Requesting changes then disappearing\n- **Rubber Stamping**: Approving without actually reviewing\n- **Bike Shedding**: Debating trivial details extensively\n\n## Templates\n\n### PR Review Comment Template\n\n```markdown\n## Summary\n[Brief overview of what was reviewed]\n\n## Strengths\n- [What was done well]\n- [Good patterns or approaches]\n\n## Required Changes\n\ud83d\udd34 [Blocking issue 1]\n\ud83d\udd34 [Blocking issue 2]\n\n## Suggestions\n\ud83d\udca1 [Improvement 1]\n\ud83d\udca1 [Improvement 2]\n\n## Questions\n\u2753 [Clarification needed on X]\n\u2753 [Alternative approach consideration]\n\n## Verdict\n\u2705 Approve after addressing required changes\n```\n\n## Resources\n\n- **references/code-review-best-practices.md**: Comprehensive review guidelines\n- **references/common-bugs-checklist.md**: Language-specific bugs to watch for\n- **references/security-review-guide.md**: Security-focused review checklist\n- **assets/pr-review-template.md**: Standard review comment template\n- **assets/review-checklist.md**: Quick reference checklist\n- **scripts/pr-analyzer.py**: Analyze PR complexity and suggest reviewers\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "e2e-testing-patterns",
      "description": "Master end-to-end testing with Playwright and Cypress to build reliable test suites that catch bugs, improve confidence, and enable fast deployment. Use when implementing E2E tests, debugging flaky tests, or establishing testing standards.",
      "plugin": "developer-essentials",
      "source_path": "plugins/developer-essentials/skills/e2e-testing-patterns/SKILL.md",
      "category": "development",
      "keywords": [
        "git",
        "sql",
        "debugging",
        "testing",
        "authentication",
        "code-review",
        "monorepo",
        "essential"
      ],
      "content": "---\nname: e2e-testing-patterns\ndescription: Master end-to-end testing with Playwright and Cypress to build reliable test suites that catch bugs, improve confidence, and enable fast deployment. Use when implementing E2E tests, debugging flaky tests, or establishing testing standards.\n---\n\n# E2E Testing Patterns\n\nBuild reliable, fast, and maintainable end-to-end test suites that provide confidence to ship code quickly and catch regressions before users do.\n\n## When to Use This Skill\n\n- Implementing end-to-end test automation\n- Debugging flaky or unreliable tests\n- Testing critical user workflows\n- Setting up CI/CD test pipelines\n- Testing across multiple browsers\n- Validating accessibility requirements\n- Testing responsive designs\n- Establishing E2E testing standards\n\n## Core Concepts\n\n### 1. E2E Testing Fundamentals\n\n**What to Test with E2E:**\n- Critical user journeys (login, checkout, signup)\n- Complex interactions (drag-and-drop, multi-step forms)\n- Cross-browser compatibility\n- Real API integration\n- Authentication flows\n\n**What NOT to Test with E2E:**\n- Unit-level logic (use unit tests)\n- API contracts (use integration tests)\n- Edge cases (too slow)\n- Internal implementation details\n\n### 2. Test Philosophy\n\n**The Testing Pyramid:**\n```\n        /\\\n       /E2E\\         \u2190 Few, focused on critical paths\n      /\u2500\u2500\u2500\u2500\u2500\\\n     /Integr\\        \u2190 More, test component interactions\n    /\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\\n   /Unit Tests\\      \u2190 Many, fast, isolated\n  /\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\\n```\n\n**Best Practices:**\n- Test user behavior, not implementation\n- Keep tests independent\n- Make tests deterministic\n- Optimize for speed\n- Use data-testid, not CSS selectors\n\n## Playwright Patterns\n\n### Setup and Configuration\n\n```typescript\n// playwright.config.ts\nimport { defineConfig, devices } from '@playwright/test';\n\nexport default defineConfig({\n    testDir: './e2e',\n    timeout: 30000,\n    expect: {\n        timeout: 5000,\n    },\n    fullyParallel: true,\n    forbidOnly: !!process.env.CI,\n    retries: process.env.CI ? 2 : 0,\n    workers: process.env.CI ? 1 : undefined,\n    reporter: [\n        ['html'],\n        ['junit', { outputFile: 'results.xml' }],\n    ],\n    use: {\n        baseURL: 'http://localhost:3000',\n        trace: 'on-first-retry',\n        screenshot: 'only-on-failure',\n        video: 'retain-on-failure',\n    },\n    projects: [\n        { name: 'chromium', use: { ...devices['Desktop Chrome'] } },\n        { name: 'firefox', use: { ...devices['Desktop Firefox'] } },\n        { name: 'webkit', use: { ...devices['Desktop Safari'] } },\n        { name: 'mobile', use: { ...devices['iPhone 13'] } },\n    ],\n});\n```\n\n### Pattern 1: Page Object Model\n\n```typescript\n// pages/LoginPage.ts\nimport { Page, Locator } from '@playwright/test';\n\nexport class LoginPage {\n    readonly page: Page;\n    readonly emailInput: Locator;\n    readonly passwordInput: Locator;\n    readonly loginButton: Locator;\n    readonly errorMessage: Locator;\n\n    constructor(page: Page) {\n        this.page = page;\n        this.emailInput = page.getByLabel('Email');\n        this.passwordInput = page.getByLabel('Password');\n        this.loginButton = page.getByRole('button', { name: 'Login' });\n        this.errorMessage = page.getByRole('alert');\n    }\n\n    async goto() {\n        await this.page.goto('/login');\n    }\n\n    async login(email: string, password: string) {\n        await this.emailInput.fill(email);\n        await this.passwordInput.fill(password);\n        await this.loginButton.click();\n    }\n\n    async getErrorMessage(): Promise<string> {\n        return await this.errorMessage.textContent() ?? '';\n    }\n}\n\n// Test using Page Object\nimport { test, expect } from '@playwright/test';\nimport { LoginPage } from './pages/LoginPage';\n\ntest('successful login', async ({ page }) => {\n    const loginPage = new LoginPage(page);\n    await loginPage.goto();\n    await loginPage.login('user@example.com', 'password123');\n\n    await expect(page).toHaveURL('/dashboard');\n    await expect(page.getByRole('heading', { name: 'Dashboard' }))\n        .toBeVisible();\n});\n\ntest('failed login shows error', async ({ page }) => {\n    const loginPage = new LoginPage(page);\n    await loginPage.goto();\n    await loginPage.login('invalid@example.com', 'wrong');\n\n    const error = await loginPage.getErrorMessage();\n    expect(error).toContain('Invalid credentials');\n});\n```\n\n### Pattern 2: Fixtures for Test Data\n\n```typescript\n// fixtures/test-data.ts\nimport { test as base } from '@playwright/test';\n\ntype TestData = {\n    testUser: {\n        email: string;\n        password: string;\n        name: string;\n    };\n    adminUser: {\n        email: string;\n        password: string;\n    };\n};\n\nexport const test = base.extend<TestData>({\n    testUser: async ({}, use) => {\n        const user = {\n            email: `test-${Date.now()}@example.com`,\n            password: 'Test123!@#',\n            name: 'Test User',\n        };\n        // Setup: Create user in database\n        await createTestUser(user);\n        await use(user);\n        // Teardown: Clean up user\n        await deleteTestUser(user.email);\n    },\n\n    adminUser: async ({}, use) => {\n        await use({\n            email: 'admin@example.com',\n            password: process.env.ADMIN_PASSWORD!,\n        });\n    },\n});\n\n// Usage in tests\nimport { test } from './fixtures/test-data';\n\ntest('user can update profile', async ({ page, testUser }) => {\n    await page.goto('/login');\n    await page.getByLabel('Email').fill(testUser.email);\n    await page.getByLabel('Password').fill(testUser.password);\n    await page.getByRole('button', { name: 'Login' }).click();\n\n    await page.goto('/profile');\n    await page.getByLabel('Name').fill('Updated Name');\n    await page.getByRole('button', { name: 'Save' }).click();\n\n    await expect(page.getByText('Profile updated')).toBeVisible();\n});\n```\n\n### Pattern 3: Waiting Strategies\n\n```typescript\n// \u274c Bad: Fixed timeouts\nawait page.waitForTimeout(3000);  // Flaky!\n\n// \u2705 Good: Wait for specific conditions\nawait page.waitForLoadState('networkidle');\nawait page.waitForURL('/dashboard');\nawait page.waitForSelector('[data-testid=\"user-profile\"]');\n\n// \u2705 Better: Auto-waiting with assertions\nawait expect(page.getByText('Welcome')).toBeVisible();\nawait expect(page.getByRole('button', { name: 'Submit' }))\n    .toBeEnabled();\n\n// Wait for API response\nconst responsePromise = page.waitForResponse(\n    response => response.url().includes('/api/users') && response.status() === 200\n);\nawait page.getByRole('button', { name: 'Load Users' }).click();\nconst response = await responsePromise;\nconst data = await response.json();\nexpect(data.users).toHaveLength(10);\n\n// Wait for multiple conditions\nawait Promise.all([\n    page.waitForURL('/success'),\n    page.waitForLoadState('networkidle'),\n    expect(page.getByText('Payment successful')).toBeVisible(),\n]);\n```\n\n### Pattern 4: Network Mocking and Interception\n\n```typescript\n// Mock API responses\ntest('displays error when API fails', async ({ page }) => {\n    await page.route('**/api/users', route => {\n        route.fulfill({\n            status: 500,\n            contentType: 'application/json',\n            body: JSON.stringify({ error: 'Internal Server Error' }),\n        });\n    });\n\n    await page.goto('/users');\n    await expect(page.getByText('Failed to load users')).toBeVisible();\n});\n\n// Intercept and modify requests\ntest('can modify API request', async ({ page }) => {\n    await page.route('**/api/users', async route => {\n        const request = route.request();\n        const postData = JSON.parse(request.postData() || '{}');\n\n        // Modify request\n        postData.role = 'admin';\n\n        await route.continue({\n            postData: JSON.stringify(postData),\n        });\n    });\n\n    // Test continues...\n});\n\n// Mock third-party services\ntest('payment flow with mocked Stripe', async ({ page }) => {\n    await page.route('**/api/stripe/**', route => {\n        route.fulfill({\n            status: 200,\n            body: JSON.stringify({\n                id: 'mock_payment_id',\n                status: 'succeeded',\n            }),\n        });\n    });\n\n    // Test payment flow with mocked response\n});\n```\n\n## Cypress Patterns\n\n### Setup and Configuration\n\n```typescript\n// cypress.config.ts\nimport { defineConfig } from 'cypress';\n\nexport default defineConfig({\n    e2e: {\n        baseUrl: 'http://localhost:3000',\n        viewportWidth: 1280,\n        viewportHeight: 720,\n        video: false,\n        screenshotOnRunFailure: true,\n        defaultCommandTimeout: 10000,\n        requestTimeout: 10000,\n        setupNodeEvents(on, config) {\n            // Implement node event listeners\n        },\n    },\n});\n```\n\n### Pattern 1: Custom Commands\n\n```typescript\n// cypress/support/commands.ts\ndeclare global {\n    namespace Cypress {\n        interface Chainable {\n            login(email: string, password: string): Chainable<void>;\n            createUser(userData: UserData): Chainable<User>;\n            dataCy(value: string): Chainable<JQuery<HTMLElement>>;\n        }\n    }\n}\n\nCypress.Commands.add('login', (email: string, password: string) => {\n    cy.visit('/login');\n    cy.get('[data-testid=\"email\"]').type(email);\n    cy.get('[data-testid=\"password\"]').type(password);\n    cy.get('[data-testid=\"login-button\"]').click();\n    cy.url().should('include', '/dashboard');\n});\n\nCypress.Commands.add('createUser', (userData: UserData) => {\n    return cy.request('POST', '/api/users', userData)\n        .its('body');\n});\n\nCypress.Commands.add('dataCy', (value: string) => {\n    return cy.get(`[data-cy=\"${value}\"]`);\n});\n\n// Usage\ncy.login('user@example.com', 'password');\ncy.dataCy('submit-button').click();\n```\n\n### Pattern 2: Cypress Intercept\n\n```typescript\n// Mock API calls\ncy.intercept('GET', '/api/users', {\n    statusCode: 200,\n    body: [\n        { id: 1, name: 'John' },\n        { id: 2, name: 'Jane' },\n    ],\n}).as('getUsers');\n\ncy.visit('/users');\ncy.wait('@getUsers');\ncy.get('[data-testid=\"user-list\"]').children().should('have.length', 2);\n\n// Modify responses\ncy.intercept('GET', '/api/users', (req) => {\n    req.reply((res) => {\n        // Modify response\n        res.body.users = res.body.users.slice(0, 5);\n        res.send();\n    });\n});\n\n// Simulate slow network\ncy.intercept('GET', '/api/data', (req) => {\n    req.reply((res) => {\n        res.delay(3000);  // 3 second delay\n        res.send();\n    });\n});\n```\n\n## Advanced Patterns\n\n### Pattern 1: Visual Regression Testing\n\n```typescript\n// With Playwright\nimport { test, expect } from '@playwright/test';\n\ntest('homepage looks correct', async ({ page }) => {\n    await page.goto('/');\n    await expect(page).toHaveScreenshot('homepage.png', {\n        fullPage: true,\n        maxDiffPixels: 100,\n    });\n});\n\ntest('button in all states', async ({ page }) => {\n    await page.goto('/components');\n\n    const button = page.getByRole('button', { name: 'Submit' });\n\n    // Default state\n    await expect(button).toHaveScreenshot('button-default.png');\n\n    // Hover state\n    await button.hover();\n    await expect(button).toHaveScreenshot('button-hover.png');\n\n    // Disabled state\n    await button.evaluate(el => el.setAttribute('disabled', 'true'));\n    await expect(button).toHaveScreenshot('button-disabled.png');\n});\n```\n\n### Pattern 2: Parallel Testing with Sharding\n\n```typescript\n// playwright.config.ts\nexport default defineConfig({\n    projects: [\n        {\n            name: 'shard-1',\n            use: { ...devices['Desktop Chrome'] },\n            grepInvert: /@slow/,\n            shard: { current: 1, total: 4 },\n        },\n        {\n            name: 'shard-2',\n            use: { ...devices['Desktop Chrome'] },\n            shard: { current: 2, total: 4 },\n        },\n        // ... more shards\n    ],\n});\n\n// Run in CI\n// npx playwright test --shard=1/4\n// npx playwright test --shard=2/4\n```\n\n### Pattern 3: Accessibility Testing\n\n```typescript\n// Install: npm install @axe-core/playwright\nimport { test, expect } from '@playwright/test';\nimport AxeBuilder from '@axe-core/playwright';\n\ntest('page should not have accessibility violations', async ({ page }) => {\n    await page.goto('/');\n\n    const accessibilityScanResults = await new AxeBuilder({ page })\n        .exclude('#third-party-widget')\n        .analyze();\n\n    expect(accessibilityScanResults.violations).toEqual([]);\n});\n\ntest('form is accessible', async ({ page }) => {\n    await page.goto('/signup');\n\n    const results = await new AxeBuilder({ page })\n        .include('form')\n        .analyze();\n\n    expect(results.violations).toEqual([]);\n});\n```\n\n## Best Practices\n\n1. **Use Data Attributes**: `data-testid` or `data-cy` for stable selectors\n2. **Avoid Brittle Selectors**: Don't rely on CSS classes or DOM structure\n3. **Test User Behavior**: Click, type, see - not implementation details\n4. **Keep Tests Independent**: Each test should run in isolation\n5. **Clean Up Test Data**: Create and destroy test data in each test\n6. **Use Page Objects**: Encapsulate page logic\n7. **Meaningful Assertions**: Check actual user-visible behavior\n8. **Optimize for Speed**: Mock when possible, parallel execution\n\n```typescript\n// \u274c Bad selectors\ncy.get('.btn.btn-primary.submit-button').click();\ncy.get('div > form > div:nth-child(2) > input').type('text');\n\n// \u2705 Good selectors\ncy.getByRole('button', { name: 'Submit' }).click();\ncy.getByLabel('Email address').type('user@example.com');\ncy.get('[data-testid=\"email-input\"]').type('user@example.com');\n```\n\n## Common Pitfalls\n\n- **Flaky Tests**: Use proper waits, not fixed timeouts\n- **Slow Tests**: Mock external APIs, use parallel execution\n- **Over-Testing**: Don't test every edge case with E2E\n- **Coupled Tests**: Tests should not depend on each other\n- **Poor Selectors**: Avoid CSS classes and nth-child\n- **No Cleanup**: Clean up test data after each test\n- **Testing Implementation**: Test user behavior, not internals\n\n## Debugging Failing Tests\n\n```typescript\n// Playwright debugging\n// 1. Run in headed mode\nnpx playwright test --headed\n\n// 2. Run in debug mode\nnpx playwright test --debug\n\n// 3. Use trace viewer\nawait page.screenshot({ path: 'screenshot.png' });\nawait page.video()?.saveAs('video.webm');\n\n// 4. Add test.step for better reporting\ntest('checkout flow', async ({ page }) => {\n    await test.step('Add item to cart', async () => {\n        await page.goto('/products');\n        await page.getByRole('button', { name: 'Add to Cart' }).click();\n    });\n\n    await test.step('Proceed to checkout', async () => {\n        await page.goto('/cart');\n        await page.getByRole('button', { name: 'Checkout' }).click();\n    });\n});\n\n// 5. Inspect page state\nawait page.pause();  // Pauses execution, opens inspector\n```\n\n## Resources\n\n- **references/playwright-best-practices.md**: Playwright-specific patterns\n- **references/cypress-best-practices.md**: Cypress-specific patterns\n- **references/flaky-test-debugging.md**: Debugging unreliable tests\n- **assets/e2e-testing-checklist.md**: What to test with E2E\n- **assets/selector-strategies.md**: Finding reliable selectors\n- **scripts/test-analyzer.ts**: Analyze test flakiness and duration\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "auth-implementation-patterns",
      "description": "Master authentication and authorization patterns including JWT, OAuth2, session management, and RBAC to build secure, scalable access control systems. Use when implementing auth systems, securing APIs, or debugging security issues.",
      "plugin": "developer-essentials",
      "source_path": "plugins/developer-essentials/skills/auth-implementation-patterns/SKILL.md",
      "category": "development",
      "keywords": [
        "git",
        "sql",
        "debugging",
        "testing",
        "authentication",
        "code-review",
        "monorepo",
        "essential"
      ],
      "content": "---\nname: auth-implementation-patterns\ndescription: Master authentication and authorization patterns including JWT, OAuth2, session management, and RBAC to build secure, scalable access control systems. Use when implementing auth systems, securing APIs, or debugging security issues.\n---\n\n# Authentication & Authorization Implementation Patterns\n\nBuild secure, scalable authentication and authorization systems using industry-standard patterns and modern best practices.\n\n## When to Use This Skill\n\n- Implementing user authentication systems\n- Securing REST or GraphQL APIs\n- Adding OAuth2/social login\n- Implementing role-based access control (RBAC)\n- Designing session management\n- Migrating authentication systems\n- Debugging auth issues\n- Implementing SSO or multi-tenancy\n\n## Core Concepts\n\n### 1. Authentication vs Authorization\n\n**Authentication (AuthN)**: Who are you?\n- Verifying identity (username/password, OAuth, biometrics)\n- Issuing credentials (sessions, tokens)\n- Managing login/logout\n\n**Authorization (AuthZ)**: What can you do?\n- Permission checking\n- Role-based access control (RBAC)\n- Resource ownership validation\n- Policy enforcement\n\n### 2. Authentication Strategies\n\n**Session-Based:**\n- Server stores session state\n- Session ID in cookie\n- Traditional, simple, stateful\n\n**Token-Based (JWT):**\n- Stateless, self-contained\n- Scales horizontally\n- Can store claims\n\n**OAuth2/OpenID Connect:**\n- Delegate authentication\n- Social login (Google, GitHub)\n- Enterprise SSO\n\n## JWT Authentication\n\n### Pattern 1: JWT Implementation\n\n```typescript\n// JWT structure: header.payload.signature\nimport jwt from 'jsonwebtoken';\nimport { Request, Response, NextFunction } from 'express';\n\ninterface JWTPayload {\n    userId: string;\n    email: string;\n    role: string;\n    iat: number;\n    exp: number;\n}\n\n// Generate JWT\nfunction generateTokens(userId: string, email: string, role: string) {\n    const accessToken = jwt.sign(\n        { userId, email, role },\n        process.env.JWT_SECRET!,\n        { expiresIn: '15m' }  // Short-lived\n    );\n\n    const refreshToken = jwt.sign(\n        { userId },\n        process.env.JWT_REFRESH_SECRET!,\n        { expiresIn: '7d' }  // Long-lived\n    );\n\n    return { accessToken, refreshToken };\n}\n\n// Verify JWT\nfunction verifyToken(token: string): JWTPayload {\n    try {\n        return jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;\n    } catch (error) {\n        if (error instanceof jwt.TokenExpiredError) {\n            throw new Error('Token expired');\n        }\n        if (error instanceof jwt.JsonWebTokenError) {\n            throw new Error('Invalid token');\n        }\n        throw error;\n    }\n}\n\n// Middleware\nfunction authenticate(req: Request, res: Response, next: NextFunction) {\n    const authHeader = req.headers.authorization;\n    if (!authHeader?.startsWith('Bearer ')) {\n        return res.status(401).json({ error: 'No token provided' });\n    }\n\n    const token = authHeader.substring(7);\n    try {\n        const payload = verifyToken(token);\n        req.user = payload;  // Attach user to request\n        next();\n    } catch (error) {\n        return res.status(401).json({ error: 'Invalid token' });\n    }\n}\n\n// Usage\napp.get('/api/profile', authenticate, (req, res) => {\n    res.json({ user: req.user });\n});\n```\n\n### Pattern 2: Refresh Token Flow\n\n```typescript\ninterface StoredRefreshToken {\n    token: string;\n    userId: string;\n    expiresAt: Date;\n    createdAt: Date;\n}\n\nclass RefreshTokenService {\n    // Store refresh token in database\n    async storeRefreshToken(userId: string, refreshToken: string) {\n        const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);\n        await db.refreshTokens.create({\n            token: await hash(refreshToken),  // Hash before storing\n            userId,\n            expiresAt,\n        });\n    }\n\n    // Refresh access token\n    async refreshAccessToken(refreshToken: string) {\n        // Verify refresh token\n        let payload;\n        try {\n            payload = jwt.verify(\n                refreshToken,\n                process.env.JWT_REFRESH_SECRET!\n            ) as { userId: string };\n        } catch {\n            throw new Error('Invalid refresh token');\n        }\n\n        // Check if token exists in database\n        const storedToken = await db.refreshTokens.findOne({\n            where: {\n                token: await hash(refreshToken),\n                userId: payload.userId,\n                expiresAt: { $gt: new Date() },\n            },\n        });\n\n        if (!storedToken) {\n            throw new Error('Refresh token not found or expired');\n        }\n\n        // Get user\n        const user = await db.users.findById(payload.userId);\n        if (!user) {\n            throw new Error('User not found');\n        }\n\n        // Generate new access token\n        const accessToken = jwt.sign(\n            { userId: user.id, email: user.email, role: user.role },\n            process.env.JWT_SECRET!,\n            { expiresIn: '15m' }\n        );\n\n        return { accessToken };\n    }\n\n    // Revoke refresh token (logout)\n    async revokeRefreshToken(refreshToken: string) {\n        await db.refreshTokens.deleteOne({\n            token: await hash(refreshToken),\n        });\n    }\n\n    // Revoke all user tokens (logout all devices)\n    async revokeAllUserTokens(userId: string) {\n        await db.refreshTokens.deleteMany({ userId });\n    }\n}\n\n// API endpoints\napp.post('/api/auth/refresh', async (req, res) => {\n    const { refreshToken } = req.body;\n    try {\n        const { accessToken } = await refreshTokenService\n            .refreshAccessToken(refreshToken);\n        res.json({ accessToken });\n    } catch (error) {\n        res.status(401).json({ error: 'Invalid refresh token' });\n    }\n});\n\napp.post('/api/auth/logout', authenticate, async (req, res) => {\n    const { refreshToken } = req.body;\n    await refreshTokenService.revokeRefreshToken(refreshToken);\n    res.json({ message: 'Logged out successfully' });\n});\n```\n\n## Session-Based Authentication\n\n### Pattern 1: Express Session\n\n```typescript\nimport session from 'express-session';\nimport RedisStore from 'connect-redis';\nimport { createClient } from 'redis';\n\n// Setup Redis for session storage\nconst redisClient = createClient({\n    url: process.env.REDIS_URL,\n});\nawait redisClient.connect();\n\napp.use(\n    session({\n        store: new RedisStore({ client: redisClient }),\n        secret: process.env.SESSION_SECRET!,\n        resave: false,\n        saveUninitialized: false,\n        cookie: {\n            secure: process.env.NODE_ENV === 'production',  // HTTPS only\n            httpOnly: true,  // No JavaScript access\n            maxAge: 24 * 60 * 60 * 1000,  // 24 hours\n            sameSite: 'strict',  // CSRF protection\n        },\n    })\n);\n\n// Login\napp.post('/api/auth/login', async (req, res) => {\n    const { email, password } = req.body;\n\n    const user = await db.users.findOne({ email });\n    if (!user || !(await verifyPassword(password, user.passwordHash))) {\n        return res.status(401).json({ error: 'Invalid credentials' });\n    }\n\n    // Store user in session\n    req.session.userId = user.id;\n    req.session.role = user.role;\n\n    res.json({ user: { id: user.id, email: user.email, role: user.role } });\n});\n\n// Session middleware\nfunction requireAuth(req: Request, res: Response, next: NextFunction) {\n    if (!req.session.userId) {\n        return res.status(401).json({ error: 'Not authenticated' });\n    }\n    next();\n}\n\n// Protected route\napp.get('/api/profile', requireAuth, async (req, res) => {\n    const user = await db.users.findById(req.session.userId);\n    res.json({ user });\n});\n\n// Logout\napp.post('/api/auth/logout', (req, res) => {\n    req.session.destroy((err) => {\n        if (err) {\n            return res.status(500).json({ error: 'Logout failed' });\n        }\n        res.clearCookie('connect.sid');\n        res.json({ message: 'Logged out successfully' });\n    });\n});\n```\n\n## OAuth2 / Social Login\n\n### Pattern 1: OAuth2 with Passport.js\n\n```typescript\nimport passport from 'passport';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\nimport { Strategy as GitHubStrategy } from 'passport-github2';\n\n// Google OAuth\npassport.use(\n    new GoogleStrategy(\n        {\n            clientID: process.env.GOOGLE_CLIENT_ID!,\n            clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n            callbackURL: '/api/auth/google/callback',\n        },\n        async (accessToken, refreshToken, profile, done) => {\n            try {\n                // Find or create user\n                let user = await db.users.findOne({\n                    googleId: profile.id,\n                });\n\n                if (!user) {\n                    user = await db.users.create({\n                        googleId: profile.id,\n                        email: profile.emails?.[0]?.value,\n                        name: profile.displayName,\n                        avatar: profile.photos?.[0]?.value,\n                    });\n                }\n\n                return done(null, user);\n            } catch (error) {\n                return done(error, undefined);\n            }\n        }\n    )\n);\n\n// Routes\napp.get('/api/auth/google', passport.authenticate('google', {\n    scope: ['profile', 'email'],\n}));\n\napp.get(\n    '/api/auth/google/callback',\n    passport.authenticate('google', { session: false }),\n    (req, res) => {\n        // Generate JWT\n        const tokens = generateTokens(req.user.id, req.user.email, req.user.role);\n        // Redirect to frontend with token\n        res.redirect(`${process.env.FRONTEND_URL}/auth/callback?token=${tokens.accessToken}`);\n    }\n);\n```\n\n## Authorization Patterns\n\n### Pattern 1: Role-Based Access Control (RBAC)\n\n```typescript\nenum Role {\n    USER = 'user',\n    MODERATOR = 'moderator',\n    ADMIN = 'admin',\n}\n\nconst roleHierarchy: Record<Role, Role[]> = {\n    [Role.ADMIN]: [Role.ADMIN, Role.MODERATOR, Role.USER],\n    [Role.MODERATOR]: [Role.MODERATOR, Role.USER],\n    [Role.USER]: [Role.USER],\n};\n\nfunction hasRole(userRole: Role, requiredRole: Role): boolean {\n    return roleHierarchy[userRole].includes(requiredRole);\n}\n\n// Middleware\nfunction requireRole(...roles: Role[]) {\n    return (req: Request, res: Response, next: NextFunction) => {\n        if (!req.user) {\n            return res.status(401).json({ error: 'Not authenticated' });\n        }\n\n        if (!roles.some(role => hasRole(req.user.role, role))) {\n            return res.status(403).json({ error: 'Insufficient permissions' });\n        }\n\n        next();\n    };\n}\n\n// Usage\napp.delete('/api/users/:id',\n    authenticate,\n    requireRole(Role.ADMIN),\n    async (req, res) => {\n        // Only admins can delete users\n        await db.users.delete(req.params.id);\n        res.json({ message: 'User deleted' });\n    }\n);\n```\n\n### Pattern 2: Permission-Based Access Control\n\n```typescript\nenum Permission {\n    READ_USERS = 'read:users',\n    WRITE_USERS = 'write:users',\n    DELETE_USERS = 'delete:users',\n    READ_POSTS = 'read:posts',\n    WRITE_POSTS = 'write:posts',\n}\n\nconst rolePermissions: Record<Role, Permission[]> = {\n    [Role.USER]: [Permission.READ_POSTS, Permission.WRITE_POSTS],\n    [Role.MODERATOR]: [\n        Permission.READ_POSTS,\n        Permission.WRITE_POSTS,\n        Permission.READ_USERS,\n    ],\n    [Role.ADMIN]: Object.values(Permission),\n};\n\nfunction hasPermission(userRole: Role, permission: Permission): boolean {\n    return rolePermissions[userRole]?.includes(permission) ?? false;\n}\n\nfunction requirePermission(...permissions: Permission[]) {\n    return (req: Request, res: Response, next: NextFunction) => {\n        if (!req.user) {\n            return res.status(401).json({ error: 'Not authenticated' });\n        }\n\n        const hasAllPermissions = permissions.every(permission =>\n            hasPermission(req.user.role, permission)\n        );\n\n        if (!hasAllPermissions) {\n            return res.status(403).json({ error: 'Insufficient permissions' });\n        }\n\n        next();\n    };\n}\n\n// Usage\napp.get('/api/users',\n    authenticate,\n    requirePermission(Permission.READ_USERS),\n    async (req, res) => {\n        const users = await db.users.findAll();\n        res.json({ users });\n    }\n);\n```\n\n### Pattern 3: Resource Ownership\n\n```typescript\n// Check if user owns resource\nasync function requireOwnership(\n    resourceType: 'post' | 'comment',\n    resourceIdParam: string = 'id'\n) {\n    return async (req: Request, res: Response, next: NextFunction) => {\n        if (!req.user) {\n            return res.status(401).json({ error: 'Not authenticated' });\n        }\n\n        const resourceId = req.params[resourceIdParam];\n\n        // Admins can access anything\n        if (req.user.role === Role.ADMIN) {\n            return next();\n        }\n\n        // Check ownership\n        let resource;\n        if (resourceType === 'post') {\n            resource = await db.posts.findById(resourceId);\n        } else if (resourceType === 'comment') {\n            resource = await db.comments.findById(resourceId);\n        }\n\n        if (!resource) {\n            return res.status(404).json({ error: 'Resource not found' });\n        }\n\n        if (resource.userId !== req.user.userId) {\n            return res.status(403).json({ error: 'Not authorized' });\n        }\n\n        next();\n    };\n}\n\n// Usage\napp.put('/api/posts/:id',\n    authenticate,\n    requireOwnership('post'),\n    async (req, res) => {\n        // User can only update their own posts\n        const post = await db.posts.update(req.params.id, req.body);\n        res.json({ post });\n    }\n);\n```\n\n## Security Best Practices\n\n### Pattern 1: Password Security\n\n```typescript\nimport bcrypt from 'bcrypt';\nimport { z } from 'zod';\n\n// Password validation schema\nconst passwordSchema = z.string()\n    .min(12, 'Password must be at least 12 characters')\n    .regex(/[A-Z]/, 'Password must contain uppercase letter')\n    .regex(/[a-z]/, 'Password must contain lowercase letter')\n    .regex(/[0-9]/, 'Password must contain number')\n    .regex(/[^A-Za-z0-9]/, 'Password must contain special character');\n\n// Hash password\nasync function hashPassword(password: string): Promise<string> {\n    const saltRounds = 12;  // 2^12 iterations\n    return bcrypt.hash(password, saltRounds);\n}\n\n// Verify password\nasync function verifyPassword(\n    password: string,\n    hash: string\n): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n}\n\n// Registration with password validation\napp.post('/api/auth/register', async (req, res) => {\n    try {\n        const { email, password } = req.body;\n\n        // Validate password\n        passwordSchema.parse(password);\n\n        // Check if user exists\n        const existingUser = await db.users.findOne({ email });\n        if (existingUser) {\n            return res.status(400).json({ error: 'Email already registered' });\n        }\n\n        // Hash password\n        const passwordHash = await hashPassword(password);\n\n        // Create user\n        const user = await db.users.create({\n            email,\n            passwordHash,\n        });\n\n        // Generate tokens\n        const tokens = generateTokens(user.id, user.email, user.role);\n\n        res.status(201).json({\n            user: { id: user.id, email: user.email },\n            ...tokens,\n        });\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            return res.status(400).json({ error: error.errors[0].message });\n        }\n        res.status(500).json({ error: 'Registration failed' });\n    }\n});\n```\n\n### Pattern 2: Rate Limiting\n\n```typescript\nimport rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\n\n// Login rate limiter\nconst loginLimiter = rateLimit({\n    store: new RedisStore({ client: redisClient }),\n    windowMs: 15 * 60 * 1000,  // 15 minutes\n    max: 5,  // 5 attempts\n    message: 'Too many login attempts, please try again later',\n    standardHeaders: true,\n    legacyHeaders: false,\n});\n\n// API rate limiter\nconst apiLimiter = rateLimit({\n    windowMs: 60 * 1000,  // 1 minute\n    max: 100,  // 100 requests per minute\n    standardHeaders: true,\n});\n\n// Apply to routes\napp.post('/api/auth/login', loginLimiter, async (req, res) => {\n    // Login logic\n});\n\napp.use('/api/', apiLimiter);\n```\n\n## Best Practices\n\n1. **Never Store Plain Passwords**: Always hash with bcrypt/argon2\n2. **Use HTTPS**: Encrypt data in transit\n3. **Short-Lived Access Tokens**: 15-30 minutes max\n4. **Secure Cookies**: httpOnly, secure, sameSite flags\n5. **Validate All Input**: Email format, password strength\n6. **Rate Limit Auth Endpoints**: Prevent brute force attacks\n7. **Implement CSRF Protection**: For session-based auth\n8. **Rotate Secrets Regularly**: JWT secrets, session secrets\n9. **Log Security Events**: Login attempts, failed auth\n10. **Use MFA When Possible**: Extra security layer\n\n## Common Pitfalls\n\n- **Weak Passwords**: Enforce strong password policies\n- **JWT in localStorage**: Vulnerable to XSS, use httpOnly cookies\n- **No Token Expiration**: Tokens should expire\n- **Client-Side Auth Checks Only**: Always validate server-side\n- **Insecure Password Reset**: Use secure tokens with expiration\n- **No Rate Limiting**: Vulnerable to brute force\n- **Trusting Client Data**: Always validate on server\n\n## Resources\n\n- **references/jwt-best-practices.md**: JWT implementation guide\n- **references/oauth2-flows.md**: OAuth2 flow diagrams and examples\n- **references/session-security.md**: Secure session management\n- **assets/auth-security-checklist.md**: Security review checklist\n- **assets/password-policy-template.md**: Password requirements template\n- **scripts/token-validator.ts**: JWT validation utility\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "debugging-strategies",
      "description": "Master systematic debugging techniques, profiling tools, and root cause analysis to efficiently track down bugs across any codebase or technology stack. Use when investigating bugs, performance issues, or unexpected behavior.",
      "plugin": "developer-essentials",
      "source_path": "plugins/developer-essentials/skills/debugging-strategies/SKILL.md",
      "category": "development",
      "keywords": [
        "git",
        "sql",
        "debugging",
        "testing",
        "authentication",
        "code-review",
        "monorepo",
        "essential"
      ],
      "content": "---\nname: debugging-strategies\ndescription: Master systematic debugging techniques, profiling tools, and root cause analysis to efficiently track down bugs across any codebase or technology stack. Use when investigating bugs, performance issues, or unexpected behavior.\n---\n\n# Debugging Strategies\n\nTransform debugging from frustrating guesswork into systematic problem-solving with proven strategies, powerful tools, and methodical approaches.\n\n## When to Use This Skill\n\n- Tracking down elusive bugs\n- Investigating performance issues\n- Understanding unfamiliar codebases\n- Debugging production issues\n- Analyzing crash dumps and stack traces\n- Profiling application performance\n- Investigating memory leaks\n- Debugging distributed systems\n\n## Core Principles\n\n### 1. The Scientific Method\n\n**1. Observe**: What's the actual behavior?\n**2. Hypothesize**: What could be causing it?\n**3. Experiment**: Test your hypothesis\n**4. Analyze**: Did it prove/disprove your theory?\n**5. Repeat**: Until you find the root cause\n\n### 2. Debugging Mindset\n\n**Don't Assume:**\n- \"It can't be X\" - Yes it can\n- \"I didn't change Y\" - Check anyway\n- \"It works on my machine\" - Find out why\n\n**Do:**\n- Reproduce consistently\n- Isolate the problem\n- Keep detailed notes\n- Question everything\n- Take breaks when stuck\n\n### 3. Rubber Duck Debugging\n\nExplain your code and problem out loud (to a rubber duck, colleague, or yourself). Often reveals the issue.\n\n## Systematic Debugging Process\n\n### Phase 1: Reproduce\n\n```markdown\n## Reproduction Checklist\n\n1. **Can you reproduce it?**\n   - Always? Sometimes? Randomly?\n   - Specific conditions needed?\n   - Can others reproduce it?\n\n2. **Create minimal reproduction**\n   - Simplify to smallest example\n   - Remove unrelated code\n   - Isolate the problem\n\n3. **Document steps**\n   - Write down exact steps\n   - Note environment details\n   - Capture error messages\n```\n\n### Phase 2: Gather Information\n\n```markdown\n## Information Collection\n\n1. **Error Messages**\n   - Full stack trace\n   - Error codes\n   - Console/log output\n\n2. **Environment**\n   - OS version\n   - Language/runtime version\n   - Dependencies versions\n   - Environment variables\n\n3. **Recent Changes**\n   - Git history\n   - Deployment timeline\n   - Configuration changes\n\n4. **Scope**\n   - Affects all users or specific ones?\n   - All browsers or specific ones?\n   - Production only or also dev?\n```\n\n### Phase 3: Form Hypothesis\n\n```markdown\n## Hypothesis Formation\n\nBased on gathered info, ask:\n\n1. **What changed?**\n   - Recent code changes\n   - Dependency updates\n   - Infrastructure changes\n\n2. **What's different?**\n   - Working vs broken environment\n   - Working vs broken user\n   - Before vs after\n\n3. **Where could this fail?**\n   - Input validation\n   - Business logic\n   - Data layer\n   - External services\n```\n\n### Phase 4: Test & Verify\n\n```markdown\n## Testing Strategies\n\n1. **Binary Search**\n   - Comment out half the code\n   - Narrow down problematic section\n   - Repeat until found\n\n2. **Add Logging**\n   - Strategic console.log/print\n   - Track variable values\n   - Trace execution flow\n\n3. **Isolate Components**\n   - Test each piece separately\n   - Mock dependencies\n   - Remove complexity\n\n4. **Compare Working vs Broken**\n   - Diff configurations\n   - Diff environments\n   - Diff data\n```\n\n## Debugging Tools\n\n### JavaScript/TypeScript Debugging\n\n```typescript\n// Chrome DevTools Debugger\nfunction processOrder(order: Order) {\n    debugger;  // Execution pauses here\n\n    const total = calculateTotal(order);\n    console.log('Total:', total);\n\n    // Conditional breakpoint\n    if (order.items.length > 10) {\n        debugger;  // Only breaks if condition true\n    }\n\n    return total;\n}\n\n// Console debugging techniques\nconsole.log('Value:', value);                    // Basic\nconsole.table(arrayOfObjects);                   // Table format\nconsole.time('operation'); /* code */ console.timeEnd('operation');  // Timing\nconsole.trace();                                 // Stack trace\nconsole.assert(value > 0, 'Value must be positive');  // Assertion\n\n// Performance profiling\nperformance.mark('start-operation');\n// ... operation code\nperformance.mark('end-operation');\nperformance.measure('operation', 'start-operation', 'end-operation');\nconsole.log(performance.getEntriesByType('measure'));\n```\n\n**VS Code Debugger Configuration:**\n```json\n// .vscode/launch.json\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"node\",\n            \"request\": \"launch\",\n            \"name\": \"Debug Program\",\n            \"program\": \"${workspaceFolder}/src/index.ts\",\n            \"preLaunchTask\": \"tsc: build - tsconfig.json\",\n            \"outFiles\": [\"${workspaceFolder}/dist/**/*.js\"],\n            \"skipFiles\": [\"<node_internals>/**\"]\n        },\n        {\n            \"type\": \"node\",\n            \"request\": \"launch\",\n            \"name\": \"Debug Tests\",\n            \"program\": \"${workspaceFolder}/node_modules/jest/bin/jest\",\n            \"args\": [\"--runInBand\", \"--no-cache\"],\n            \"console\": \"integratedTerminal\"\n        }\n    ]\n}\n```\n\n### Python Debugging\n\n```python\n# Built-in debugger (pdb)\nimport pdb\n\ndef calculate_total(items):\n    total = 0\n    pdb.set_trace()  # Debugger starts here\n\n    for item in items:\n        total += item.price * item.quantity\n\n    return total\n\n# Breakpoint (Python 3.7+)\ndef process_order(order):\n    breakpoint()  # More convenient than pdb.set_trace()\n    # ... code\n\n# Post-mortem debugging\ntry:\n    risky_operation()\nexcept Exception:\n    import pdb\n    pdb.post_mortem()  # Debug at exception point\n\n# IPython debugging (ipdb)\nfrom ipdb import set_trace\nset_trace()  # Better interface than pdb\n\n# Logging for debugging\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\ndef fetch_user(user_id):\n    logger.debug(f'Fetching user: {user_id}')\n    user = db.query(User).get(user_id)\n    logger.debug(f'Found user: {user}')\n    return user\n\n# Profile performance\nimport cProfile\nimport pstats\n\ncProfile.run('slow_function()', 'profile_stats')\nstats = pstats.Stats('profile_stats')\nstats.sort_stats('cumulative')\nstats.print_stats(10)  # Top 10 slowest\n```\n\n### Go Debugging\n\n```go\n// Delve debugger\n// Install: go install github.com/go-delve/delve/cmd/dlv@latest\n// Run: dlv debug main.go\n\nimport (\n    \"fmt\"\n    \"runtime\"\n    \"runtime/debug\"\n)\n\n// Print stack trace\nfunc debugStack() {\n    debug.PrintStack()\n}\n\n// Panic recovery with debugging\nfunc processRequest() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"Panic:\", r)\n            debug.PrintStack()\n        }\n    }()\n\n    // ... code that might panic\n}\n\n// Memory profiling\nimport _ \"net/http/pprof\"\n// Visit http://localhost:6060/debug/pprof/\n\n// CPU profiling\nimport (\n    \"os\"\n    \"runtime/pprof\"\n)\n\nf, _ := os.Create(\"cpu.prof\")\npprof.StartCPUProfile(f)\ndefer pprof.StopCPUProfile()\n// ... code to profile\n```\n\n## Advanced Debugging Techniques\n\n### Technique 1: Binary Search Debugging\n\n```bash\n# Git bisect for finding regression\ngit bisect start\ngit bisect bad                    # Current commit is bad\ngit bisect good v1.0.0            # v1.0.0 was good\n\n# Git checks out middle commit\n# Test it, then:\ngit bisect good   # if it works\ngit bisect bad    # if it's broken\n\n# Continue until bug found\ngit bisect reset  # when done\n```\n\n### Technique 2: Differential Debugging\n\nCompare working vs broken:\n\n```markdown\n## What's Different?\n\n| Aspect       | Working         | Broken          |\n|--------------|-----------------|-----------------|\n| Environment  | Development     | Production      |\n| Node version | 18.16.0         | 18.15.0         |\n| Data         | Empty DB        | 1M records      |\n| User         | Admin           | Regular user    |\n| Browser      | Chrome          | Safari          |\n| Time         | During day      | After midnight  |\n\nHypothesis: Time-based issue? Check timezone handling.\n```\n\n### Technique 3: Trace Debugging\n\n```typescript\n// Function call tracing\nfunction trace(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function(...args: any[]) {\n        console.log(`Calling ${propertyKey} with args:`, args);\n        const result = originalMethod.apply(this, args);\n        console.log(`${propertyKey} returned:`, result);\n        return result;\n    };\n\n    return descriptor;\n}\n\nclass OrderService {\n    @trace\n    calculateTotal(items: Item[]): number {\n        return items.reduce((sum, item) => sum + item.price, 0);\n    }\n}\n```\n\n### Technique 4: Memory Leak Detection\n\n```typescript\n// Chrome DevTools Memory Profiler\n// 1. Take heap snapshot\n// 2. Perform action\n// 3. Take another snapshot\n// 4. Compare snapshots\n\n// Node.js memory debugging\nif (process.memoryUsage().heapUsed > 500 * 1024 * 1024) {\n    console.warn('High memory usage:', process.memoryUsage());\n\n    // Generate heap dump\n    require('v8').writeHeapSnapshot();\n}\n\n// Find memory leaks in tests\nlet beforeMemory: number;\n\nbeforeEach(() => {\n    beforeMemory = process.memoryUsage().heapUsed;\n});\n\nafterEach(() => {\n    const afterMemory = process.memoryUsage().heapUsed;\n    const diff = afterMemory - beforeMemory;\n\n    if (diff > 10 * 1024 * 1024) {  // 10MB threshold\n        console.warn(`Possible memory leak: ${diff / 1024 / 1024}MB`);\n    }\n});\n```\n\n## Debugging Patterns by Issue Type\n\n### Pattern 1: Intermittent Bugs\n\n```markdown\n## Strategies for Flaky Bugs\n\n1. **Add extensive logging**\n   - Log timing information\n   - Log all state transitions\n   - Log external interactions\n\n2. **Look for race conditions**\n   - Concurrent access to shared state\n   - Async operations completing out of order\n   - Missing synchronization\n\n3. **Check timing dependencies**\n   - setTimeout/setInterval\n   - Promise resolution order\n   - Animation frame timing\n\n4. **Stress test**\n   - Run many times\n   - Vary timing\n   - Simulate load\n```\n\n### Pattern 2: Performance Issues\n\n```markdown\n## Performance Debugging\n\n1. **Profile first**\n   - Don't optimize blindly\n   - Measure before and after\n   - Find bottlenecks\n\n2. **Common culprits**\n   - N+1 queries\n   - Unnecessary re-renders\n   - Large data processing\n   - Synchronous I/O\n\n3. **Tools**\n   - Browser DevTools Performance tab\n   - Lighthouse\n   - Python: cProfile, line_profiler\n   - Node: clinic.js, 0x\n```\n\n### Pattern 3: Production Bugs\n\n```markdown\n## Production Debugging\n\n1. **Gather evidence**\n   - Error tracking (Sentry, Bugsnag)\n   - Application logs\n   - User reports\n   - Metrics/monitoring\n\n2. **Reproduce locally**\n   - Use production data (anonymized)\n   - Match environment\n   - Follow exact steps\n\n3. **Safe investigation**\n   - Don't change production\n   - Use feature flags\n   - Add monitoring/logging\n   - Test fixes in staging\n```\n\n## Best Practices\n\n1. **Reproduce First**: Can't fix what you can't reproduce\n2. **Isolate the Problem**: Remove complexity until minimal case\n3. **Read Error Messages**: They're usually helpful\n4. **Check Recent Changes**: Most bugs are recent\n5. **Use Version Control**: Git bisect, blame, history\n6. **Take Breaks**: Fresh eyes see better\n7. **Document Findings**: Help future you\n8. **Fix Root Cause**: Not just symptoms\n\n## Common Debugging Mistakes\n\n- **Making Multiple Changes**: Change one thing at a time\n- **Not Reading Error Messages**: Read the full stack trace\n- **Assuming It's Complex**: Often it's simple\n- **Debug Logging in Prod**: Remove before shipping\n- **Not Using Debugger**: console.log isn't always best\n- **Giving Up Too Soon**: Persistence pays off\n- **Not Testing the Fix**: Verify it actually works\n\n## Quick Debugging Checklist\n\n```markdown\n## When Stuck, Check:\n\n- [ ] Spelling errors (typos in variable names)\n- [ ] Case sensitivity (fileName vs filename)\n- [ ] Null/undefined values\n- [ ] Array index off-by-one\n- [ ] Async timing (race conditions)\n- [ ] Scope issues (closure, hoisting)\n- [ ] Type mismatches\n- [ ] Missing dependencies\n- [ ] Environment variables\n- [ ] File paths (absolute vs relative)\n- [ ] Cache issues (clear cache)\n- [ ] Stale data (refresh database)\n```\n\n## Resources\n\n- **references/debugging-tools-guide.md**: Comprehensive tool documentation\n- **references/performance-profiling.md**: Performance debugging guide\n- **references/production-debugging.md**: Debugging live systems\n- **assets/debugging-checklist.md**: Quick reference checklist\n- **assets/common-bugs.md**: Common bug patterns\n- **scripts/debug-helper.ts**: Debugging utility functions\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "monorepo-management",
      "description": "Master monorepo management with Turborepo, Nx, and pnpm workspaces to build efficient, scalable multi-package repositories with optimized builds and dependency management. Use when setting up monorepos, optimizing builds, or managing shared dependencies.",
      "plugin": "developer-essentials",
      "source_path": "plugins/developer-essentials/skills/monorepo-management/SKILL.md",
      "category": "development",
      "keywords": [
        "git",
        "sql",
        "debugging",
        "testing",
        "authentication",
        "code-review",
        "monorepo",
        "essential"
      ],
      "content": "---\nname: monorepo-management\ndescription: Master monorepo management with Turborepo, Nx, and pnpm workspaces to build efficient, scalable multi-package repositories with optimized builds and dependency management. Use when setting up monorepos, optimizing builds, or managing shared dependencies.\n---\n\n# Monorepo Management\n\nBuild efficient, scalable monorepos that enable code sharing, consistent tooling, and atomic changes across multiple packages and applications.\n\n## When to Use This Skill\n\n- Setting up new monorepo projects\n- Migrating from multi-repo to monorepo\n- Optimizing build and test performance\n- Managing shared dependencies\n- Implementing code sharing strategies\n- Setting up CI/CD for monorepos\n- Versioning and publishing packages\n- Debugging monorepo-specific issues\n\n## Core Concepts\n\n### 1. Why Monorepos?\n\n**Advantages:**\n- Shared code and dependencies\n- Atomic commits across projects\n- Consistent tooling and standards\n- Easier refactoring\n- Simplified dependency management\n- Better code visibility\n\n**Challenges:**\n- Build performance at scale\n- CI/CD complexity\n- Access control\n- Large Git repository\n\n### 2. Monorepo Tools\n\n**Package Managers:**\n- pnpm workspaces (recommended)\n- npm workspaces\n- Yarn workspaces\n\n**Build Systems:**\n- Turborepo (recommended for most)\n- Nx (feature-rich, complex)\n- Lerna (older, maintenance mode)\n\n## Turborepo Setup\n\n### Initial Setup\n\n```bash\n# Create new monorepo\nnpx create-turbo@latest my-monorepo\ncd my-monorepo\n\n# Structure:\n# apps/\n#   web/          - Next.js app\n#   docs/         - Documentation site\n# packages/\n#   ui/           - Shared UI components\n#   config/       - Shared configurations\n#   tsconfig/     - Shared TypeScript configs\n# turbo.json      - Turborepo configuration\n# package.json    - Root package.json\n```\n\n### Configuration\n\n```json\n// turbo.json\n{\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"globalDependencies\": [\"**/.env.*local\"],\n  \"pipeline\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": [\"dist/**\", \".next/**\", \"!.next/cache/**\"]\n    },\n    \"test\": {\n      \"dependsOn\": [\"build\"],\n      \"outputs\": [\"coverage/**\"]\n    },\n    \"lint\": {\n      \"outputs\": []\n    },\n    \"dev\": {\n      \"cache\": false,\n      \"persistent\": true\n    },\n    \"type-check\": {\n      \"dependsOn\": [\"^build\"],\n      \"outputs\": []\n    }\n  }\n}\n```\n\n```json\n// package.json (root)\n{\n  \"name\": \"my-monorepo\",\n  \"private\": true,\n  \"workspaces\": [\n    \"apps/*\",\n    \"packages/*\"\n  ],\n  \"scripts\": {\n    \"build\": \"turbo run build\",\n    \"dev\": \"turbo run dev\",\n    \"test\": \"turbo run test\",\n    \"lint\": \"turbo run lint\",\n    \"format\": \"prettier --write \\\"**/*.{ts,tsx,md}\\\"\",\n    \"clean\": \"turbo run clean && rm -rf node_modules\"\n  },\n  \"devDependencies\": {\n    \"turbo\": \"^1.10.0\",\n    \"prettier\": \"^3.0.0\",\n    \"typescript\": \"^5.0.0\"\n  },\n  \"packageManager\": \"pnpm@8.0.0\"\n}\n```\n\n### Package Structure\n\n```json\n// packages/ui/package.json\n{\n  \"name\": \"@repo/ui\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    },\n    \"./button\": {\n      \"import\": \"./dist/button.js\",\n      \"types\": \"./dist/button.d.ts\"\n    }\n  },\n  \"scripts\": {\n    \"build\": \"tsup src/index.ts --format esm,cjs --dts\",\n    \"dev\": \"tsup src/index.ts --format esm,cjs --dts --watch\",\n    \"lint\": \"eslint src/\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"devDependencies\": {\n    \"@repo/tsconfig\": \"workspace:*\",\n    \"tsup\": \"^7.0.0\",\n    \"typescript\": \"^5.0.0\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.2.0\"\n  }\n}\n```\n\n## pnpm Workspaces\n\n### Setup\n\n```yaml\n# pnpm-workspace.yaml\npackages:\n  - 'apps/*'\n  - 'packages/*'\n  - 'tools/*'\n```\n\n```json\n// .npmrc\n# Hoist shared dependencies\nshamefully-hoist=true\n\n# Strict peer dependencies\nauto-install-peers=true\nstrict-peer-dependencies=true\n\n# Performance\nstore-dir=~/.pnpm-store\n```\n\n### Dependency Management\n\n```bash\n# Install dependency in specific package\npnpm add react --filter @repo/ui\npnpm add -D typescript --filter @repo/ui\n\n# Install workspace dependency\npnpm add @repo/ui --filter web\n\n# Install in all packages\npnpm add -D eslint -w\n\n# Update all dependencies\npnpm update -r\n\n# Remove dependency\npnpm remove react --filter @repo/ui\n```\n\n### Scripts\n\n```bash\n# Run script in specific package\npnpm --filter web dev\npnpm --filter @repo/ui build\n\n# Run in all packages\npnpm -r build\npnpm -r test\n\n# Run in parallel\npnpm -r --parallel dev\n\n# Filter by pattern\npnpm --filter \"@repo/*\" build\npnpm --filter \"...web\" build  # Build web and dependencies\n```\n\n## Nx Monorepo\n\n### Setup\n\n```bash\n# Create Nx monorepo\nnpx create-nx-workspace@latest my-org\n\n# Generate applications\nnx generate @nx/react:app my-app\nnx generate @nx/next:app my-next-app\n\n# Generate libraries\nnx generate @nx/react:lib ui-components\nnx generate @nx/js:lib utils\n```\n\n### Configuration\n\n```json\n// nx.json\n{\n  \"extends\": \"nx/presets/npm.json\",\n  \"$schema\": \"./node_modules/nx/schemas/nx-schema.json\",\n  \"targetDefaults\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"],\n      \"inputs\": [\"production\", \"^production\"],\n      \"cache\": true\n    },\n    \"test\": {\n      \"inputs\": [\"default\", \"^production\", \"{workspaceRoot}/jest.preset.js\"],\n      \"cache\": true\n    },\n    \"lint\": {\n      \"inputs\": [\"default\", \"{workspaceRoot}/.eslintrc.json\"],\n      \"cache\": true\n    }\n  },\n  \"namedInputs\": {\n    \"default\": [\"{projectRoot}/**/*\", \"sharedGlobals\"],\n    \"production\": [\n      \"default\",\n      \"!{projectRoot}/**/?(*.)+(spec|test).[jt]s?(x)?(.snap)\",\n      \"!{projectRoot}/tsconfig.spec.json\"\n    ],\n    \"sharedGlobals\": []\n  }\n}\n```\n\n### Running Tasks\n\n```bash\n# Run task for specific project\nnx build my-app\nnx test ui-components\nnx lint utils\n\n# Run for affected projects\nnx affected:build\nnx affected:test --base=main\n\n# Visualize dependencies\nnx graph\n\n# Run in parallel\nnx run-many --target=build --all --parallel=3\n```\n\n## Shared Configurations\n\n### TypeScript Configuration\n\n```json\n// packages/tsconfig/base.json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"incremental\": true,\n    \"declaration\": true\n  },\n  \"exclude\": [\"node_modules\"]\n}\n\n// packages/tsconfig/react.json\n{\n  \"extends\": \"./base.json\",\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsx\",\n    \"lib\": [\"ES2022\", \"DOM\", \"DOM.Iterable\"]\n  }\n}\n\n// apps/web/tsconfig.json\n{\n  \"extends\": \"@repo/tsconfig/react.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n### ESLint Configuration\n\n```javascript\n// packages/config/eslint-preset.js\nmodule.exports = {\n  extends: [\n    'eslint:recommended',\n    'plugin:@typescript-eslint/recommended',\n    'plugin:react/recommended',\n    'plugin:react-hooks/recommended',\n    'prettier',\n  ],\n  plugins: ['@typescript-eslint', 'react', 'react-hooks'],\n  parser: '@typescript-eslint/parser',\n  parserOptions: {\n    ecmaVersion: 2022,\n    sourceType: 'module',\n    ecmaFeatures: {\n      jsx: true,\n    },\n  },\n  settings: {\n    react: {\n      version: 'detect',\n    },\n  },\n  rules: {\n    '@typescript-eslint/no-unused-vars': 'error',\n    'react/react-in-jsx-scope': 'off',\n  },\n};\n\n// apps/web/.eslintrc.js\nmodule.exports = {\n  extends: ['@repo/config/eslint-preset'],\n  rules: {\n    // App-specific rules\n  },\n};\n```\n\n## Code Sharing Patterns\n\n### Pattern 1: Shared UI Components\n\n```typescript\n// packages/ui/src/button.tsx\nimport * as React from 'react';\n\nexport interface ButtonProps {\n  variant?: 'primary' | 'secondary';\n  children: React.ReactNode;\n  onClick?: () => void;\n}\n\nexport function Button({ variant = 'primary', children, onClick }: ButtonProps) {\n  return (\n    <button\n      className={`btn btn-${variant}`}\n      onClick={onClick}\n    >\n      {children}\n    </button>\n  );\n}\n\n// packages/ui/src/index.ts\nexport { Button, type ButtonProps } from './button';\nexport { Input, type InputProps } from './input';\n\n// apps/web/src/app.tsx\nimport { Button } from '@repo/ui';\n\nexport function App() {\n  return <Button variant=\"primary\">Click me</Button>;\n}\n```\n\n### Pattern 2: Shared Utilities\n\n```typescript\n// packages/utils/src/string.ts\nexport function capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function truncate(str: string, length: number): string {\n  return str.length > length ? str.slice(0, length) + '...' : str;\n}\n\n// packages/utils/src/index.ts\nexport * from './string';\nexport * from './array';\nexport * from './date';\n\n// Usage in apps\nimport { capitalize, truncate } from '@repo/utils';\n```\n\n### Pattern 3: Shared Types\n\n```typescript\n// packages/types/src/user.ts\nexport interface User {\n  id: string;\n  email: string;\n  name: string;\n  role: 'admin' | 'user';\n}\n\nexport interface CreateUserInput {\n  email: string;\n  name: string;\n  password: string;\n}\n\n// Used in both frontend and backend\nimport type { User, CreateUserInput } from '@repo/types';\n```\n\n## Build Optimization\n\n### Turborepo Caching\n\n```json\n// turbo.json\n{\n  \"pipeline\": {\n    \"build\": {\n      // Build depends on dependencies being built first\n      \"dependsOn\": [\"^build\"],\n\n      // Cache these outputs\n      \"outputs\": [\"dist/**\", \".next/**\"],\n\n      // Cache based on these inputs (default: all files)\n      \"inputs\": [\"src/**/*.tsx\", \"src/**/*.ts\", \"package.json\"]\n    },\n    \"test\": {\n      // Run tests in parallel, don't depend on build\n      \"cache\": true,\n      \"outputs\": [\"coverage/**\"]\n    }\n  }\n}\n```\n\n### Remote Caching\n\n```bash\n# Turborepo Remote Cache (Vercel)\nnpx turbo login\nnpx turbo link\n\n# Custom remote cache\n# turbo.json\n{\n  \"remoteCache\": {\n    \"signature\": true,\n    \"enabled\": true\n  }\n}\n```\n\n## CI/CD for Monorepos\n\n### GitHub Actions\n\n```yaml\n# .github/workflows/ci.yml\nname: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0  # For Nx affected commands\n\n      - uses: pnpm/action-setup@v2\n        with:\n          version: 8\n\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 18\n          cache: 'pnpm'\n\n      - name: Install dependencies\n        run: pnpm install --frozen-lockfile\n\n      - name: Build\n        run: pnpm turbo run build\n\n      - name: Test\n        run: pnpm turbo run test\n\n      - name: Lint\n        run: pnpm turbo run lint\n\n      - name: Type check\n        run: pnpm turbo run type-check\n```\n\n### Deploy Affected Only\n\n```yaml\n# Deploy only changed apps\n- name: Deploy affected apps\n  run: |\n    if pnpm nx affected:apps --base=origin/main --head=HEAD | grep -q \"web\"; then\n      echo \"Deploying web app\"\n      pnpm --filter web deploy\n    fi\n```\n\n## Best Practices\n\n1. **Consistent Versioning**: Lock dependency versions across workspace\n2. **Shared Configs**: Centralize ESLint, TypeScript, Prettier configs\n3. **Dependency Graph**: Keep it acyclic, avoid circular dependencies\n4. **Cache Effectively**: Configure inputs/outputs correctly\n5. **Type Safety**: Share types between frontend/backend\n6. **Testing Strategy**: Unit tests in packages, E2E in apps\n7. **Documentation**: README in each package\n8. **Release Strategy**: Use changesets for versioning\n\n## Common Pitfalls\n\n- **Circular Dependencies**: A depends on B, B depends on A\n- **Phantom Dependencies**: Using deps not in package.json\n- **Incorrect Cache Inputs**: Missing files in Turborepo inputs\n- **Over-Sharing**: Sharing code that should be separate\n- **Under-Sharing**: Duplicating code across packages\n- **Large Monorepos**: Without proper tooling, builds slow down\n\n## Publishing Packages\n\n```bash\n# Using Changesets\npnpm add -Dw @changesets/cli\npnpm changeset init\n\n# Create changeset\npnpm changeset\n\n# Version packages\npnpm changeset version\n\n# Publish\npnpm changeset publish\n```\n\n```yaml\n# .github/workflows/release.yml\n- name: Create Release Pull Request or Publish\n  uses: changesets/action@v1\n  with:\n    publish: pnpm release\n  env:\n    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n    NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n```\n\n## Resources\n\n- **references/turborepo-guide.md**: Comprehensive Turborepo documentation\n- **references/nx-guide.md**: Nx monorepo patterns\n- **references/pnpm-workspaces.md**: pnpm workspace features\n- **assets/monorepo-checklist.md**: Setup checklist\n- **assets/migration-guide.md**: Multi-repo to monorepo migration\n- **scripts/dependency-graph.ts**: Visualize package dependencies\n",
      "references": {},
      "assets": {}
    }
  ],
  "counts": {
    "agents": 0,
    "commands": 0,
    "skills": 8
  }
}