{
  "total_count": 12,
  "category": "languages",
  "skills": [
    {
      "name": "async-python-patterns",
      "description": "Master Python asyncio, concurrent programming, and async/await patterns for high-performance applications. Use when building async APIs, concurrent systems, or I/O-bound applications requiring non-blocking operations.",
      "plugin": "python-development",
      "source_path": "plugins/python-development/skills/async-python-patterns/SKILL.md",
      "category": "languages",
      "keywords": [
        "python",
        "django",
        "fastapi",
        "async",
        "backend"
      ],
      "content": "---\nname: async-python-patterns\ndescription: Master Python asyncio, concurrent programming, and async/await patterns for high-performance applications. Use when building async APIs, concurrent systems, or I/O-bound applications requiring non-blocking operations.\n---\n\n# Async Python Patterns\n\nComprehensive guidance for implementing asynchronous Python applications using asyncio, concurrent programming patterns, and async/await for building high-performance, non-blocking systems.\n\n## When to Use This Skill\n\n- Building async web APIs (FastAPI, aiohttp, Sanic)\n- Implementing concurrent I/O operations (database, file, network)\n- Creating web scrapers with concurrent requests\n- Developing real-time applications (WebSocket servers, chat systems)\n- Processing multiple independent tasks simultaneously\n- Building microservices with async communication\n- Optimizing I/O-bound workloads\n- Implementing async background tasks and queues\n\n## Core Concepts\n\n### 1. Event Loop\nThe event loop is the heart of asyncio, managing and scheduling asynchronous tasks.\n\n**Key characteristics:**\n- Single-threaded cooperative multitasking\n- Schedules coroutines for execution\n- Handles I/O operations without blocking\n- Manages callbacks and futures\n\n### 2. Coroutines\nFunctions defined with `async def` that can be paused and resumed.\n\n**Syntax:**\n```python\nasync def my_coroutine():\n    result = await some_async_operation()\n    return result\n```\n\n### 3. Tasks\nScheduled coroutines that run concurrently on the event loop.\n\n### 4. Futures\nLow-level objects representing eventual results of async operations.\n\n### 5. Async Context Managers\nResources that support `async with` for proper cleanup.\n\n### 6. Async Iterators\nObjects that support `async for` for iterating over async data sources.\n\n## Quick Start\n\n```python\nimport asyncio\n\nasync def main():\n    print(\"Hello\")\n    await asyncio.sleep(1)\n    print(\"World\")\n\n# Python 3.7+\nasyncio.run(main())\n```\n\n## Fundamental Patterns\n\n### Pattern 1: Basic Async/Await\n\n```python\nimport asyncio\n\nasync def fetch_data(url: str) -> dict:\n    \"\"\"Fetch data from URL asynchronously.\"\"\"\n    await asyncio.sleep(1)  # Simulate I/O\n    return {\"url\": url, \"data\": \"result\"}\n\nasync def main():\n    result = await fetch_data(\"https://api.example.com\")\n    print(result)\n\nasyncio.run(main())\n```\n\n### Pattern 2: Concurrent Execution with gather()\n\n```python\nimport asyncio\nfrom typing import List\n\nasync def fetch_user(user_id: int) -> dict:\n    \"\"\"Fetch user data.\"\"\"\n    await asyncio.sleep(0.5)\n    return {\"id\": user_id, \"name\": f\"User {user_id}\"}\n\nasync def fetch_all_users(user_ids: List[int]) -> List[dict]:\n    \"\"\"Fetch multiple users concurrently.\"\"\"\n    tasks = [fetch_user(uid) for uid in user_ids]\n    results = await asyncio.gather(*tasks)\n    return results\n\nasync def main():\n    user_ids = [1, 2, 3, 4, 5]\n    users = await fetch_all_users(user_ids)\n    print(f\"Fetched {len(users)} users\")\n\nasyncio.run(main())\n```\n\n### Pattern 3: Task Creation and Management\n\n```python\nimport asyncio\n\nasync def background_task(name: str, delay: int):\n    \"\"\"Long-running background task.\"\"\"\n    print(f\"{name} started\")\n    await asyncio.sleep(delay)\n    print(f\"{name} completed\")\n    return f\"Result from {name}\"\n\nasync def main():\n    # Create tasks\n    task1 = asyncio.create_task(background_task(\"Task 1\", 2))\n    task2 = asyncio.create_task(background_task(\"Task 2\", 1))\n\n    # Do other work\n    print(\"Main: doing other work\")\n    await asyncio.sleep(0.5)\n\n    # Wait for tasks\n    result1 = await task1\n    result2 = await task2\n\n    print(f\"Results: {result1}, {result2}\")\n\nasyncio.run(main())\n```\n\n### Pattern 4: Error Handling in Async Code\n\n```python\nimport asyncio\nfrom typing import List, Optional\n\nasync def risky_operation(item_id: int) -> dict:\n    \"\"\"Operation that might fail.\"\"\"\n    await asyncio.sleep(0.1)\n    if item_id % 3 == 0:\n        raise ValueError(f\"Item {item_id} failed\")\n    return {\"id\": item_id, \"status\": \"success\"}\n\nasync def safe_operation(item_id: int) -> Optional[dict]:\n    \"\"\"Wrapper with error handling.\"\"\"\n    try:\n        return await risky_operation(item_id)\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        return None\n\nasync def process_items(item_ids: List[int]):\n    \"\"\"Process multiple items with error handling.\"\"\"\n    tasks = [safe_operation(iid) for iid in item_ids]\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n\n    # Filter out failures\n    successful = [r for r in results if r is not None and not isinstance(r, Exception)]\n    failed = [r for r in results if isinstance(r, Exception)]\n\n    print(f\"Success: {len(successful)}, Failed: {len(failed)}\")\n    return successful\n\nasyncio.run(process_items([1, 2, 3, 4, 5, 6]))\n```\n\n### Pattern 5: Timeout Handling\n\n```python\nimport asyncio\n\nasync def slow_operation(delay: int) -> str:\n    \"\"\"Operation that takes time.\"\"\"\n    await asyncio.sleep(delay)\n    return f\"Completed after {delay}s\"\n\nasync def with_timeout():\n    \"\"\"Execute operation with timeout.\"\"\"\n    try:\n        result = await asyncio.wait_for(slow_operation(5), timeout=2.0)\n        print(result)\n    except asyncio.TimeoutError:\n        print(\"Operation timed out\")\n\nasyncio.run(with_timeout())\n```\n\n## Advanced Patterns\n\n### Pattern 6: Async Context Managers\n\n```python\nimport asyncio\nfrom typing import Optional\n\nclass AsyncDatabaseConnection:\n    \"\"\"Async database connection context manager.\"\"\"\n\n    def __init__(self, dsn: str):\n        self.dsn = dsn\n        self.connection: Optional[object] = None\n\n    async def __aenter__(self):\n        print(\"Opening connection\")\n        await asyncio.sleep(0.1)  # Simulate connection\n        self.connection = {\"dsn\": self.dsn, \"connected\": True}\n        return self.connection\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        print(\"Closing connection\")\n        await asyncio.sleep(0.1)  # Simulate cleanup\n        self.connection = None\n\nasync def query_database():\n    \"\"\"Use async context manager.\"\"\"\n    async with AsyncDatabaseConnection(\"postgresql://localhost\") as conn:\n        print(f\"Using connection: {conn}\")\n        await asyncio.sleep(0.2)  # Simulate query\n        return {\"rows\": 10}\n\nasyncio.run(query_database())\n```\n\n### Pattern 7: Async Iterators and Generators\n\n```python\nimport asyncio\nfrom typing import AsyncIterator\n\nasync def async_range(start: int, end: int, delay: float = 0.1) -> AsyncIterator[int]:\n    \"\"\"Async generator that yields numbers with delay.\"\"\"\n    for i in range(start, end):\n        await asyncio.sleep(delay)\n        yield i\n\nasync def fetch_pages(url: str, max_pages: int) -> AsyncIterator[dict]:\n    \"\"\"Fetch paginated data asynchronously.\"\"\"\n    for page in range(1, max_pages + 1):\n        await asyncio.sleep(0.2)  # Simulate API call\n        yield {\n            \"page\": page,\n            \"url\": f\"{url}?page={page}\",\n            \"data\": [f\"item_{page}_{i}\" for i in range(5)]\n        }\n\nasync def consume_async_iterator():\n    \"\"\"Consume async iterator.\"\"\"\n    async for number in async_range(1, 5):\n        print(f\"Number: {number}\")\n\n    print(\"\\nFetching pages:\")\n    async for page_data in fetch_pages(\"https://api.example.com/items\", 3):\n        print(f\"Page {page_data['page']}: {len(page_data['data'])} items\")\n\nasyncio.run(consume_async_iterator())\n```\n\n### Pattern 8: Producer-Consumer Pattern\n\n```python\nimport asyncio\nfrom asyncio import Queue\nfrom typing import Optional\n\nasync def producer(queue: Queue, producer_id: int, num_items: int):\n    \"\"\"Produce items and put them in queue.\"\"\"\n    for i in range(num_items):\n        item = f\"Item-{producer_id}-{i}\"\n        await queue.put(item)\n        print(f\"Producer {producer_id} produced: {item}\")\n        await asyncio.sleep(0.1)\n    await queue.put(None)  # Signal completion\n\nasync def consumer(queue: Queue, consumer_id: int):\n    \"\"\"Consume items from queue.\"\"\"\n    while True:\n        item = await queue.get()\n        if item is None:\n            queue.task_done()\n            break\n\n        print(f\"Consumer {consumer_id} processing: {item}\")\n        await asyncio.sleep(0.2)  # Simulate work\n        queue.task_done()\n\nasync def producer_consumer_example():\n    \"\"\"Run producer-consumer pattern.\"\"\"\n    queue = Queue(maxsize=10)\n\n    # Create tasks\n    producers = [\n        asyncio.create_task(producer(queue, i, 5))\n        for i in range(2)\n    ]\n\n    consumers = [\n        asyncio.create_task(consumer(queue, i))\n        for i in range(3)\n    ]\n\n    # Wait for producers\n    await asyncio.gather(*producers)\n\n    # Wait for queue to be empty\n    await queue.join()\n\n    # Cancel consumers\n    for c in consumers:\n        c.cancel()\n\nasyncio.run(producer_consumer_example())\n```\n\n### Pattern 9: Semaphore for Rate Limiting\n\n```python\nimport asyncio\nfrom typing import List\n\nasync def api_call(url: str, semaphore: asyncio.Semaphore) -> dict:\n    \"\"\"Make API call with rate limiting.\"\"\"\n    async with semaphore:\n        print(f\"Calling {url}\")\n        await asyncio.sleep(0.5)  # Simulate API call\n        return {\"url\": url, \"status\": 200}\n\nasync def rate_limited_requests(urls: List[str], max_concurrent: int = 5):\n    \"\"\"Make multiple requests with rate limiting.\"\"\"\n    semaphore = asyncio.Semaphore(max_concurrent)\n    tasks = [api_call(url, semaphore) for url in urls]\n    results = await asyncio.gather(*tasks)\n    return results\n\nasync def main():\n    urls = [f\"https://api.example.com/item/{i}\" for i in range(20)]\n    results = await rate_limited_requests(urls, max_concurrent=3)\n    print(f\"Completed {len(results)} requests\")\n\nasyncio.run(main())\n```\n\n### Pattern 10: Async Locks and Synchronization\n\n```python\nimport asyncio\n\nclass AsyncCounter:\n    \"\"\"Thread-safe async counter.\"\"\"\n\n    def __init__(self):\n        self.value = 0\n        self.lock = asyncio.Lock()\n\n    async def increment(self):\n        \"\"\"Safely increment counter.\"\"\"\n        async with self.lock:\n            current = self.value\n            await asyncio.sleep(0.01)  # Simulate work\n            self.value = current + 1\n\n    async def get_value(self) -> int:\n        \"\"\"Get current value.\"\"\"\n        async with self.lock:\n            return self.value\n\nasync def worker(counter: AsyncCounter, worker_id: int):\n    \"\"\"Worker that increments counter.\"\"\"\n    for _ in range(10):\n        await counter.increment()\n        print(f\"Worker {worker_id} incremented\")\n\nasync def test_counter():\n    \"\"\"Test concurrent counter.\"\"\"\n    counter = AsyncCounter()\n\n    workers = [asyncio.create_task(worker(counter, i)) for i in range(5)]\n    await asyncio.gather(*workers)\n\n    final_value = await counter.get_value()\n    print(f\"Final counter value: {final_value}\")\n\nasyncio.run(test_counter())\n```\n\n## Real-World Applications\n\n### Web Scraping with aiohttp\n\n```python\nimport asyncio\nimport aiohttp\nfrom typing import List, Dict\n\nasync def fetch_url(session: aiohttp.ClientSession, url: str) -> Dict:\n    \"\"\"Fetch single URL.\"\"\"\n    try:\n        async with session.get(url, timeout=aiohttp.ClientTimeout(total=10)) as response:\n            text = await response.text()\n            return {\n                \"url\": url,\n                \"status\": response.status,\n                \"length\": len(text)\n            }\n    except Exception as e:\n        return {\"url\": url, \"error\": str(e)}\n\nasync def scrape_urls(urls: List[str]) -> List[Dict]:\n    \"\"\"Scrape multiple URLs concurrently.\"\"\"\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n        return results\n\nasync def main():\n    urls = [\n        \"https://httpbin.org/delay/1\",\n        \"https://httpbin.org/delay/2\",\n        \"https://httpbin.org/status/404\",\n    ]\n\n    results = await scrape_urls(urls)\n    for result in results:\n        print(result)\n\nasyncio.run(main())\n```\n\n### Async Database Operations\n\n```python\nimport asyncio\nfrom typing import List, Optional\n\n# Simulated async database client\nclass AsyncDB:\n    \"\"\"Simulated async database.\"\"\"\n\n    async def execute(self, query: str) -> List[dict]:\n        \"\"\"Execute query.\"\"\"\n        await asyncio.sleep(0.1)\n        return [{\"id\": 1, \"name\": \"Example\"}]\n\n    async def fetch_one(self, query: str) -> Optional[dict]:\n        \"\"\"Fetch single row.\"\"\"\n        await asyncio.sleep(0.1)\n        return {\"id\": 1, \"name\": \"Example\"}\n\nasync def get_user_data(db: AsyncDB, user_id: int) -> dict:\n    \"\"\"Fetch user and related data concurrently.\"\"\"\n    user_task = db.fetch_one(f\"SELECT * FROM users WHERE id = {user_id}\")\n    orders_task = db.execute(f\"SELECT * FROM orders WHERE user_id = {user_id}\")\n    profile_task = db.fetch_one(f\"SELECT * FROM profiles WHERE user_id = {user_id}\")\n\n    user, orders, profile = await asyncio.gather(user_task, orders_task, profile_task)\n\n    return {\n        \"user\": user,\n        \"orders\": orders,\n        \"profile\": profile\n    }\n\nasync def main():\n    db = AsyncDB()\n    user_data = await get_user_data(db, 1)\n    print(user_data)\n\nasyncio.run(main())\n```\n\n### WebSocket Server\n\n```python\nimport asyncio\nfrom typing import Set\n\n# Simulated WebSocket connection\nclass WebSocket:\n    \"\"\"Simulated WebSocket.\"\"\"\n\n    def __init__(self, client_id: str):\n        self.client_id = client_id\n\n    async def send(self, message: str):\n        \"\"\"Send message.\"\"\"\n        print(f\"Sending to {self.client_id}: {message}\")\n        await asyncio.sleep(0.01)\n\n    async def recv(self) -> str:\n        \"\"\"Receive message.\"\"\"\n        await asyncio.sleep(1)\n        return f\"Message from {self.client_id}\"\n\nclass WebSocketServer:\n    \"\"\"Simple WebSocket server.\"\"\"\n\n    def __init__(self):\n        self.clients: Set[WebSocket] = set()\n\n    async def register(self, websocket: WebSocket):\n        \"\"\"Register new client.\"\"\"\n        self.clients.add(websocket)\n        print(f\"Client {websocket.client_id} connected\")\n\n    async def unregister(self, websocket: WebSocket):\n        \"\"\"Unregister client.\"\"\"\n        self.clients.remove(websocket)\n        print(f\"Client {websocket.client_id} disconnected\")\n\n    async def broadcast(self, message: str):\n        \"\"\"Broadcast message to all clients.\"\"\"\n        if self.clients:\n            tasks = [client.send(message) for client in self.clients]\n            await asyncio.gather(*tasks)\n\n    async def handle_client(self, websocket: WebSocket):\n        \"\"\"Handle individual client connection.\"\"\"\n        await self.register(websocket)\n        try:\n            async for message in self.message_iterator(websocket):\n                await self.broadcast(f\"{websocket.client_id}: {message}\")\n        finally:\n            await self.unregister(websocket)\n\n    async def message_iterator(self, websocket: WebSocket):\n        \"\"\"Iterate over messages from client.\"\"\"\n        for _ in range(3):  # Simulate 3 messages\n            yield await websocket.recv()\n```\n\n## Performance Best Practices\n\n### 1. Use Connection Pools\n\n```python\nimport asyncio\nimport aiohttp\n\nasync def with_connection_pool():\n    \"\"\"Use connection pool for efficiency.\"\"\"\n    connector = aiohttp.TCPConnector(limit=100, limit_per_host=10)\n\n    async with aiohttp.ClientSession(connector=connector) as session:\n        tasks = [session.get(f\"https://api.example.com/item/{i}\") for i in range(50)]\n        responses = await asyncio.gather(*tasks)\n        return responses\n```\n\n### 2. Batch Operations\n\n```python\nasync def batch_process(items: List[str], batch_size: int = 10):\n    \"\"\"Process items in batches.\"\"\"\n    for i in range(0, len(items), batch_size):\n        batch = items[i:i + batch_size]\n        tasks = [process_item(item) for item in batch]\n        await asyncio.gather(*tasks)\n        print(f\"Processed batch {i // batch_size + 1}\")\n\nasync def process_item(item: str):\n    \"\"\"Process single item.\"\"\"\n    await asyncio.sleep(0.1)\n    return f\"Processed: {item}\"\n```\n\n### 3. Avoid Blocking Operations\n\n```python\nimport asyncio\nimport concurrent.futures\nfrom typing import Any\n\ndef blocking_operation(data: Any) -> Any:\n    \"\"\"CPU-intensive blocking operation.\"\"\"\n    import time\n    time.sleep(1)\n    return data * 2\n\nasync def run_in_executor(data: Any) -> Any:\n    \"\"\"Run blocking operation in thread pool.\"\"\"\n    loop = asyncio.get_event_loop()\n    with concurrent.futures.ThreadPoolExecutor() as pool:\n        result = await loop.run_in_executor(pool, blocking_operation, data)\n        return result\n\nasync def main():\n    results = await asyncio.gather(*[run_in_executor(i) for i in range(5)])\n    print(results)\n\nasyncio.run(main())\n```\n\n## Common Pitfalls\n\n### 1. Forgetting await\n\n```python\n# Wrong - returns coroutine object, doesn't execute\nresult = async_function()\n\n# Correct\nresult = await async_function()\n```\n\n### 2. Blocking the Event Loop\n\n```python\n# Wrong - blocks event loop\nimport time\nasync def bad():\n    time.sleep(1)  # Blocks!\n\n# Correct\nasync def good():\n    await asyncio.sleep(1)  # Non-blocking\n```\n\n### 3. Not Handling Cancellation\n\n```python\nasync def cancelable_task():\n    \"\"\"Task that handles cancellation.\"\"\"\n    try:\n        while True:\n            await asyncio.sleep(1)\n            print(\"Working...\")\n    except asyncio.CancelledError:\n        print(\"Task cancelled, cleaning up...\")\n        # Perform cleanup\n        raise  # Re-raise to propagate cancellation\n```\n\n### 4. Mixing Sync and Async Code\n\n```python\n# Wrong - can't call async from sync directly\ndef sync_function():\n    result = await async_function()  # SyntaxError!\n\n# Correct\ndef sync_function():\n    result = asyncio.run(async_function())\n```\n\n## Testing Async Code\n\n```python\nimport asyncio\nimport pytest\n\n# Using pytest-asyncio\n@pytest.mark.asyncio\nasync def test_async_function():\n    \"\"\"Test async function.\"\"\"\n    result = await fetch_data(\"https://api.example.com\")\n    assert result is not None\n\n@pytest.mark.asyncio\nasync def test_with_timeout():\n    \"\"\"Test with timeout.\"\"\"\n    with pytest.raises(asyncio.TimeoutError):\n        await asyncio.wait_for(slow_operation(5), timeout=1.0)\n```\n\n## Resources\n\n- **Python asyncio documentation**: https://docs.python.org/3/library/asyncio.html\n- **aiohttp**: Async HTTP client/server\n- **FastAPI**: Modern async web framework\n- **asyncpg**: Async PostgreSQL driver\n- **motor**: Async MongoDB driver\n\n## Best Practices Summary\n\n1. **Use asyncio.run()** for entry point (Python 3.7+)\n2. **Always await coroutines** to execute them\n3. **Use gather() for concurrent execution** of multiple tasks\n4. **Implement proper error handling** with try/except\n5. **Use timeouts** to prevent hanging operations\n6. **Pool connections** for better performance\n7. **Avoid blocking operations** in async code\n8. **Use semaphores** for rate limiting\n9. **Handle task cancellation** properly\n10. **Test async code** with pytest-asyncio\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "python-testing-patterns",
      "description": "Implement comprehensive testing strategies with pytest, fixtures, mocking, and test-driven development. Use when writing Python tests, setting up test suites, or implementing testing best practices.",
      "plugin": "python-development",
      "source_path": "plugins/python-development/skills/python-testing-patterns/SKILL.md",
      "category": "languages",
      "keywords": [
        "python",
        "django",
        "fastapi",
        "async",
        "backend"
      ],
      "content": "---\nname: python-testing-patterns\ndescription: Implement comprehensive testing strategies with pytest, fixtures, mocking, and test-driven development. Use when writing Python tests, setting up test suites, or implementing testing best practices.\n---\n\n# Python Testing Patterns\n\nComprehensive guide to implementing robust testing strategies in Python using pytest, fixtures, mocking, parameterization, and test-driven development practices.\n\n## When to Use This Skill\n\n- Writing unit tests for Python code\n- Setting up test suites and test infrastructure\n- Implementing test-driven development (TDD)\n- Creating integration tests for APIs and services\n- Mocking external dependencies and services\n- Testing async code and concurrent operations\n- Setting up continuous testing in CI/CD\n- Implementing property-based testing\n- Testing database operations\n- Debugging failing tests\n\n## Core Concepts\n\n### 1. Test Types\n- **Unit Tests**: Test individual functions/classes in isolation\n- **Integration Tests**: Test interaction between components\n- **Functional Tests**: Test complete features end-to-end\n- **Performance Tests**: Measure speed and resource usage\n\n### 2. Test Structure (AAA Pattern)\n- **Arrange**: Set up test data and preconditions\n- **Act**: Execute the code under test\n- **Assert**: Verify the results\n\n### 3. Test Coverage\n- Measure what code is exercised by tests\n- Identify untested code paths\n- Aim for meaningful coverage, not just high percentages\n\n### 4. Test Isolation\n- Tests should be independent\n- No shared state between tests\n- Each test should clean up after itself\n\n## Quick Start\n\n```python\n# test_example.py\ndef add(a, b):\n    return a + b\n\ndef test_add():\n    \"\"\"Basic test example.\"\"\"\n    result = add(2, 3)\n    assert result == 5\n\ndef test_add_negative():\n    \"\"\"Test with negative numbers.\"\"\"\n    assert add(-1, 1) == 0\n\n# Run with: pytest test_example.py\n```\n\n## Fundamental Patterns\n\n### Pattern 1: Basic pytest Tests\n\n```python\n# test_calculator.py\nimport pytest\n\nclass Calculator:\n    \"\"\"Simple calculator for testing.\"\"\"\n\n    def add(self, a: float, b: float) -> float:\n        return a + b\n\n    def subtract(self, a: float, b: float) -> float:\n        return a - b\n\n    def multiply(self, a: float, b: float) -> float:\n        return a * b\n\n    def divide(self, a: float, b: float) -> float:\n        if b == 0:\n            raise ValueError(\"Cannot divide by zero\")\n        return a / b\n\n\ndef test_addition():\n    \"\"\"Test addition.\"\"\"\n    calc = Calculator()\n    assert calc.add(2, 3) == 5\n    assert calc.add(-1, 1) == 0\n    assert calc.add(0, 0) == 0\n\n\ndef test_subtraction():\n    \"\"\"Test subtraction.\"\"\"\n    calc = Calculator()\n    assert calc.subtract(5, 3) == 2\n    assert calc.subtract(0, 5) == -5\n\n\ndef test_multiplication():\n    \"\"\"Test multiplication.\"\"\"\n    calc = Calculator()\n    assert calc.multiply(3, 4) == 12\n    assert calc.multiply(0, 5) == 0\n\n\ndef test_division():\n    \"\"\"Test division.\"\"\"\n    calc = Calculator()\n    assert calc.divide(6, 3) == 2\n    assert calc.divide(5, 2) == 2.5\n\n\ndef test_division_by_zero():\n    \"\"\"Test division by zero raises error.\"\"\"\n    calc = Calculator()\n    with pytest.raises(ValueError, match=\"Cannot divide by zero\"):\n        calc.divide(5, 0)\n```\n\n### Pattern 2: Fixtures for Setup and Teardown\n\n```python\n# test_database.py\nimport pytest\nfrom typing import Generator\n\nclass Database:\n    \"\"\"Simple database class.\"\"\"\n\n    def __init__(self, connection_string: str):\n        self.connection_string = connection_string\n        self.connected = False\n\n    def connect(self):\n        \"\"\"Connect to database.\"\"\"\n        self.connected = True\n\n    def disconnect(self):\n        \"\"\"Disconnect from database.\"\"\"\n        self.connected = False\n\n    def query(self, sql: str) -> list:\n        \"\"\"Execute query.\"\"\"\n        if not self.connected:\n            raise RuntimeError(\"Not connected\")\n        return [{\"id\": 1, \"name\": \"Test\"}]\n\n\n@pytest.fixture\ndef db() -> Generator[Database, None, None]:\n    \"\"\"Fixture that provides connected database.\"\"\"\n    # Setup\n    database = Database(\"sqlite:///:memory:\")\n    database.connect()\n\n    # Provide to test\n    yield database\n\n    # Teardown\n    database.disconnect()\n\n\ndef test_database_query(db):\n    \"\"\"Test database query with fixture.\"\"\"\n    results = db.query(\"SELECT * FROM users\")\n    assert len(results) == 1\n    assert results[0][\"name\"] == \"Test\"\n\n\n@pytest.fixture(scope=\"session\")\ndef app_config():\n    \"\"\"Session-scoped fixture - created once per test session.\"\"\"\n    return {\n        \"database_url\": \"postgresql://localhost/test\",\n        \"api_key\": \"test-key\",\n        \"debug\": True\n    }\n\n\n@pytest.fixture(scope=\"module\")\ndef api_client(app_config):\n    \"\"\"Module-scoped fixture - created once per test module.\"\"\"\n    # Setup expensive resource\n    client = {\"config\": app_config, \"session\": \"active\"}\n    yield client\n    # Cleanup\n    client[\"session\"] = \"closed\"\n\n\ndef test_api_client(api_client):\n    \"\"\"Test using api client fixture.\"\"\"\n    assert api_client[\"session\"] == \"active\"\n    assert api_client[\"config\"][\"debug\"] is True\n```\n\n### Pattern 3: Parameterized Tests\n\n```python\n# test_validation.py\nimport pytest\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"Check if email is valid.\"\"\"\n    return \"@\" in email and \".\" in email.split(\"@\")[1]\n\n\n@pytest.mark.parametrize(\"email,expected\", [\n    (\"user@example.com\", True),\n    (\"test.user@domain.co.uk\", True),\n    (\"invalid.email\", False),\n    (\"@example.com\", False),\n    (\"user@domain\", False),\n    (\"\", False),\n])\ndef test_email_validation(email, expected):\n    \"\"\"Test email validation with various inputs.\"\"\"\n    assert is_valid_email(email) == expected\n\n\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (2, 3, 5),\n    (0, 0, 0),\n    (-1, 1, 0),\n    (100, 200, 300),\n    (-5, -5, -10),\n])\ndef test_addition_parameterized(a, b, expected):\n    \"\"\"Test addition with multiple parameter sets.\"\"\"\n    from test_calculator import Calculator\n    calc = Calculator()\n    assert calc.add(a, b) == expected\n\n\n# Using pytest.param for special cases\n@pytest.mark.parametrize(\"value,expected\", [\n    pytest.param(1, True, id=\"positive\"),\n    pytest.param(0, False, id=\"zero\"),\n    pytest.param(-1, False, id=\"negative\"),\n])\ndef test_is_positive(value, expected):\n    \"\"\"Test with custom test IDs.\"\"\"\n    assert (value > 0) == expected\n```\n\n### Pattern 4: Mocking with unittest.mock\n\n```python\n# test_api_client.py\nimport pytest\nfrom unittest.mock import Mock, patch, MagicMock\nimport requests\n\nclass APIClient:\n    \"\"\"Simple API client.\"\"\"\n\n    def __init__(self, base_url: str):\n        self.base_url = base_url\n\n    def get_user(self, user_id: int) -> dict:\n        \"\"\"Fetch user from API.\"\"\"\n        response = requests.get(f\"{self.base_url}/users/{user_id}\")\n        response.raise_for_status()\n        return response.json()\n\n    def create_user(self, data: dict) -> dict:\n        \"\"\"Create new user.\"\"\"\n        response = requests.post(f\"{self.base_url}/users\", json=data)\n        response.raise_for_status()\n        return response.json()\n\n\ndef test_get_user_success():\n    \"\"\"Test successful API call with mock.\"\"\"\n    client = APIClient(\"https://api.example.com\")\n\n    mock_response = Mock()\n    mock_response.json.return_value = {\"id\": 1, \"name\": \"John Doe\"}\n    mock_response.raise_for_status.return_value = None\n\n    with patch(\"requests.get\", return_value=mock_response) as mock_get:\n        user = client.get_user(1)\n\n        assert user[\"id\"] == 1\n        assert user[\"name\"] == \"John Doe\"\n        mock_get.assert_called_once_with(\"https://api.example.com/users/1\")\n\n\ndef test_get_user_not_found():\n    \"\"\"Test API call with 404 error.\"\"\"\n    client = APIClient(\"https://api.example.com\")\n\n    mock_response = Mock()\n    mock_response.raise_for_status.side_effect = requests.HTTPError(\"404 Not Found\")\n\n    with patch(\"requests.get\", return_value=mock_response):\n        with pytest.raises(requests.HTTPError):\n            client.get_user(999)\n\n\n@patch(\"requests.post\")\ndef test_create_user(mock_post):\n    \"\"\"Test user creation with decorator syntax.\"\"\"\n    client = APIClient(\"https://api.example.com\")\n\n    mock_post.return_value.json.return_value = {\"id\": 2, \"name\": \"Jane Doe\"}\n    mock_post.return_value.raise_for_status.return_value = None\n\n    user_data = {\"name\": \"Jane Doe\", \"email\": \"jane@example.com\"}\n    result = client.create_user(user_data)\n\n    assert result[\"id\"] == 2\n    mock_post.assert_called_once()\n    call_args = mock_post.call_args\n    assert call_args.kwargs[\"json\"] == user_data\n```\n\n### Pattern 5: Testing Exceptions\n\n```python\n# test_exceptions.py\nimport pytest\n\ndef divide(a: float, b: float) -> float:\n    \"\"\"Divide a by b.\"\"\"\n    if b == 0:\n        raise ZeroDivisionError(\"Division by zero\")\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Arguments must be numbers\")\n    return a / b\n\n\ndef test_zero_division():\n    \"\"\"Test exception is raised for division by zero.\"\"\"\n    with pytest.raises(ZeroDivisionError):\n        divide(10, 0)\n\n\ndef test_zero_division_with_message():\n    \"\"\"Test exception message.\"\"\"\n    with pytest.raises(ZeroDivisionError, match=\"Division by zero\"):\n        divide(5, 0)\n\n\ndef test_type_error():\n    \"\"\"Test type error exception.\"\"\"\n    with pytest.raises(TypeError, match=\"must be numbers\"):\n        divide(\"10\", 5)\n\n\ndef test_exception_info():\n    \"\"\"Test accessing exception info.\"\"\"\n    with pytest.raises(ValueError) as exc_info:\n        int(\"not a number\")\n\n    assert \"invalid literal\" in str(exc_info.value)\n```\n\n## Advanced Patterns\n\n### Pattern 6: Testing Async Code\n\n```python\n# test_async.py\nimport pytest\nimport asyncio\n\nasync def fetch_data(url: str) -> dict:\n    \"\"\"Fetch data asynchronously.\"\"\"\n    await asyncio.sleep(0.1)\n    return {\"url\": url, \"data\": \"result\"}\n\n\n@pytest.mark.asyncio\nasync def test_fetch_data():\n    \"\"\"Test async function.\"\"\"\n    result = await fetch_data(\"https://api.example.com\")\n    assert result[\"url\"] == \"https://api.example.com\"\n    assert \"data\" in result\n\n\n@pytest.mark.asyncio\nasync def test_concurrent_fetches():\n    \"\"\"Test concurrent async operations.\"\"\"\n    urls = [\"url1\", \"url2\", \"url3\"]\n    tasks = [fetch_data(url) for url in urls]\n    results = await asyncio.gather(*tasks)\n\n    assert len(results) == 3\n    assert all(\"data\" in r for r in results)\n\n\n@pytest.fixture\nasync def async_client():\n    \"\"\"Async fixture.\"\"\"\n    client = {\"connected\": True}\n    yield client\n    client[\"connected\"] = False\n\n\n@pytest.mark.asyncio\nasync def test_with_async_fixture(async_client):\n    \"\"\"Test using async fixture.\"\"\"\n    assert async_client[\"connected\"] is True\n```\n\n### Pattern 7: Monkeypatch for Testing\n\n```python\n# test_environment.py\nimport os\nimport pytest\n\ndef get_database_url() -> str:\n    \"\"\"Get database URL from environment.\"\"\"\n    return os.environ.get(\"DATABASE_URL\", \"sqlite:///:memory:\")\n\n\ndef test_database_url_default():\n    \"\"\"Test default database URL.\"\"\"\n    # Will use actual environment variable if set\n    url = get_database_url()\n    assert url\n\n\ndef test_database_url_custom(monkeypatch):\n    \"\"\"Test custom database URL with monkeypatch.\"\"\"\n    monkeypatch.setenv(\"DATABASE_URL\", \"postgresql://localhost/test\")\n    assert get_database_url() == \"postgresql://localhost/test\"\n\n\ndef test_database_url_not_set(monkeypatch):\n    \"\"\"Test when env var is not set.\"\"\"\n    monkeypatch.delenv(\"DATABASE_URL\", raising=False)\n    assert get_database_url() == \"sqlite:///:memory:\"\n\n\nclass Config:\n    \"\"\"Configuration class.\"\"\"\n\n    def __init__(self):\n        self.api_key = \"production-key\"\n\n    def get_api_key(self):\n        return self.api_key\n\n\ndef test_monkeypatch_attribute(monkeypatch):\n    \"\"\"Test monkeypatching object attributes.\"\"\"\n    config = Config()\n    monkeypatch.setattr(config, \"api_key\", \"test-key\")\n    assert config.get_api_key() == \"test-key\"\n```\n\n### Pattern 8: Temporary Files and Directories\n\n```python\n# test_file_operations.py\nimport pytest\nfrom pathlib import Path\n\ndef save_data(filepath: Path, data: str):\n    \"\"\"Save data to file.\"\"\"\n    filepath.write_text(data)\n\n\ndef load_data(filepath: Path) -> str:\n    \"\"\"Load data from file.\"\"\"\n    return filepath.read_text()\n\n\ndef test_file_operations(tmp_path):\n    \"\"\"Test file operations with temporary directory.\"\"\"\n    # tmp_path is a pathlib.Path object\n    test_file = tmp_path / \"test_data.txt\"\n\n    # Save data\n    save_data(test_file, \"Hello, World!\")\n\n    # Verify file exists\n    assert test_file.exists()\n\n    # Load and verify data\n    data = load_data(test_file)\n    assert data == \"Hello, World!\"\n\n\ndef test_multiple_files(tmp_path):\n    \"\"\"Test with multiple temporary files.\"\"\"\n    files = {\n        \"file1.txt\": \"Content 1\",\n        \"file2.txt\": \"Content 2\",\n        \"file3.txt\": \"Content 3\"\n    }\n\n    for filename, content in files.items():\n        filepath = tmp_path / filename\n        save_data(filepath, content)\n\n    # Verify all files created\n    assert len(list(tmp_path.iterdir())) == 3\n\n    # Verify contents\n    for filename, expected_content in files.items():\n        filepath = tmp_path / filename\n        assert load_data(filepath) == expected_content\n```\n\n### Pattern 9: Custom Fixtures and Conftest\n\n```python\n# conftest.py\n\"\"\"Shared fixtures for all tests.\"\"\"\nimport pytest\n\n@pytest.fixture(scope=\"session\")\ndef database_url():\n    \"\"\"Provide database URL for all tests.\"\"\"\n    return \"postgresql://localhost/test_db\"\n\n\n@pytest.fixture(autouse=True)\ndef reset_database(database_url):\n    \"\"\"Auto-use fixture that runs before each test.\"\"\"\n    # Setup: Clear database\n    print(f\"Clearing database: {database_url}\")\n    yield\n    # Teardown: Clean up\n    print(\"Test completed\")\n\n\n@pytest.fixture\ndef sample_user():\n    \"\"\"Provide sample user data.\"\"\"\n    return {\n        \"id\": 1,\n        \"name\": \"Test User\",\n        \"email\": \"test@example.com\"\n    }\n\n\n@pytest.fixture\ndef sample_users():\n    \"\"\"Provide list of sample users.\"\"\"\n    return [\n        {\"id\": 1, \"name\": \"User 1\"},\n        {\"id\": 2, \"name\": \"User 2\"},\n        {\"id\": 3, \"name\": \"User 3\"},\n    ]\n\n\n# Parametrized fixture\n@pytest.fixture(params=[\"sqlite\", \"postgresql\", \"mysql\"])\ndef db_backend(request):\n    \"\"\"Fixture that runs tests with different database backends.\"\"\"\n    return request.param\n\n\ndef test_with_db_backend(db_backend):\n    \"\"\"This test will run 3 times with different backends.\"\"\"\n    print(f\"Testing with {db_backend}\")\n    assert db_backend in [\"sqlite\", \"postgresql\", \"mysql\"]\n```\n\n### Pattern 10: Property-Based Testing\n\n```python\n# test_properties.py\nfrom hypothesis import given, strategies as st\nimport pytest\n\ndef reverse_string(s: str) -> str:\n    \"\"\"Reverse a string.\"\"\"\n    return s[::-1]\n\n\n@given(st.text())\ndef test_reverse_twice_is_original(s):\n    \"\"\"Property: reversing twice returns original.\"\"\"\n    assert reverse_string(reverse_string(s)) == s\n\n\n@given(st.text())\ndef test_reverse_length(s):\n    \"\"\"Property: reversed string has same length.\"\"\"\n    assert len(reverse_string(s)) == len(s)\n\n\n@given(st.integers(), st.integers())\ndef test_addition_commutative(a, b):\n    \"\"\"Property: addition is commutative.\"\"\"\n    assert a + b == b + a\n\n\n@given(st.lists(st.integers()))\ndef test_sorted_list_properties(lst):\n    \"\"\"Property: sorted list is ordered.\"\"\"\n    sorted_lst = sorted(lst)\n\n    # Same length\n    assert len(sorted_lst) == len(lst)\n\n    # All elements present\n    assert set(sorted_lst) == set(lst)\n\n    # Is ordered\n    for i in range(len(sorted_lst) - 1):\n        assert sorted_lst[i] <= sorted_lst[i + 1]\n```\n\n## Testing Best Practices\n\n### Test Organization\n\n```python\n# tests/\n#   __init__.py\n#   conftest.py           # Shared fixtures\n#   test_unit/            # Unit tests\n#     test_models.py\n#     test_utils.py\n#   test_integration/     # Integration tests\n#     test_api.py\n#     test_database.py\n#   test_e2e/            # End-to-end tests\n#     test_workflows.py\n```\n\n### Test Naming\n\n```python\n# Good test names\ndef test_user_creation_with_valid_data():\n    \"\"\"Clear name describes what is being tested.\"\"\"\n    pass\n\n\ndef test_login_fails_with_invalid_password():\n    \"\"\"Name describes expected behavior.\"\"\"\n    pass\n\n\ndef test_api_returns_404_for_missing_resource():\n    \"\"\"Specific about inputs and expected outcomes.\"\"\"\n    pass\n\n\n# Bad test names\ndef test_1():  # Not descriptive\n    pass\n\n\ndef test_user():  # Too vague\n    pass\n\n\ndef test_function():  # Doesn't explain what's tested\n    pass\n```\n\n### Test Markers\n\n```python\n# test_markers.py\nimport pytest\n\n@pytest.mark.slow\ndef test_slow_operation():\n    \"\"\"Mark slow tests.\"\"\"\n    import time\n    time.sleep(2)\n\n\n@pytest.mark.integration\ndef test_database_integration():\n    \"\"\"Mark integration tests.\"\"\"\n    pass\n\n\n@pytest.mark.skip(reason=\"Feature not implemented yet\")\ndef test_future_feature():\n    \"\"\"Skip tests temporarily.\"\"\"\n    pass\n\n\n@pytest.mark.skipif(os.name == \"nt\", reason=\"Unix only test\")\ndef test_unix_specific():\n    \"\"\"Conditional skip.\"\"\"\n    pass\n\n\n@pytest.mark.xfail(reason=\"Known bug #123\")\ndef test_known_bug():\n    \"\"\"Mark expected failures.\"\"\"\n    assert False\n\n\n# Run with:\n# pytest -m slow          # Run only slow tests\n# pytest -m \"not slow\"    # Skip slow tests\n# pytest -m integration   # Run integration tests\n```\n\n### Coverage Reporting\n\n```bash\n# Install coverage\npip install pytest-cov\n\n# Run tests with coverage\npytest --cov=myapp tests/\n\n# Generate HTML report\npytest --cov=myapp --cov-report=html tests/\n\n# Fail if coverage below threshold\npytest --cov=myapp --cov-fail-under=80 tests/\n\n# Show missing lines\npytest --cov=myapp --cov-report=term-missing tests/\n```\n\n## Testing Database Code\n\n```python\n# test_database_models.py\nimport pytest\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nBase = declarative_base()\n\n\nclass User(Base):\n    \"\"\"User model.\"\"\"\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(50))\n    email = Column(String(100), unique=True)\n\n\n@pytest.fixture(scope=\"function\")\ndef db_session() -> Session:\n    \"\"\"Create in-memory database for testing.\"\"\"\n    engine = create_engine(\"sqlite:///:memory:\")\n    Base.metadata.create_all(engine)\n\n    SessionLocal = sessionmaker(bind=engine)\n    session = SessionLocal()\n\n    yield session\n\n    session.close()\n\n\ndef test_create_user(db_session):\n    \"\"\"Test creating a user.\"\"\"\n    user = User(name=\"Test User\", email=\"test@example.com\")\n    db_session.add(user)\n    db_session.commit()\n\n    assert user.id is not None\n    assert user.name == \"Test User\"\n\n\ndef test_query_user(db_session):\n    \"\"\"Test querying users.\"\"\"\n    user1 = User(name=\"User 1\", email=\"user1@example.com\")\n    user2 = User(name=\"User 2\", email=\"user2@example.com\")\n\n    db_session.add_all([user1, user2])\n    db_session.commit()\n\n    users = db_session.query(User).all()\n    assert len(users) == 2\n\n\ndef test_unique_email_constraint(db_session):\n    \"\"\"Test unique email constraint.\"\"\"\n    from sqlalchemy.exc import IntegrityError\n\n    user1 = User(name=\"User 1\", email=\"same@example.com\")\n    user2 = User(name=\"User 2\", email=\"same@example.com\")\n\n    db_session.add(user1)\n    db_session.commit()\n\n    db_session.add(user2)\n\n    with pytest.raises(IntegrityError):\n        db_session.commit()\n```\n\n## CI/CD Integration\n\n```yaml\n# .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        python-version: [\"3.9\", \"3.10\", \"3.11\", \"3.12\"]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install dependencies\n        run: |\n          pip install -e \".[dev]\"\n          pip install pytest pytest-cov\n\n      - name: Run tests\n        run: |\n          pytest --cov=myapp --cov-report=xml\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage.xml\n```\n\n## Configuration Files\n\n```ini\n# pytest.ini\n[pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\naddopts =\n    -v\n    --strict-markers\n    --tb=short\n    --cov=myapp\n    --cov-report=term-missing\nmarkers =\n    slow: marks tests as slow\n    integration: marks integration tests\n    unit: marks unit tests\n    e2e: marks end-to-end tests\n```\n\n```toml\n# pyproject.toml\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\naddopts = [\n    \"-v\",\n    \"--cov=myapp\",\n    \"--cov-report=term-missing\",\n]\n\n[tool.coverage.run]\nsource = [\"myapp\"]\nomit = [\"*/tests/*\", \"*/migrations/*\"]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n]\n```\n\n## Resources\n\n- **pytest documentation**: https://docs.pytest.org/\n- **unittest.mock**: https://docs.python.org/3/library/unittest.mock.html\n- **hypothesis**: Property-based testing\n- **pytest-asyncio**: Testing async code\n- **pytest-cov**: Coverage reporting\n- **pytest-mock**: pytest wrapper for mock\n\n## Best Practices Summary\n\n1. **Write tests first** (TDD) or alongside code\n2. **One assertion per test** when possible\n3. **Use descriptive test names** that explain behavior\n4. **Keep tests independent** and isolated\n5. **Use fixtures** for setup and teardown\n6. **Mock external dependencies** appropriately\n7. **Parametrize tests** to reduce duplication\n8. **Test edge cases** and error conditions\n9. **Measure coverage** but focus on quality\n10. **Run tests in CI/CD** on every commit\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "python-packaging",
      "description": "Create distributable Python packages with proper project structure, setup.py/pyproject.toml, and publishing to PyPI. Use when packaging Python libraries, creating CLI tools, or distributing Python code.",
      "plugin": "python-development",
      "source_path": "plugins/python-development/skills/python-packaging/SKILL.md",
      "category": "languages",
      "keywords": [
        "python",
        "django",
        "fastapi",
        "async",
        "backend"
      ],
      "content": "---\nname: python-packaging\ndescription: Create distributable Python packages with proper project structure, setup.py/pyproject.toml, and publishing to PyPI. Use when packaging Python libraries, creating CLI tools, or distributing Python code.\n---\n\n# Python Packaging\n\nComprehensive guide to creating, structuring, and distributing Python packages using modern packaging tools, pyproject.toml, and publishing to PyPI.\n\n## When to Use This Skill\n\n- Creating Python libraries for distribution\n- Building command-line tools with entry points\n- Publishing packages to PyPI or private repositories\n- Setting up Python project structure\n- Creating installable packages with dependencies\n- Building wheels and source distributions\n- Versioning and releasing Python packages\n- Creating namespace packages\n- Implementing package metadata and classifiers\n\n## Core Concepts\n\n### 1. Package Structure\n- **Source layout**: `src/package_name/` (recommended)\n- **Flat layout**: `package_name/` (simpler but less flexible)\n- **Package metadata**: pyproject.toml, setup.py, or setup.cfg\n- **Distribution formats**: wheel (.whl) and source distribution (.tar.gz)\n\n### 2. Modern Packaging Standards\n- **PEP 517/518**: Build system requirements\n- **PEP 621**: Metadata in pyproject.toml\n- **PEP 660**: Editable installs\n- **pyproject.toml**: Single source of configuration\n\n### 3. Build Backends\n- **setuptools**: Traditional, widely used\n- **hatchling**: Modern, opinionated\n- **flit**: Lightweight, for pure Python\n- **poetry**: Dependency management + packaging\n\n### 4. Distribution\n- **PyPI**: Python Package Index (public)\n- **TestPyPI**: Testing before production\n- **Private repositories**: JFrog, AWS CodeArtifact, etc.\n\n## Quick Start\n\n### Minimal Package Structure\n\n```\nmy-package/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 my_package/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 module.py\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 test_module.py\n```\n\n### Minimal pyproject.toml\n\n```toml\n[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"my-package\"\nversion = \"0.1.0\"\ndescription = \"A short description\"\nauthors = [{name = \"Your Name\", email = \"you@example.com\"}]\nreadme = \"README.md\"\nrequires-python = \">=3.8\"\ndependencies = [\n    \"requests>=2.28.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest>=7.0\",\n    \"black>=22.0\",\n]\n```\n\n## Package Structure Patterns\n\n### Pattern 1: Source Layout (Recommended)\n\n```\nmy-package/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 my_package/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 core.py\n\u2502       \u251c\u2500\u2500 utils.py\n\u2502       \u2514\u2500\u2500 py.typed          # For type hints\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 test_core.py\n\u2502   \u2514\u2500\u2500 test_utils.py\n\u2514\u2500\u2500 docs/\n    \u2514\u2500\u2500 index.md\n```\n\n**Advantages:**\n- Prevents accidentally importing from source\n- Cleaner test imports\n- Better isolation\n\n**pyproject.toml for source layout:**\n```toml\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n```\n\n### Pattern 2: Flat Layout\n\n```\nmy-package/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 my_package/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 module.py\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 test_module.py\n```\n\n**Simpler but:**\n- Can import package without installing\n- Less professional for libraries\n\n### Pattern 3: Multi-Package Project\n\n```\nproject/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 package-a/\n\u2502   \u2502   \u2514\u2500\u2500 src/\n\u2502   \u2502       \u2514\u2500\u2500 package_a/\n\u2502   \u2514\u2500\u2500 package-b/\n\u2502       \u2514\u2500\u2500 src/\n\u2502           \u2514\u2500\u2500 package_b/\n\u2514\u2500\u2500 tests/\n```\n\n## Complete pyproject.toml Examples\n\n### Pattern 4: Full-Featured pyproject.toml\n\n```toml\n[build-system]\nrequires = [\"setuptools>=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"my-awesome-package\"\nversion = \"1.0.0\"\ndescription = \"An awesome Python package\"\nreadme = \"README.md\"\nrequires-python = \">=3.8\"\nlicense = {text = \"MIT\"}\nauthors = [\n    {name = \"Your Name\", email = \"you@example.com\"},\n]\nmaintainers = [\n    {name = \"Maintainer Name\", email = \"maintainer@example.com\"},\n]\nkeywords = [\"example\", \"package\", \"awesome\"]\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n]\n\ndependencies = [\n    \"requests>=2.28.0,<3.0.0\",\n    \"click>=8.0.0\",\n    \"pydantic>=2.0.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest>=7.0.0\",\n    \"pytest-cov>=4.0.0\",\n    \"black>=23.0.0\",\n    \"ruff>=0.1.0\",\n    \"mypy>=1.0.0\",\n]\ndocs = [\n    \"sphinx>=5.0.0\",\n    \"sphinx-rtd-theme>=1.0.0\",\n]\nall = [\n    \"my-awesome-package[dev,docs]\",\n]\n\n[project.urls]\nHomepage = \"https://github.com/username/my-awesome-package\"\nDocumentation = \"https://my-awesome-package.readthedocs.io\"\nRepository = \"https://github.com/username/my-awesome-package\"\n\"Bug Tracker\" = \"https://github.com/username/my-awesome-package/issues\"\nChangelog = \"https://github.com/username/my-awesome-package/blob/main/CHANGELOG.md\"\n\n[project.scripts]\nmy-cli = \"my_package.cli:main\"\nawesome-tool = \"my_package.tools:run\"\n\n[project.entry-points.\"my_package.plugins\"]\nplugin1 = \"my_package.plugins:plugin1\"\n\n[tool.setuptools]\npackage-dir = {\"\" = \"src\"}\nzip-safe = false\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\ninclude = [\"my_package*\"]\nexclude = [\"tests*\"]\n\n[tool.setuptools.package-data]\nmy_package = [\"py.typed\", \"*.pyi\", \"data/*.json\"]\n\n# Black configuration\n[tool.black]\nline-length = 100\ntarget-version = [\"py38\", \"py39\", \"py310\", \"py311\"]\ninclude = '\\.pyi?$'\n\n# Ruff configuration\n[tool.ruff]\nline-length = 100\ntarget-version = \"py38\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"I\", \"N\", \"W\", \"UP\"]\n\n# MyPy configuration\n[tool.mypy]\npython_version = \"3.8\"\nwarn_return_any = true\nwarn_unused_configs = true\ndisallow_untyped_defs = true\n\n# Pytest configuration\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\"]\naddopts = \"-v --cov=my_package --cov-report=term-missing\"\n\n# Coverage configuration\n[tool.coverage.run]\nsource = [\"src\"]\nomit = [\"*/tests/*\"]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise AssertionError\",\n    \"raise NotImplementedError\",\n]\n```\n\n### Pattern 5: Dynamic Versioning\n\n```toml\n[build-system]\nrequires = [\"setuptools>=61.0\", \"setuptools-scm>=8.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"my-package\"\ndynamic = [\"version\"]\ndescription = \"Package with dynamic version\"\n\n[tool.setuptools.dynamic]\nversion = {attr = \"my_package.__version__\"}\n\n# Or use setuptools-scm for git-based versioning\n[tool.setuptools_scm]\nwrite_to = \"src/my_package/_version.py\"\n```\n\n**In __init__.py:**\n```python\n# src/my_package/__init__.py\n__version__ = \"1.0.0\"\n\n# Or with setuptools-scm\nfrom importlib.metadata import version\n__version__ = version(\"my-package\")\n```\n\n## Command-Line Interface (CLI) Patterns\n\n### Pattern 6: CLI with Click\n\n```python\n# src/my_package/cli.py\nimport click\n\n@click.group()\n@click.version_option()\ndef cli():\n    \"\"\"My awesome CLI tool.\"\"\"\n    pass\n\n@cli.command()\n@click.argument(\"name\")\n@click.option(\"--greeting\", default=\"Hello\", help=\"Greeting to use\")\ndef greet(name: str, greeting: str):\n    \"\"\"Greet someone.\"\"\"\n    click.echo(f\"{greeting}, {name}!\")\n\n@cli.command()\n@click.option(\"--count\", default=1, help=\"Number of times to repeat\")\ndef repeat(count: int):\n    \"\"\"Repeat a message.\"\"\"\n    for i in range(count):\n        click.echo(f\"Message {i + 1}\")\n\ndef main():\n    \"\"\"Entry point for CLI.\"\"\"\n    cli()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Register in pyproject.toml:**\n```toml\n[project.scripts]\nmy-tool = \"my_package.cli:main\"\n```\n\n**Usage:**\n```bash\npip install -e .\nmy-tool greet World\nmy-tool greet Alice --greeting=\"Hi\"\nmy-tool repeat --count=3\n```\n\n### Pattern 7: CLI with argparse\n\n```python\n# src/my_package/cli.py\nimport argparse\nimport sys\n\ndef main():\n    \"\"\"Main CLI entry point.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"My awesome tool\",\n        prog=\"my-tool\"\n    )\n\n    parser.add_argument(\n        \"--version\",\n        action=\"version\",\n        version=\"%(prog)s 1.0.0\"\n    )\n\n    subparsers = parser.add_subparsers(dest=\"command\", help=\"Commands\")\n\n    # Add subcommand\n    process_parser = subparsers.add_parser(\"process\", help=\"Process data\")\n    process_parser.add_argument(\"input_file\", help=\"Input file path\")\n    process_parser.add_argument(\n        \"--output\", \"-o\",\n        default=\"output.txt\",\n        help=\"Output file path\"\n    )\n\n    args = parser.parse_args()\n\n    if args.command == \"process\":\n        process_data(args.input_file, args.output)\n    else:\n        parser.print_help()\n        sys.exit(1)\n\ndef process_data(input_file: str, output_file: str):\n    \"\"\"Process data from input to output.\"\"\"\n    print(f\"Processing {input_file} -> {output_file}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Building and Publishing\n\n### Pattern 8: Build Package Locally\n\n```bash\n# Install build tools\npip install build twine\n\n# Build distribution\npython -m build\n\n# This creates:\n# dist/\n#   my-package-1.0.0.tar.gz (source distribution)\n#   my_package-1.0.0-py3-none-any.whl (wheel)\n\n# Check the distribution\ntwine check dist/*\n```\n\n### Pattern 9: Publishing to PyPI\n\n```bash\n# Install publishing tools\npip install twine\n\n# Test on TestPyPI first\ntwine upload --repository testpypi dist/*\n\n# Install from TestPyPI to test\npip install --index-url https://test.pypi.org/simple/ my-package\n\n# If all good, publish to PyPI\ntwine upload dist/*\n```\n\n**Using API tokens (recommended):**\n```bash\n# Create ~/.pypirc\n[distutils]\nindex-servers =\n    pypi\n    testpypi\n\n[pypi]\nusername = __token__\npassword = pypi-...your-token...\n\n[testpypi]\nusername = __token__\npassword = pypi-...your-test-token...\n```\n\n### Pattern 10: Automated Publishing with GitHub Actions\n\n```yaml\n# .github/workflows/publish.yml\nname: Publish to PyPI\n\non:\n  release:\n    types: [created]\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.11\"\n\n      - name: Install dependencies\n        run: |\n          pip install build twine\n\n      - name: Build package\n        run: python -m build\n\n      - name: Check package\n        run: twine check dist/*\n\n      - name: Publish to PyPI\n        env:\n          TWINE_USERNAME: __token__\n          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}\n        run: twine upload dist/*\n```\n\n## Advanced Patterns\n\n### Pattern 11: Including Data Files\n\n```toml\n[tool.setuptools.package-data]\nmy_package = [\n    \"data/*.json\",\n    \"templates/*.html\",\n    \"static/css/*.css\",\n    \"py.typed\",\n]\n```\n\n**Accessing data files:**\n```python\n# src/my_package/loader.py\nfrom importlib.resources import files\nimport json\n\ndef load_config():\n    \"\"\"Load configuration from package data.\"\"\"\n    config_file = files(\"my_package\").joinpath(\"data/config.json\")\n    with config_file.open() as f:\n        return json.load(f)\n\n# Python 3.9+\nfrom importlib.resources import files\n\ndata = files(\"my_package\").joinpath(\"data/file.txt\").read_text()\n```\n\n### Pattern 12: Namespace Packages\n\n**For large projects split across multiple repositories:**\n\n```\n# Package 1: company-core\ncompany/\n\u2514\u2500\u2500 core/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 models.py\n\n# Package 2: company-api\ncompany/\n\u2514\u2500\u2500 api/\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 routes.py\n```\n\n**Do NOT include __init__.py in the namespace directory (company/):**\n\n```toml\n# company-core/pyproject.toml\n[project]\nname = \"company-core\"\n\n[tool.setuptools.packages.find]\nwhere = [\".\"]\ninclude = [\"company.core*\"]\n\n# company-api/pyproject.toml\n[project]\nname = \"company-api\"\n\n[tool.setuptools.packages.find]\nwhere = [\".\"]\ninclude = [\"company.api*\"]\n```\n\n**Usage:**\n```python\n# Both packages can be imported under same namespace\nfrom company.core import models\nfrom company.api import routes\n```\n\n### Pattern 13: C Extensions\n\n```toml\n[build-system]\nrequires = [\"setuptools>=61.0\", \"wheel\", \"Cython>=0.29\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools]\next-modules = [\n    {name = \"my_package.fast_module\", sources = [\"src/fast_module.c\"]},\n]\n```\n\n**Or with setup.py:**\n```python\n# setup.py\nfrom setuptools import setup, Extension\n\nsetup(\n    ext_modules=[\n        Extension(\n            \"my_package.fast_module\",\n            sources=[\"src/fast_module.c\"],\n            include_dirs=[\"src/include\"],\n        )\n    ]\n)\n```\n\n## Version Management\n\n### Pattern 14: Semantic Versioning\n\n```python\n# src/my_package/__init__.py\n__version__ = \"1.2.3\"\n\n# Semantic versioning: MAJOR.MINOR.PATCH\n# MAJOR: Breaking changes\n# MINOR: New features (backward compatible)\n# PATCH: Bug fixes\n```\n\n**Version constraints in dependencies:**\n```toml\ndependencies = [\n    \"requests>=2.28.0,<3.0.0\",  # Compatible range\n    \"click~=8.1.0\",              # Compatible release (~= 8.1.0 means >=8.1.0,<8.2.0)\n    \"pydantic>=2.0\",             # Minimum version\n    \"numpy==1.24.3\",             # Exact version (avoid if possible)\n]\n```\n\n### Pattern 15: Git-Based Versioning\n\n```toml\n[build-system]\nrequires = [\"setuptools>=61.0\", \"setuptools-scm>=8.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"my-package\"\ndynamic = [\"version\"]\n\n[tool.setuptools_scm]\nwrite_to = \"src/my_package/_version.py\"\nversion_scheme = \"post-release\"\nlocal_scheme = \"dirty-tag\"\n```\n\n**Creates versions like:**\n- `1.0.0` (from git tag)\n- `1.0.1.dev3+g1234567` (3 commits after tag)\n\n## Testing Installation\n\n### Pattern 16: Editable Install\n\n```bash\n# Install in development mode\npip install -e .\n\n# With optional dependencies\npip install -e \".[dev]\"\npip install -e \".[dev,docs]\"\n\n# Now changes to source code are immediately reflected\n```\n\n### Pattern 17: Testing in Isolated Environment\n\n```bash\n# Create virtual environment\npython -m venv test-env\nsource test-env/bin/activate  # Linux/Mac\n# test-env\\Scripts\\activate  # Windows\n\n# Install package\npip install dist/my_package-1.0.0-py3-none-any.whl\n\n# Test it works\npython -c \"import my_package; print(my_package.__version__)\"\n\n# Test CLI\nmy-tool --help\n\n# Cleanup\ndeactivate\nrm -rf test-env\n```\n\n## Documentation\n\n### Pattern 18: README.md Template\n\n```markdown\n# My Package\n\n[![PyPI version](https://badge.fury.io/py/my-package.svg)](https://pypi.org/project/my-package/)\n[![Python versions](https://img.shields.io/pypi/pyversions/my-package.svg)](https://pypi.org/project/my-package/)\n[![Tests](https://github.com/username/my-package/workflows/Tests/badge.svg)](https://github.com/username/my-package/actions)\n\nBrief description of your package.\n\n## Installation\n\n```bash\npip install my-package\n```\n\n## Quick Start\n\n```python\nfrom my_package import something\n\nresult = something.do_stuff()\n```\n\n## Features\n\n- Feature 1\n- Feature 2\n- Feature 3\n\n## Documentation\n\nFull documentation: https://my-package.readthedocs.io\n\n## Development\n\n```bash\ngit clone https://github.com/username/my-package.git\ncd my-package\npip install -e \".[dev]\"\npytest\n```\n\n## License\n\nMIT\n```\n\n## Common Patterns\n\n### Pattern 19: Multi-Architecture Wheels\n\n```yaml\n# .github/workflows/wheels.yml\nname: Build wheels\n\non: [push, pull_request]\n\njobs:\n  build_wheels:\n    name: Build wheels on ${{ matrix.os }}\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Build wheels\n        uses: pypa/cibuildwheel@v2.16.2\n\n      - uses: actions/upload-artifact@v3\n        with:\n          path: ./wheelhouse/*.whl\n```\n\n### Pattern 20: Private Package Index\n\n```bash\n# Install from private index\npip install my-package --index-url https://private.pypi.org/simple/\n\n# Or add to pip.conf\n[global]\nindex-url = https://private.pypi.org/simple/\nextra-index-url = https://pypi.org/simple/\n\n# Upload to private index\ntwine upload --repository-url https://private.pypi.org/ dist/*\n```\n\n## File Templates\n\n### .gitignore for Python Packages\n\n```gitignore\n# Build artifacts\nbuild/\ndist/\n*.egg-info/\n*.egg\n.eggs/\n\n# Python\n__pycache__/\n*.py[cod]\n*$py.class\n*.so\n\n# Virtual environments\nvenv/\nenv/\nENV/\n\n# IDE\n.vscode/\n.idea/\n*.swp\n\n# Testing\n.pytest_cache/\n.coverage\nhtmlcov/\n\n# Distribution\n*.whl\n*.tar.gz\n```\n\n### MANIFEST.in\n\n```\n# MANIFEST.in\ninclude README.md\ninclude LICENSE\ninclude pyproject.toml\n\nrecursive-include src/my_package/data *.json\nrecursive-include src/my_package/templates *.html\nrecursive-exclude * __pycache__\nrecursive-exclude * *.py[co]\n```\n\n## Checklist for Publishing\n\n- [ ] Code is tested (pytest passing)\n- [ ] Documentation is complete (README, docstrings)\n- [ ] Version number updated\n- [ ] CHANGELOG.md updated\n- [ ] License file included\n- [ ] pyproject.toml is complete\n- [ ] Package builds without errors\n- [ ] Installation tested in clean environment\n- [ ] CLI tools work (if applicable)\n- [ ] PyPI metadata is correct (classifiers, keywords)\n- [ ] GitHub repository linked\n- [ ] Tested on TestPyPI first\n- [ ] Git tag created for release\n\n## Resources\n\n- **Python Packaging Guide**: https://packaging.python.org/\n- **PyPI**: https://pypi.org/\n- **TestPyPI**: https://test.pypi.org/\n- **setuptools documentation**: https://setuptools.pypa.io/\n- **build**: https://pypa-build.readthedocs.io/\n- **twine**: https://twine.readthedocs.io/\n\n## Best Practices Summary\n\n1. **Use src/ layout** for cleaner package structure\n2. **Use pyproject.toml** for modern packaging\n3. **Pin build dependencies** in build-system.requires\n4. **Version appropriately** with semantic versioning\n5. **Include all metadata** (classifiers, URLs, etc.)\n6. **Test installation** in clean environments\n7. **Use TestPyPI** before publishing to PyPI\n8. **Document thoroughly** with README and docstrings\n9. **Include LICENSE** file\n10. **Automate publishing** with CI/CD\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "python-performance-optimization",
      "description": "Profile and optimize Python code using cProfile, memory profilers, and performance best practices. Use when debugging slow Python code, optimizing bottlenecks, or improving application performance.",
      "plugin": "python-development",
      "source_path": "plugins/python-development/skills/python-performance-optimization/SKILL.md",
      "category": "languages",
      "keywords": [
        "python",
        "django",
        "fastapi",
        "async",
        "backend"
      ],
      "content": "---\nname: python-performance-optimization\ndescription: Profile and optimize Python code using cProfile, memory profilers, and performance best practices. Use when debugging slow Python code, optimizing bottlenecks, or improving application performance.\n---\n\n# Python Performance Optimization\n\nComprehensive guide to profiling, analyzing, and optimizing Python code for better performance, including CPU profiling, memory optimization, and implementation best practices.\n\n## When to Use This Skill\n\n- Identifying performance bottlenecks in Python applications\n- Reducing application latency and response times\n- Optimizing CPU-intensive operations\n- Reducing memory consumption and memory leaks\n- Improving database query performance\n- Optimizing I/O operations\n- Speeding up data processing pipelines\n- Implementing high-performance algorithms\n- Profiling production applications\n\n## Core Concepts\n\n### 1. Profiling Types\n- **CPU Profiling**: Identify time-consuming functions\n- **Memory Profiling**: Track memory allocation and leaks\n- **Line Profiling**: Profile at line-by-line granularity\n- **Call Graph**: Visualize function call relationships\n\n### 2. Performance Metrics\n- **Execution Time**: How long operations take\n- **Memory Usage**: Peak and average memory consumption\n- **CPU Utilization**: Processor usage patterns\n- **I/O Wait**: Time spent on I/O operations\n\n### 3. Optimization Strategies\n- **Algorithmic**: Better algorithms and data structures\n- **Implementation**: More efficient code patterns\n- **Parallelization**: Multi-threading/processing\n- **Caching**: Avoid redundant computation\n- **Native Extensions**: C/Rust for critical paths\n\n## Quick Start\n\n### Basic Timing\n\n```python\nimport time\n\ndef measure_time():\n    \"\"\"Simple timing measurement.\"\"\"\n    start = time.time()\n\n    # Your code here\n    result = sum(range(1000000))\n\n    elapsed = time.time() - start\n    print(f\"Execution time: {elapsed:.4f} seconds\")\n    return result\n\n# Better: use timeit for accurate measurements\nimport timeit\n\nexecution_time = timeit.timeit(\n    \"sum(range(1000000))\",\n    number=100\n)\nprint(f\"Average time: {execution_time/100:.6f} seconds\")\n```\n\n## Profiling Tools\n\n### Pattern 1: cProfile - CPU Profiling\n\n```python\nimport cProfile\nimport pstats\nfrom pstats import SortKey\n\ndef slow_function():\n    \"\"\"Function to profile.\"\"\"\n    total = 0\n    for i in range(1000000):\n        total += i\n    return total\n\ndef another_function():\n    \"\"\"Another function.\"\"\"\n    return [i**2 for i in range(100000)]\n\ndef main():\n    \"\"\"Main function to profile.\"\"\"\n    result1 = slow_function()\n    result2 = another_function()\n    return result1, result2\n\n# Profile the code\nif __name__ == \"__main__\":\n    profiler = cProfile.Profile()\n    profiler.enable()\n\n    main()\n\n    profiler.disable()\n\n    # Print stats\n    stats = pstats.Stats(profiler)\n    stats.sort_stats(SortKey.CUMULATIVE)\n    stats.print_stats(10)  # Top 10 functions\n\n    # Save to file for later analysis\n    stats.dump_stats(\"profile_output.prof\")\n```\n\n**Command-line profiling:**\n```bash\n# Profile a script\npython -m cProfile -o output.prof script.py\n\n# View results\npython -m pstats output.prof\n# In pstats:\n# sort cumtime\n# stats 10\n```\n\n### Pattern 2: line_profiler - Line-by-Line Profiling\n\n```python\n# Install: pip install line-profiler\n\n# Add @profile decorator (line_profiler provides this)\n@profile\ndef process_data(data):\n    \"\"\"Process data with line profiling.\"\"\"\n    result = []\n    for item in data:\n        processed = item * 2\n        result.append(processed)\n    return result\n\n# Run with:\n# kernprof -l -v script.py\n```\n\n**Manual line profiling:**\n```python\nfrom line_profiler import LineProfiler\n\ndef process_data(data):\n    \"\"\"Function to profile.\"\"\"\n    result = []\n    for item in data:\n        processed = item * 2\n        result.append(processed)\n    return result\n\nif __name__ == \"__main__\":\n    lp = LineProfiler()\n    lp.add_function(process_data)\n\n    data = list(range(100000))\n\n    lp_wrapper = lp(process_data)\n    lp_wrapper(data)\n\n    lp.print_stats()\n```\n\n### Pattern 3: memory_profiler - Memory Usage\n\n```python\n# Install: pip install memory-profiler\n\nfrom memory_profiler import profile\n\n@profile\ndef memory_intensive():\n    \"\"\"Function that uses lots of memory.\"\"\"\n    # Create large list\n    big_list = [i for i in range(1000000)]\n\n    # Create large dict\n    big_dict = {i: i**2 for i in range(100000)}\n\n    # Process data\n    result = sum(big_list)\n\n    return result\n\nif __name__ == \"__main__\":\n    memory_intensive()\n\n# Run with:\n# python -m memory_profiler script.py\n```\n\n### Pattern 4: py-spy - Production Profiling\n\n```bash\n# Install: pip install py-spy\n\n# Profile a running Python process\npy-spy top --pid 12345\n\n# Generate flamegraph\npy-spy record -o profile.svg --pid 12345\n\n# Profile a script\npy-spy record -o profile.svg -- python script.py\n\n# Dump current call stack\npy-spy dump --pid 12345\n```\n\n## Optimization Patterns\n\n### Pattern 5: List Comprehensions vs Loops\n\n```python\nimport timeit\n\n# Slow: Traditional loop\ndef slow_squares(n):\n    \"\"\"Create list of squares using loop.\"\"\"\n    result = []\n    for i in range(n):\n        result.append(i**2)\n    return result\n\n# Fast: List comprehension\ndef fast_squares(n):\n    \"\"\"Create list of squares using comprehension.\"\"\"\n    return [i**2 for i in range(n)]\n\n# Benchmark\nn = 100000\n\nslow_time = timeit.timeit(lambda: slow_squares(n), number=100)\nfast_time = timeit.timeit(lambda: fast_squares(n), number=100)\n\nprint(f\"Loop: {slow_time:.4f}s\")\nprint(f\"Comprehension: {fast_time:.4f}s\")\nprint(f\"Speedup: {slow_time/fast_time:.2f}x\")\n\n# Even faster for simple operations: map\ndef faster_squares(n):\n    \"\"\"Use map for even better performance.\"\"\"\n    return list(map(lambda x: x**2, range(n)))\n```\n\n### Pattern 6: Generator Expressions for Memory\n\n```python\nimport sys\n\ndef list_approach():\n    \"\"\"Memory-intensive list.\"\"\"\n    data = [i**2 for i in range(1000000)]\n    return sum(data)\n\ndef generator_approach():\n    \"\"\"Memory-efficient generator.\"\"\"\n    data = (i**2 for i in range(1000000))\n    return sum(data)\n\n# Memory comparison\nlist_data = [i for i in range(1000000)]\ngen_data = (i for i in range(1000000))\n\nprint(f\"List size: {sys.getsizeof(list_data)} bytes\")\nprint(f\"Generator size: {sys.getsizeof(gen_data)} bytes\")\n\n# Generators use constant memory regardless of size\n```\n\n### Pattern 7: String Concatenation\n\n```python\nimport timeit\n\ndef slow_concat(items):\n    \"\"\"Slow string concatenation.\"\"\"\n    result = \"\"\n    for item in items:\n        result += str(item)\n    return result\n\ndef fast_concat(items):\n    \"\"\"Fast string concatenation with join.\"\"\"\n    return \"\".join(str(item) for item in items)\n\ndef faster_concat(items):\n    \"\"\"Even faster with list.\"\"\"\n    parts = [str(item) for item in items]\n    return \"\".join(parts)\n\nitems = list(range(10000))\n\n# Benchmark\nslow = timeit.timeit(lambda: slow_concat(items), number=100)\nfast = timeit.timeit(lambda: fast_concat(items), number=100)\nfaster = timeit.timeit(lambda: faster_concat(items), number=100)\n\nprint(f\"Concatenation (+): {slow:.4f}s\")\nprint(f\"Join (generator): {fast:.4f}s\")\nprint(f\"Join (list): {faster:.4f}s\")\n```\n\n### Pattern 8: Dictionary Lookups vs List Searches\n\n```python\nimport timeit\n\n# Create test data\nsize = 10000\nitems = list(range(size))\nlookup_dict = {i: i for i in range(size)}\n\ndef list_search(items, target):\n    \"\"\"O(n) search in list.\"\"\"\n    return target in items\n\ndef dict_search(lookup_dict, target):\n    \"\"\"O(1) search in dict.\"\"\"\n    return target in lookup_dict\n\ntarget = size - 1  # Worst case for list\n\n# Benchmark\nlist_time = timeit.timeit(\n    lambda: list_search(items, target),\n    number=1000\n)\ndict_time = timeit.timeit(\n    lambda: dict_search(lookup_dict, target),\n    number=1000\n)\n\nprint(f\"List search: {list_time:.6f}s\")\nprint(f\"Dict search: {dict_time:.6f}s\")\nprint(f\"Speedup: {list_time/dict_time:.0f}x\")\n```\n\n### Pattern 9: Local Variable Access\n\n```python\nimport timeit\n\n# Global variable (slow)\nGLOBAL_VALUE = 100\n\ndef use_global():\n    \"\"\"Access global variable.\"\"\"\n    total = 0\n    for i in range(10000):\n        total += GLOBAL_VALUE\n    return total\n\ndef use_local():\n    \"\"\"Use local variable.\"\"\"\n    local_value = 100\n    total = 0\n    for i in range(10000):\n        total += local_value\n    return total\n\n# Local is faster\nglobal_time = timeit.timeit(use_global, number=1000)\nlocal_time = timeit.timeit(use_local, number=1000)\n\nprint(f\"Global access: {global_time:.4f}s\")\nprint(f\"Local access: {local_time:.4f}s\")\nprint(f\"Speedup: {global_time/local_time:.2f}x\")\n```\n\n### Pattern 10: Function Call Overhead\n\n```python\nimport timeit\n\ndef calculate_inline():\n    \"\"\"Inline calculation.\"\"\"\n    total = 0\n    for i in range(10000):\n        total += i * 2 + 1\n    return total\n\ndef helper_function(x):\n    \"\"\"Helper function.\"\"\"\n    return x * 2 + 1\n\ndef calculate_with_function():\n    \"\"\"Calculation with function calls.\"\"\"\n    total = 0\n    for i in range(10000):\n        total += helper_function(i)\n    return total\n\n# Inline is faster due to no call overhead\ninline_time = timeit.timeit(calculate_inline, number=1000)\nfunction_time = timeit.timeit(calculate_with_function, number=1000)\n\nprint(f\"Inline: {inline_time:.4f}s\")\nprint(f\"Function calls: {function_time:.4f}s\")\n```\n\n## Advanced Optimization\n\n### Pattern 11: NumPy for Numerical Operations\n\n```python\nimport timeit\nimport numpy as np\n\ndef python_sum(n):\n    \"\"\"Sum using pure Python.\"\"\"\n    return sum(range(n))\n\ndef numpy_sum(n):\n    \"\"\"Sum using NumPy.\"\"\"\n    return np.arange(n).sum()\n\nn = 1000000\n\npython_time = timeit.timeit(lambda: python_sum(n), number=100)\nnumpy_time = timeit.timeit(lambda: numpy_sum(n), number=100)\n\nprint(f\"Python: {python_time:.4f}s\")\nprint(f\"NumPy: {numpy_time:.4f}s\")\nprint(f\"Speedup: {python_time/numpy_time:.2f}x\")\n\n# Vectorized operations\ndef python_multiply():\n    \"\"\"Element-wise multiplication in Python.\"\"\"\n    a = list(range(100000))\n    b = list(range(100000))\n    return [x * y for x, y in zip(a, b)]\n\ndef numpy_multiply():\n    \"\"\"Vectorized multiplication in NumPy.\"\"\"\n    a = np.arange(100000)\n    b = np.arange(100000)\n    return a * b\n\npy_time = timeit.timeit(python_multiply, number=100)\nnp_time = timeit.timeit(numpy_multiply, number=100)\n\nprint(f\"\\nPython multiply: {py_time:.4f}s\")\nprint(f\"NumPy multiply: {np_time:.4f}s\")\nprint(f\"Speedup: {py_time/np_time:.2f}x\")\n```\n\n### Pattern 12: Caching with functools.lru_cache\n\n```python\nfrom functools import lru_cache\nimport timeit\n\ndef fibonacci_slow(n):\n    \"\"\"Recursive fibonacci without caching.\"\"\"\n    if n < 2:\n        return n\n    return fibonacci_slow(n-1) + fibonacci_slow(n-2)\n\n@lru_cache(maxsize=None)\ndef fibonacci_fast(n):\n    \"\"\"Recursive fibonacci with caching.\"\"\"\n    if n < 2:\n        return n\n    return fibonacci_fast(n-1) + fibonacci_fast(n-2)\n\n# Massive speedup for recursive algorithms\nn = 30\n\nslow_time = timeit.timeit(lambda: fibonacci_slow(n), number=1)\nfast_time = timeit.timeit(lambda: fibonacci_fast(n), number=1000)\n\nprint(f\"Without cache (1 run): {slow_time:.4f}s\")\nprint(f\"With cache (1000 runs): {fast_time:.4f}s\")\n\n# Cache info\nprint(f\"Cache info: {fibonacci_fast.cache_info()}\")\n```\n\n### Pattern 13: Using __slots__ for Memory\n\n```python\nimport sys\n\nclass RegularClass:\n    \"\"\"Regular class with __dict__.\"\"\"\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\nclass SlottedClass:\n    \"\"\"Class with __slots__ for memory efficiency.\"\"\"\n    __slots__ = ['x', 'y', 'z']\n\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n# Memory comparison\nregular = RegularClass(1, 2, 3)\nslotted = SlottedClass(1, 2, 3)\n\nprint(f\"Regular class size: {sys.getsizeof(regular)} bytes\")\nprint(f\"Slotted class size: {sys.getsizeof(slotted)} bytes\")\n\n# Significant savings with many instances\nregular_objects = [RegularClass(i, i+1, i+2) for i in range(10000)]\nslotted_objects = [SlottedClass(i, i+1, i+2) for i in range(10000)]\n\nprint(f\"\\nMemory for 10000 regular objects: ~{sys.getsizeof(regular) * 10000} bytes\")\nprint(f\"Memory for 10000 slotted objects: ~{sys.getsizeof(slotted) * 10000} bytes\")\n```\n\n### Pattern 14: Multiprocessing for CPU-Bound Tasks\n\n```python\nimport multiprocessing as mp\nimport time\n\ndef cpu_intensive_task(n):\n    \"\"\"CPU-intensive calculation.\"\"\"\n    return sum(i**2 for i in range(n))\n\ndef sequential_processing():\n    \"\"\"Process tasks sequentially.\"\"\"\n    start = time.time()\n    results = [cpu_intensive_task(1000000) for _ in range(4)]\n    elapsed = time.time() - start\n    return elapsed, results\n\ndef parallel_processing():\n    \"\"\"Process tasks in parallel.\"\"\"\n    start = time.time()\n    with mp.Pool(processes=4) as pool:\n        results = pool.map(cpu_intensive_task, [1000000] * 4)\n    elapsed = time.time() - start\n    return elapsed, results\n\nif __name__ == \"__main__\":\n    seq_time, seq_results = sequential_processing()\n    par_time, par_results = parallel_processing()\n\n    print(f\"Sequential: {seq_time:.2f}s\")\n    print(f\"Parallel: {par_time:.2f}s\")\n    print(f\"Speedup: {seq_time/par_time:.2f}x\")\n```\n\n### Pattern 15: Async I/O for I/O-Bound Tasks\n\n```python\nimport asyncio\nimport aiohttp\nimport time\nimport requests\n\nurls = [\n    \"https://httpbin.org/delay/1\",\n    \"https://httpbin.org/delay/1\",\n    \"https://httpbin.org/delay/1\",\n    \"https://httpbin.org/delay/1\",\n]\n\ndef synchronous_requests():\n    \"\"\"Synchronous HTTP requests.\"\"\"\n    start = time.time()\n    results = []\n    for url in urls:\n        response = requests.get(url)\n        results.append(response.status_code)\n    elapsed = time.time() - start\n    return elapsed, results\n\nasync def async_fetch(session, url):\n    \"\"\"Async HTTP request.\"\"\"\n    async with session.get(url) as response:\n        return response.status\n\nasync def asynchronous_requests():\n    \"\"\"Asynchronous HTTP requests.\"\"\"\n    start = time.time()\n    async with aiohttp.ClientSession() as session:\n        tasks = [async_fetch(session, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n    elapsed = time.time() - start\n    return elapsed, results\n\n# Async is much faster for I/O-bound work\nsync_time, sync_results = synchronous_requests()\nasync_time, async_results = asyncio.run(asynchronous_requests())\n\nprint(f\"Synchronous: {sync_time:.2f}s\")\nprint(f\"Asynchronous: {async_time:.2f}s\")\nprint(f\"Speedup: {sync_time/async_time:.2f}x\")\n```\n\n## Database Optimization\n\n### Pattern 16: Batch Database Operations\n\n```python\nimport sqlite3\nimport time\n\ndef create_db():\n    \"\"\"Create test database.\"\"\"\n    conn = sqlite3.connect(\":memory:\")\n    conn.execute(\"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)\")\n    return conn\n\ndef slow_inserts(conn, count):\n    \"\"\"Insert records one at a time.\"\"\"\n    start = time.time()\n    cursor = conn.cursor()\n    for i in range(count):\n        cursor.execute(\"INSERT INTO users (name) VALUES (?)\", (f\"User {i}\",))\n        conn.commit()  # Commit each insert\n    elapsed = time.time() - start\n    return elapsed\n\ndef fast_inserts(conn, count):\n    \"\"\"Batch insert with single commit.\"\"\"\n    start = time.time()\n    cursor = conn.cursor()\n    data = [(f\"User {i}\",) for i in range(count)]\n    cursor.executemany(\"INSERT INTO users (name) VALUES (?)\", data)\n    conn.commit()  # Single commit\n    elapsed = time.time() - start\n    return elapsed\n\n# Benchmark\nconn1 = create_db()\nslow_time = slow_inserts(conn1, 1000)\n\nconn2 = create_db()\nfast_time = fast_inserts(conn2, 1000)\n\nprint(f\"Individual inserts: {slow_time:.4f}s\")\nprint(f\"Batch insert: {fast_time:.4f}s\")\nprint(f\"Speedup: {slow_time/fast_time:.2f}x\")\n```\n\n### Pattern 17: Query Optimization\n\n```python\n# Use indexes for frequently queried columns\n\"\"\"\n-- Slow: No index\nSELECT * FROM users WHERE email = 'user@example.com';\n\n-- Fast: With index\nCREATE INDEX idx_users_email ON users(email);\nSELECT * FROM users WHERE email = 'user@example.com';\n\"\"\"\n\n# Use query planning\nimport sqlite3\n\nconn = sqlite3.connect(\"example.db\")\ncursor = conn.cursor()\n\n# Analyze query performance\ncursor.execute(\"EXPLAIN QUERY PLAN SELECT * FROM users WHERE email = ?\", (\"test@example.com\",))\nprint(cursor.fetchall())\n\n# Use SELECT only needed columns\n# Slow: SELECT *\n# Fast: SELECT id, name\n```\n\n## Memory Optimization\n\n### Pattern 18: Detecting Memory Leaks\n\n```python\nimport tracemalloc\nimport gc\n\ndef memory_leak_example():\n    \"\"\"Example that leaks memory.\"\"\"\n    leaked_objects = []\n\n    for i in range(100000):\n        # Objects added but never removed\n        leaked_objects.append([i] * 100)\n\n    # In real code, this would be an unintended reference\n\ndef track_memory_usage():\n    \"\"\"Track memory allocations.\"\"\"\n    tracemalloc.start()\n\n    # Take snapshot before\n    snapshot1 = tracemalloc.take_snapshot()\n\n    # Run code\n    memory_leak_example()\n\n    # Take snapshot after\n    snapshot2 = tracemalloc.take_snapshot()\n\n    # Compare\n    top_stats = snapshot2.compare_to(snapshot1, 'lineno')\n\n    print(\"Top 10 memory allocations:\")\n    for stat in top_stats[:10]:\n        print(stat)\n\n    tracemalloc.stop()\n\n# Monitor memory\ntrack_memory_usage()\n\n# Force garbage collection\ngc.collect()\n```\n\n### Pattern 19: Iterators vs Lists\n\n```python\nimport sys\n\ndef process_file_list(filename):\n    \"\"\"Load entire file into memory.\"\"\"\n    with open(filename) as f:\n        lines = f.readlines()  # Loads all lines\n        return sum(1 for line in lines if line.strip())\n\ndef process_file_iterator(filename):\n    \"\"\"Process file line by line.\"\"\"\n    with open(filename) as f:\n        return sum(1 for line in f if line.strip())\n\n# Iterator uses constant memory\n# List loads entire file into memory\n```\n\n### Pattern 20: Weakref for Caches\n\n```python\nimport weakref\n\nclass CachedResource:\n    \"\"\"Resource that can be garbage collected.\"\"\"\n    def __init__(self, data):\n        self.data = data\n\n# Regular cache prevents garbage collection\nregular_cache = {}\n\ndef get_resource_regular(key):\n    \"\"\"Get resource from regular cache.\"\"\"\n    if key not in regular_cache:\n        regular_cache[key] = CachedResource(f\"Data for {key}\")\n    return regular_cache[key]\n\n# Weak reference cache allows garbage collection\nweak_cache = weakref.WeakValueDictionary()\n\ndef get_resource_weak(key):\n    \"\"\"Get resource from weak cache.\"\"\"\n    resource = weak_cache.get(key)\n    if resource is None:\n        resource = CachedResource(f\"Data for {key}\")\n        weak_cache[key] = resource\n    return resource\n\n# When no strong references exist, objects can be GC'd\n```\n\n## Benchmarking Tools\n\n### Custom Benchmark Decorator\n\n```python\nimport time\nfrom functools import wraps\n\ndef benchmark(func):\n    \"\"\"Decorator to benchmark function execution.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        elapsed = time.perf_counter() - start\n        print(f\"{func.__name__} took {elapsed:.6f} seconds\")\n        return result\n    return wrapper\n\n@benchmark\ndef slow_function():\n    \"\"\"Function to benchmark.\"\"\"\n    time.sleep(0.5)\n    return sum(range(1000000))\n\nresult = slow_function()\n```\n\n### Performance Testing with pytest-benchmark\n\n```python\n# Install: pip install pytest-benchmark\n\ndef test_list_comprehension(benchmark):\n    \"\"\"Benchmark list comprehension.\"\"\"\n    result = benchmark(lambda: [i**2 for i in range(10000)])\n    assert len(result) == 10000\n\ndef test_map_function(benchmark):\n    \"\"\"Benchmark map function.\"\"\"\n    result = benchmark(lambda: list(map(lambda x: x**2, range(10000))))\n    assert len(result) == 10000\n\n# Run with: pytest test_performance.py --benchmark-compare\n```\n\n## Best Practices\n\n1. **Profile before optimizing** - Measure to find real bottlenecks\n2. **Focus on hot paths** - Optimize code that runs most frequently\n3. **Use appropriate data structures** - Dict for lookups, set for membership\n4. **Avoid premature optimization** - Clarity first, then optimize\n5. **Use built-in functions** - They're implemented in C\n6. **Cache expensive computations** - Use lru_cache\n7. **Batch I/O operations** - Reduce system calls\n8. **Use generators** for large datasets\n9. **Consider NumPy** for numerical operations\n10. **Profile production code** - Use py-spy for live systems\n\n## Common Pitfalls\n\n- Optimizing without profiling\n- Using global variables unnecessarily\n- Not using appropriate data structures\n- Creating unnecessary copies of data\n- Not using connection pooling for databases\n- Ignoring algorithmic complexity\n- Over-optimizing rare code paths\n- Not considering memory usage\n\n## Resources\n\n- **cProfile**: Built-in CPU profiler\n- **memory_profiler**: Memory usage profiling\n- **line_profiler**: Line-by-line profiling\n- **py-spy**: Sampling profiler for production\n- **NumPy**: High-performance numerical computing\n- **Cython**: Compile Python to C\n- **PyPy**: Alternative Python interpreter with JIT\n\n## Performance Checklist\n\n- [ ] Profiled code to identify bottlenecks\n- [ ] Used appropriate data structures\n- [ ] Implemented caching where beneficial\n- [ ] Optimized database queries\n- [ ] Used generators for large datasets\n- [ ] Considered multiprocessing for CPU-bound tasks\n- [ ] Used async I/O for I/O-bound tasks\n- [ ] Minimized function call overhead in hot loops\n- [ ] Checked for memory leaks\n- [ ] Benchmarked before and after optimization\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "uv-package-manager",
      "description": "Master the uv package manager for fast Python dependency management, virtual environments, and modern Python project workflows. Use when setting up Python projects, managing dependencies, or optimizing Python development workflows with uv.",
      "plugin": "python-development",
      "source_path": "plugins/python-development/skills/uv-package-manager/SKILL.md",
      "category": "languages",
      "keywords": [
        "python",
        "django",
        "fastapi",
        "async",
        "backend"
      ],
      "content": "---\nname: uv-package-manager\ndescription: Master the uv package manager for fast Python dependency management, virtual environments, and modern Python project workflows. Use when setting up Python projects, managing dependencies, or optimizing Python development workflows with uv.\n---\n\n# UV Package Manager\n\nComprehensive guide to using uv, an extremely fast Python package installer and resolver written in Rust, for modern Python project management and dependency workflows.\n\n## When to Use This Skill\n\n- Setting up new Python projects quickly\n- Managing Python dependencies faster than pip\n- Creating and managing virtual environments\n- Installing Python interpreters\n- Resolving dependency conflicts efficiently\n- Migrating from pip/pip-tools/poetry\n- Speeding up CI/CD pipelines\n- Managing monorepo Python projects\n- Working with lockfiles for reproducible builds\n- Optimizing Docker builds with Python dependencies\n\n## Core Concepts\n\n### 1. What is uv?\n- **Ultra-fast package installer**: 10-100x faster than pip\n- **Written in Rust**: Leverages Rust's performance\n- **Drop-in pip replacement**: Compatible with pip workflows\n- **Virtual environment manager**: Create and manage venvs\n- **Python installer**: Download and manage Python versions\n- **Resolver**: Advanced dependency resolution\n- **Lockfile support**: Reproducible installations\n\n### 2. Key Features\n- Blazing fast installation speeds\n- Disk space efficient with global cache\n- Compatible with pip, pip-tools, poetry\n- Comprehensive dependency resolution\n- Cross-platform support (Linux, macOS, Windows)\n- No Python required for installation\n- Built-in virtual environment support\n\n### 3. UV vs Traditional Tools\n- **vs pip**: 10-100x faster, better resolver\n- **vs pip-tools**: Faster, simpler, better UX\n- **vs poetry**: Faster, less opinionated, lighter\n- **vs conda**: Faster, Python-focused\n\n## Installation\n\n### Quick Install\n\n```bash\n# macOS/Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Windows (PowerShell)\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n# Using pip (if you already have Python)\npip install uv\n\n# Using Homebrew (macOS)\nbrew install uv\n\n# Using cargo (if you have Rust)\ncargo install --git https://github.com/astral-sh/uv uv\n```\n\n### Verify Installation\n\n```bash\nuv --version\n# uv 0.x.x\n```\n\n## Quick Start\n\n### Create a New Project\n\n```bash\n# Create new project with virtual environment\nuv init my-project\ncd my-project\n\n# Or create in current directory\nuv init .\n\n# Initialize creates:\n# - .python-version (Python version)\n# - pyproject.toml (project config)\n# - README.md\n# - .gitignore\n```\n\n### Install Dependencies\n\n```bash\n# Install packages (creates venv if needed)\nuv add requests pandas\n\n# Install dev dependencies\nuv add --dev pytest black ruff\n\n# Install from requirements.txt\nuv pip install -r requirements.txt\n\n# Install from pyproject.toml\nuv sync\n```\n\n## Virtual Environment Management\n\n### Pattern 1: Creating Virtual Environments\n\n```bash\n# Create virtual environment with uv\nuv venv\n\n# Create with specific Python version\nuv venv --python 3.12\n\n# Create with custom name\nuv venv my-env\n\n# Create with system site packages\nuv venv --system-site-packages\n\n# Specify location\nuv venv /path/to/venv\n```\n\n### Pattern 2: Activating Virtual Environments\n\n```bash\n# Linux/macOS\nsource .venv/bin/activate\n\n# Windows (Command Prompt)\n.venv\\Scripts\\activate.bat\n\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# Or use uv run (no activation needed)\nuv run python script.py\nuv run pytest\n```\n\n### Pattern 3: Using uv run\n\n```bash\n# Run Python script (auto-activates venv)\nuv run python app.py\n\n# Run installed CLI tool\nuv run black .\nuv run pytest\n\n# Run with specific Python version\nuv run --python 3.11 python script.py\n\n# Pass arguments\nuv run python script.py --arg value\n```\n\n## Package Management\n\n### Pattern 4: Adding Dependencies\n\n```bash\n# Add package (adds to pyproject.toml)\nuv add requests\n\n# Add with version constraint\nuv add \"django>=4.0,<5.0\"\n\n# Add multiple packages\nuv add numpy pandas matplotlib\n\n# Add dev dependency\nuv add --dev pytest pytest-cov\n\n# Add optional dependency group\nuv add --optional docs sphinx\n\n# Add from git\nuv add git+https://github.com/user/repo.git\n\n# Add from git with specific ref\nuv add git+https://github.com/user/repo.git@v1.0.0\n\n# Add from local path\nuv add ./local-package\n\n# Add editable local package\nuv add -e ./local-package\n```\n\n### Pattern 5: Removing Dependencies\n\n```bash\n# Remove package\nuv remove requests\n\n# Remove dev dependency\nuv remove --dev pytest\n\n# Remove multiple packages\nuv remove numpy pandas matplotlib\n```\n\n### Pattern 6: Upgrading Dependencies\n\n```bash\n# Upgrade specific package\nuv add --upgrade requests\n\n# Upgrade all packages\nuv sync --upgrade\n\n# Upgrade package to latest\nuv add --upgrade requests\n\n# Show what would be upgraded\nuv tree --outdated\n```\n\n### Pattern 7: Locking Dependencies\n\n```bash\n# Generate uv.lock file\nuv lock\n\n# Update lock file\nuv lock --upgrade\n\n# Lock without installing\nuv lock --no-install\n\n# Lock specific package\nuv lock --upgrade-package requests\n```\n\n## Python Version Management\n\n### Pattern 8: Installing Python Versions\n\n```bash\n# Install Python version\nuv python install 3.12\n\n# Install multiple versions\nuv python install 3.11 3.12 3.13\n\n# Install latest version\nuv python install\n\n# List installed versions\nuv python list\n\n# Find available versions\nuv python list --all-versions\n```\n\n### Pattern 9: Setting Python Version\n\n```bash\n# Set Python version for project\nuv python pin 3.12\n\n# This creates/updates .python-version file\n\n# Use specific Python version for command\nuv --python 3.11 run python script.py\n\n# Create venv with specific version\nuv venv --python 3.12\n```\n\n## Project Configuration\n\n### Pattern 10: pyproject.toml with uv\n\n```toml\n[project]\nname = \"my-project\"\nversion = \"0.1.0\"\ndescription = \"My awesome project\"\nreadme = \"README.md\"\nrequires-python = \">=3.8\"\ndependencies = [\n    \"requests>=2.31.0\",\n    \"pydantic>=2.0.0\",\n    \"click>=8.1.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest>=7.4.0\",\n    \"pytest-cov>=4.1.0\",\n    \"black>=23.0.0\",\n    \"ruff>=0.1.0\",\n    \"mypy>=1.5.0\",\n]\ndocs = [\n    \"sphinx>=7.0.0\",\n    \"sphinx-rtd-theme>=1.3.0\",\n]\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.uv]\ndev-dependencies = [\n    # Additional dev dependencies managed by uv\n]\n\n[tool.uv.sources]\n# Custom package sources\nmy-package = { git = \"https://github.com/user/repo.git\" }\n```\n\n### Pattern 11: Using uv with Existing Projects\n\n```bash\n# Migrate from requirements.txt\nuv add -r requirements.txt\n\n# Migrate from poetry\n# Already have pyproject.toml, just use:\nuv sync\n\n# Export to requirements.txt\nuv pip freeze > requirements.txt\n\n# Export with hashes\nuv pip freeze --require-hashes > requirements.txt\n```\n\n## Advanced Workflows\n\n### Pattern 12: Monorepo Support\n\n```bash\n# Project structure\n# monorepo/\n#   packages/\n#     package-a/\n#       pyproject.toml\n#     package-b/\n#       pyproject.toml\n#   pyproject.toml (root)\n\n# Root pyproject.toml\n[tool.uv.workspace]\nmembers = [\"packages/*\"]\n\n# Install all workspace packages\nuv sync\n\n# Add workspace dependency\nuv add --path ./packages/package-a\n```\n\n### Pattern 13: CI/CD Integration\n\n```yaml\n# .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install uv\n        uses: astral-sh/setup-uv@v2\n        with:\n          enable-cache: true\n\n      - name: Set up Python\n        run: uv python install 3.12\n\n      - name: Install dependencies\n        run: uv sync --all-extras --dev\n\n      - name: Run tests\n        run: uv run pytest\n\n      - name: Run linting\n        run: |\n          uv run ruff check .\n          uv run black --check .\n```\n\n### Pattern 14: Docker Integration\n\n```dockerfile\n# Dockerfile\nFROM python:3.12-slim\n\n# Install uv\nCOPY --from=ghcr.io/astral-sh/uv:latest /uv /usr/local/bin/uv\n\n# Set working directory\nWORKDIR /app\n\n# Copy dependency files\nCOPY pyproject.toml uv.lock ./\n\n# Install dependencies\nRUN uv sync --frozen --no-dev\n\n# Copy application code\nCOPY . .\n\n# Run application\nCMD [\"uv\", \"run\", \"python\", \"app.py\"]\n```\n\n**Optimized multi-stage build:**\n\n```dockerfile\n# Multi-stage Dockerfile\nFROM python:3.12-slim AS builder\n\n# Install uv\nCOPY --from=ghcr.io/astral-sh/uv:latest /uv /usr/local/bin/uv\n\nWORKDIR /app\n\n# Install dependencies to venv\nCOPY pyproject.toml uv.lock ./\nRUN uv sync --frozen --no-dev --no-editable\n\n# Runtime stage\nFROM python:3.12-slim\n\nWORKDIR /app\n\n# Copy venv from builder\nCOPY --from=builder /app/.venv .venv\nCOPY . .\n\n# Use venv\nENV PATH=\"/app/.venv/bin:$PATH\"\n\nCMD [\"python\", \"app.py\"]\n```\n\n### Pattern 15: Lockfile Workflows\n\n```bash\n# Create lockfile (uv.lock)\nuv lock\n\n# Install from lockfile (exact versions)\nuv sync --frozen\n\n# Update lockfile without installing\nuv lock --no-install\n\n# Upgrade specific package in lock\nuv lock --upgrade-package requests\n\n# Check if lockfile is up to date\nuv lock --check\n\n# Export lockfile to requirements.txt\nuv export --format requirements-txt > requirements.txt\n\n# Export with hashes for security\nuv export --format requirements-txt --hash > requirements.txt\n```\n\n## Performance Optimization\n\n### Pattern 16: Using Global Cache\n\n```bash\n# UV automatically uses global cache at:\n# Linux: ~/.cache/uv\n# macOS: ~/Library/Caches/uv\n# Windows: %LOCALAPPDATA%\\uv\\cache\n\n# Clear cache\nuv cache clean\n\n# Check cache size\nuv cache dir\n```\n\n### Pattern 17: Parallel Installation\n\n```bash\n# UV installs packages in parallel by default\n\n# Control parallelism\nuv pip install --jobs 4 package1 package2\n\n# No parallel (sequential)\nuv pip install --jobs 1 package\n```\n\n### Pattern 18: Offline Mode\n\n```bash\n# Install from cache only (no network)\nuv pip install --offline package\n\n# Sync from lockfile offline\nuv sync --frozen --offline\n```\n\n## Comparison with Other Tools\n\n### uv vs pip\n\n```bash\n# pip\npython -m venv .venv\nsource .venv/bin/activate\npip install requests pandas numpy\n# ~30 seconds\n\n# uv\nuv venv\nuv add requests pandas numpy\n# ~2 seconds (10-15x faster)\n```\n\n### uv vs poetry\n\n```bash\n# poetry\npoetry init\npoetry add requests pandas\npoetry install\n# ~20 seconds\n\n# uv\nuv init\nuv add requests pandas\nuv sync\n# ~3 seconds (6-7x faster)\n```\n\n### uv vs pip-tools\n\n```bash\n# pip-tools\npip-compile requirements.in\npip-sync requirements.txt\n# ~15 seconds\n\n# uv\nuv lock\nuv sync --frozen\n# ~2 seconds (7-8x faster)\n```\n\n## Common Workflows\n\n### Pattern 19: Starting a New Project\n\n```bash\n# Complete workflow\nuv init my-project\ncd my-project\n\n# Set Python version\nuv python pin 3.12\n\n# Add dependencies\nuv add fastapi uvicorn pydantic\n\n# Add dev dependencies\nuv add --dev pytest black ruff mypy\n\n# Create structure\nmkdir -p src/my_project tests\n\n# Run tests\nuv run pytest\n\n# Format code\nuv run black .\nuv run ruff check .\n```\n\n### Pattern 20: Maintaining Existing Project\n\n```bash\n# Clone repository\ngit clone https://github.com/user/project.git\ncd project\n\n# Install dependencies (creates venv automatically)\nuv sync\n\n# Install with dev dependencies\nuv sync --all-extras\n\n# Update dependencies\nuv lock --upgrade\n\n# Run application\nuv run python app.py\n\n# Run tests\nuv run pytest\n\n# Add new dependency\nuv add new-package\n\n# Commit updated files\ngit add pyproject.toml uv.lock\ngit commit -m \"Add new-package dependency\"\n```\n\n## Tool Integration\n\n### Pattern 21: Pre-commit Hooks\n\n```yaml\n# .pre-commit-config.yaml\nrepos:\n  - repo: local\n    hooks:\n      - id: uv-lock\n        name: uv lock\n        entry: uv lock\n        language: system\n        pass_filenames: false\n\n      - id: ruff\n        name: ruff\n        entry: uv run ruff check --fix\n        language: system\n        types: [python]\n\n      - id: black\n        name: black\n        entry: uv run black\n        language: system\n        types: [python]\n```\n\n### Pattern 22: VS Code Integration\n\n```json\n// .vscode/settings.json\n{\n  \"python.defaultInterpreterPath\": \"${workspaceFolder}/.venv/bin/python\",\n  \"python.terminal.activateEnvironment\": true,\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestArgs\": [\"-v\"],\n  \"python.linting.enabled\": true,\n  \"python.formatting.provider\": \"black\",\n  \"[python]\": {\n    \"editor.defaultFormatter\": \"ms-python.black-formatter\",\n    \"editor.formatOnSave\": true\n  }\n}\n```\n\n## Troubleshooting\n\n### Common Issues\n\n```bash\n# Issue: uv not found\n# Solution: Add to PATH or reinstall\necho 'export PATH=\"$HOME/.cargo/bin:$PATH\"' >> ~/.bashrc\n\n# Issue: Wrong Python version\n# Solution: Pin version explicitly\nuv python pin 3.12\nuv venv --python 3.12\n\n# Issue: Dependency conflict\n# Solution: Check resolution\nuv lock --verbose\n\n# Issue: Cache issues\n# Solution: Clear cache\nuv cache clean\n\n# Issue: Lockfile out of sync\n# Solution: Regenerate\nuv lock --upgrade\n```\n\n## Best Practices\n\n### Project Setup\n\n1. **Always use lockfiles** for reproducibility\n2. **Pin Python version** with .python-version\n3. **Separate dev dependencies** from production\n4. **Use uv run** instead of activating venv\n5. **Commit uv.lock** to version control\n6. **Use --frozen in CI** for consistent builds\n7. **Leverage global cache** for speed\n8. **Use workspace** for monorepos\n9. **Export requirements.txt** for compatibility\n10. **Keep uv updated** for latest features\n\n### Performance Tips\n\n```bash\n# Use frozen installs in CI\nuv sync --frozen\n\n# Use offline mode when possible\nuv sync --offline\n\n# Parallel operations (automatic)\n# uv does this by default\n\n# Reuse cache across environments\n# uv shares cache globally\n\n# Use lockfiles to skip resolution\nuv sync --frozen  # skips resolution\n```\n\n## Migration Guide\n\n### From pip + requirements.txt\n\n```bash\n# Before\npython -m venv .venv\nsource .venv/bin/activate\npip install -r requirements.txt\n\n# After\nuv venv\nuv pip install -r requirements.txt\n# Or better:\nuv init\nuv add -r requirements.txt\n```\n\n### From Poetry\n\n```bash\n# Before\npoetry install\npoetry add requests\n\n# After\nuv sync\nuv add requests\n\n# Keep existing pyproject.toml\n# uv reads [project] and [tool.poetry] sections\n```\n\n### From pip-tools\n\n```bash\n# Before\npip-compile requirements.in\npip-sync requirements.txt\n\n# After\nuv lock\nuv sync --frozen\n```\n\n## Command Reference\n\n### Essential Commands\n\n```bash\n# Project management\nuv init [PATH]              # Initialize project\nuv add PACKAGE              # Add dependency\nuv remove PACKAGE           # Remove dependency\nuv sync                     # Install dependencies\nuv lock                     # Create/update lockfile\n\n# Virtual environments\nuv venv [PATH]              # Create venv\nuv run COMMAND              # Run in venv\n\n# Python management\nuv python install VERSION   # Install Python\nuv python list              # List installed Pythons\nuv python pin VERSION       # Pin Python version\n\n# Package installation (pip-compatible)\nuv pip install PACKAGE      # Install package\nuv pip uninstall PACKAGE    # Uninstall package\nuv pip freeze               # List installed\nuv pip list                 # List packages\n\n# Utility\nuv cache clean              # Clear cache\nuv cache dir                # Show cache location\nuv --version                # Show version\n```\n\n## Resources\n\n- **Official documentation**: https://docs.astral.sh/uv/\n- **GitHub repository**: https://github.com/astral-sh/uv\n- **Astral blog**: https://astral.sh/blog\n- **Migration guides**: https://docs.astral.sh/uv/guides/\n- **Comparison with other tools**: https://docs.astral.sh/uv/pip/compatibility/\n\n## Best Practices Summary\n\n1. **Use uv for all new projects** - Start with `uv init`\n2. **Commit lockfiles** - Ensure reproducible builds\n3. **Pin Python versions** - Use .python-version\n4. **Use uv run** - Avoid manual venv activation\n5. **Leverage caching** - Let uv manage global cache\n6. **Use --frozen in CI** - Exact reproduction\n7. **Keep uv updated** - Fast-moving project\n8. **Use workspaces** - For monorepo projects\n9. **Export for compatibility** - Generate requirements.txt when needed\n10. **Read the docs** - uv is feature-rich and evolving\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "typescript-advanced-types",
      "description": "Master TypeScript's advanced type system including generics, conditional types, mapped types, template literals, and utility types for building type-safe applications. Use when implementing complex type logic, creating reusable type utilities, or ensuring compile-time type safety in TypeScript projects.",
      "plugin": "javascript-typescript",
      "source_path": "plugins/javascript-typescript/skills/typescript-advanced-types/SKILL.md",
      "category": "languages",
      "keywords": [
        "javascript",
        "typescript",
        "es6",
        "nodejs",
        "react"
      ],
      "content": "---\nname: typescript-advanced-types\ndescription: Master TypeScript's advanced type system including generics, conditional types, mapped types, template literals, and utility types for building type-safe applications. Use when implementing complex type logic, creating reusable type utilities, or ensuring compile-time type safety in TypeScript projects.\n---\n\n# TypeScript Advanced Types\n\nComprehensive guidance for mastering TypeScript's advanced type system including generics, conditional types, mapped types, template literal types, and utility types for building robust, type-safe applications.\n\n## When to Use This Skill\n\n- Building type-safe libraries or frameworks\n- Creating reusable generic components\n- Implementing complex type inference logic\n- Designing type-safe API clients\n- Building form validation systems\n- Creating strongly-typed configuration objects\n- Implementing type-safe state management\n- Migrating JavaScript codebases to TypeScript\n\n## Core Concepts\n\n### 1. Generics\n\n**Purpose:** Create reusable, type-flexible components while maintaining type safety.\n\n**Basic Generic Function:**\n```typescript\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nconst num = identity<number>(42);        // Type: number\nconst str = identity<string>(\"hello\");    // Type: string\nconst auto = identity(true);              // Type inferred: boolean\n```\n\n**Generic Constraints:**\n```typescript\ninterface HasLength {\n  length: number;\n}\n\nfunction logLength<T extends HasLength>(item: T): T {\n  console.log(item.length);\n  return item;\n}\n\nlogLength(\"hello\");           // OK: string has length\nlogLength([1, 2, 3]);         // OK: array has length\nlogLength({ length: 10 });    // OK: object has length\n// logLength(42);             // Error: number has no length\n```\n\n**Multiple Type Parameters:**\n```typescript\nfunction merge<T, U>(obj1: T, obj2: U): T & U {\n  return { ...obj1, ...obj2 };\n}\n\nconst merged = merge(\n  { name: \"John\" },\n  { age: 30 }\n);\n// Type: { name: string } & { age: number }\n```\n\n### 2. Conditional Types\n\n**Purpose:** Create types that depend on conditions, enabling sophisticated type logic.\n\n**Basic Conditional Type:**\n```typescript\ntype IsString<T> = T extends string ? true : false;\n\ntype A = IsString<string>;    // true\ntype B = IsString<number>;    // false\n```\n\n**Extracting Return Types:**\n```typescript\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\nfunction getUser() {\n  return { id: 1, name: \"John\" };\n}\n\ntype User = ReturnType<typeof getUser>;\n// Type: { id: number; name: string; }\n```\n\n**Distributive Conditional Types:**\n```typescript\ntype ToArray<T> = T extends any ? T[] : never;\n\ntype StrOrNumArray = ToArray<string | number>;\n// Type: string[] | number[]\n```\n\n**Nested Conditions:**\n```typescript\ntype TypeName<T> =\n  T extends string ? \"string\" :\n  T extends number ? \"number\" :\n  T extends boolean ? \"boolean\" :\n  T extends undefined ? \"undefined\" :\n  T extends Function ? \"function\" :\n  \"object\";\n\ntype T1 = TypeName<string>;     // \"string\"\ntype T2 = TypeName<() => void>; // \"function\"\n```\n\n### 3. Mapped Types\n\n**Purpose:** Transform existing types by iterating over their properties.\n\n**Basic Mapped Type:**\n```typescript\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\ninterface User {\n  id: number;\n  name: string;\n}\n\ntype ReadonlyUser = Readonly<User>;\n// Type: { readonly id: number; readonly name: string; }\n```\n\n**Optional Properties:**\n```typescript\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n\ntype PartialUser = Partial<User>;\n// Type: { id?: number; name?: string; }\n```\n\n**Key Remapping:**\n```typescript\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\n\ninterface Person {\n  name: string;\n  age: number;\n}\n\ntype PersonGetters = Getters<Person>;\n// Type: { getName: () => string; getAge: () => number; }\n```\n\n**Filtering Properties:**\n```typescript\ntype PickByType<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n};\n\ninterface Mixed {\n  id: number;\n  name: string;\n  age: number;\n  active: boolean;\n}\n\ntype OnlyNumbers = PickByType<Mixed, number>;\n// Type: { id: number; age: number; }\n```\n\n### 4. Template Literal Types\n\n**Purpose:** Create string-based types with pattern matching and transformation.\n\n**Basic Template Literal:**\n```typescript\ntype EventName = \"click\" | \"focus\" | \"blur\";\ntype EventHandler = `on${Capitalize<EventName>}`;\n// Type: \"onClick\" | \"onFocus\" | \"onBlur\"\n```\n\n**String Manipulation:**\n```typescript\ntype UppercaseGreeting = Uppercase<\"hello\">;  // \"HELLO\"\ntype LowercaseGreeting = Lowercase<\"HELLO\">;  // \"hello\"\ntype CapitalizedName = Capitalize<\"john\">;    // \"John\"\ntype UncapitalizedName = Uncapitalize<\"John\">; // \"john\"\n```\n\n**Path Building:**\n```typescript\ntype Path<T> = T extends object\n  ? { [K in keyof T]: K extends string\n      ? `${K}` | `${K}.${Path<T[K]>}`\n      : never\n    }[keyof T]\n  : never;\n\ninterface Config {\n  server: {\n    host: string;\n    port: number;\n  };\n  database: {\n    url: string;\n  };\n}\n\ntype ConfigPath = Path<Config>;\n// Type: \"server\" | \"database\" | \"server.host\" | \"server.port\" | \"database.url\"\n```\n\n### 5. Utility Types\n\n**Built-in Utility Types:**\n\n```typescript\n// Partial<T> - Make all properties optional\ntype PartialUser = Partial<User>;\n\n// Required<T> - Make all properties required\ntype RequiredUser = Required<PartialUser>;\n\n// Readonly<T> - Make all properties readonly\ntype ReadonlyUser = Readonly<User>;\n\n// Pick<T, K> - Select specific properties\ntype UserName = Pick<User, \"name\" | \"email\">;\n\n// Omit<T, K> - Remove specific properties\ntype UserWithoutPassword = Omit<User, \"password\">;\n\n// Exclude<T, U> - Exclude types from union\ntype T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\">;  // \"b\" | \"c\"\n\n// Extract<T, U> - Extract types from union\ntype T2 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"b\">;  // \"a\" | \"b\"\n\n// NonNullable<T> - Exclude null and undefined\ntype T3 = NonNullable<string | null | undefined>;  // string\n\n// Record<K, T> - Create object type with keys K and values T\ntype PageInfo = Record<\"home\" | \"about\", { title: string }>;\n```\n\n## Advanced Patterns\n\n### Pattern 1: Type-Safe Event Emitter\n\n```typescript\ntype EventMap = {\n  \"user:created\": { id: string; name: string };\n  \"user:updated\": { id: string };\n  \"user:deleted\": { id: string };\n};\n\nclass TypedEventEmitter<T extends Record<string, any>> {\n  private listeners: {\n    [K in keyof T]?: Array<(data: T[K]) => void>;\n  } = {};\n\n  on<K extends keyof T>(event: K, callback: (data: T[K]) => void): void {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event]!.push(callback);\n  }\n\n  emit<K extends keyof T>(event: K, data: T[K]): void {\n    const callbacks = this.listeners[event];\n    if (callbacks) {\n      callbacks.forEach(callback => callback(data));\n    }\n  }\n}\n\nconst emitter = new TypedEventEmitter<EventMap>();\n\nemitter.on(\"user:created\", (data) => {\n  console.log(data.id, data.name);  // Type-safe!\n});\n\nemitter.emit(\"user:created\", { id: \"1\", name: \"John\" });\n// emitter.emit(\"user:created\", { id: \"1\" });  // Error: missing 'name'\n```\n\n### Pattern 2: Type-Safe API Client\n\n```typescript\ntype HTTPMethod = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n\ntype EndpointConfig = {\n  \"/users\": {\n    GET: { response: User[] };\n    POST: { body: { name: string; email: string }; response: User };\n  };\n  \"/users/:id\": {\n    GET: { params: { id: string }; response: User };\n    PUT: { params: { id: string }; body: Partial<User>; response: User };\n    DELETE: { params: { id: string }; response: void };\n  };\n};\n\ntype ExtractParams<T> = T extends { params: infer P } ? P : never;\ntype ExtractBody<T> = T extends { body: infer B } ? B : never;\ntype ExtractResponse<T> = T extends { response: infer R } ? R : never;\n\nclass APIClient<Config extends Record<string, Record<HTTPMethod, any>>> {\n  async request<\n    Path extends keyof Config,\n    Method extends keyof Config[Path]\n  >(\n    path: Path,\n    method: Method,\n    ...[options]: ExtractParams<Config[Path][Method]> extends never\n      ? ExtractBody<Config[Path][Method]> extends never\n        ? []\n        : [{ body: ExtractBody<Config[Path][Method]> }]\n      : [{\n          params: ExtractParams<Config[Path][Method]>;\n          body?: ExtractBody<Config[Path][Method]>;\n        }]\n  ): Promise<ExtractResponse<Config[Path][Method]>> {\n    // Implementation here\n    return {} as any;\n  }\n}\n\nconst api = new APIClient<EndpointConfig>();\n\n// Type-safe API calls\nconst users = await api.request(\"/users\", \"GET\");\n// Type: User[]\n\nconst newUser = await api.request(\"/users\", \"POST\", {\n  body: { name: \"John\", email: \"john@example.com\" }\n});\n// Type: User\n\nconst user = await api.request(\"/users/:id\", \"GET\", {\n  params: { id: \"123\" }\n});\n// Type: User\n```\n\n### Pattern 3: Builder Pattern with Type Safety\n\n```typescript\ntype BuilderState<T> = {\n  [K in keyof T]: T[K] | undefined;\n};\n\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;\n}[keyof T];\n\ntype IsComplete<T, S> =\n  RequiredKeys<T> extends keyof S\n    ? S[RequiredKeys<T>] extends undefined\n      ? false\n      : true\n    : false;\n\nclass Builder<T, S extends BuilderState<T> = {}> {\n  private state: S = {} as S;\n\n  set<K extends keyof T>(\n    key: K,\n    value: T[K]\n  ): Builder<T, S & Record<K, T[K]>> {\n    this.state[key] = value;\n    return this as any;\n  }\n\n  build(\n    this: IsComplete<T, S> extends true ? this : never\n  ): T {\n    return this.state as T;\n  }\n}\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  age?: number;\n}\n\nconst builder = new Builder<User>();\n\nconst user = builder\n  .set(\"id\", \"1\")\n  .set(\"name\", \"John\")\n  .set(\"email\", \"john@example.com\")\n  .build();  // OK: all required fields set\n\n// const incomplete = builder\n//   .set(\"id\", \"1\")\n//   .build();  // Error: missing required fields\n```\n\n### Pattern 4: Deep Readonly/Partial\n\n```typescript\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object\n    ? T[P] extends Function\n      ? T[P]\n      : DeepReadonly<T[P]>\n    : T[P];\n};\n\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object\n    ? T[P] extends Array<infer U>\n      ? Array<DeepPartial<U>>\n      : DeepPartial<T[P]>\n    : T[P];\n};\n\ninterface Config {\n  server: {\n    host: string;\n    port: number;\n    ssl: {\n      enabled: boolean;\n      cert: string;\n    };\n  };\n  database: {\n    url: string;\n    pool: {\n      min: number;\n      max: number;\n    };\n  };\n}\n\ntype ReadonlyConfig = DeepReadonly<Config>;\n// All nested properties are readonly\n\ntype PartialConfig = DeepPartial<Config>;\n// All nested properties are optional\n```\n\n### Pattern 5: Type-Safe Form Validation\n\n```typescript\ntype ValidationRule<T> = {\n  validate: (value: T) => boolean;\n  message: string;\n};\n\ntype FieldValidation<T> = {\n  [K in keyof T]?: ValidationRule<T[K]>[];\n};\n\ntype ValidationErrors<T> = {\n  [K in keyof T]?: string[];\n};\n\nclass FormValidator<T extends Record<string, any>> {\n  constructor(private rules: FieldValidation<T>) {}\n\n  validate(data: T): ValidationErrors<T> | null {\n    const errors: ValidationErrors<T> = {};\n    let hasErrors = false;\n\n    for (const key in this.rules) {\n      const fieldRules = this.rules[key];\n      const value = data[key];\n\n      if (fieldRules) {\n        const fieldErrors: string[] = [];\n\n        for (const rule of fieldRules) {\n          if (!rule.validate(value)) {\n            fieldErrors.push(rule.message);\n          }\n        }\n\n        if (fieldErrors.length > 0) {\n          errors[key] = fieldErrors;\n          hasErrors = true;\n        }\n      }\n    }\n\n    return hasErrors ? errors : null;\n  }\n}\n\ninterface LoginForm {\n  email: string;\n  password: string;\n}\n\nconst validator = new FormValidator<LoginForm>({\n  email: [\n    {\n      validate: (v) => v.includes(\"@\"),\n      message: \"Email must contain @\"\n    },\n    {\n      validate: (v) => v.length > 0,\n      message: \"Email is required\"\n    }\n  ],\n  password: [\n    {\n      validate: (v) => v.length >= 8,\n      message: \"Password must be at least 8 characters\"\n    }\n  ]\n});\n\nconst errors = validator.validate({\n  email: \"invalid\",\n  password: \"short\"\n});\n// Type: { email?: string[]; password?: string[]; } | null\n```\n\n### Pattern 6: Discriminated Unions\n\n```typescript\ntype Success<T> = {\n  status: \"success\";\n  data: T;\n};\n\ntype Error = {\n  status: \"error\";\n  error: string;\n};\n\ntype Loading = {\n  status: \"loading\";\n};\n\ntype AsyncState<T> = Success<T> | Error | Loading;\n\nfunction handleState<T>(state: AsyncState<T>): void {\n  switch (state.status) {\n    case \"success\":\n      console.log(state.data);  // Type: T\n      break;\n    case \"error\":\n      console.log(state.error);  // Type: string\n      break;\n    case \"loading\":\n      console.log(\"Loading...\");\n      break;\n  }\n}\n\n// Type-safe state machine\ntype State =\n  | { type: \"idle\" }\n  | { type: \"fetching\"; requestId: string }\n  | { type: \"success\"; data: any }\n  | { type: \"error\"; error: Error };\n\ntype Event =\n  | { type: \"FETCH\"; requestId: string }\n  | { type: \"SUCCESS\"; data: any }\n  | { type: \"ERROR\"; error: Error }\n  | { type: \"RESET\" };\n\nfunction reducer(state: State, event: Event): State {\n  switch (state.type) {\n    case \"idle\":\n      return event.type === \"FETCH\"\n        ? { type: \"fetching\", requestId: event.requestId }\n        : state;\n    case \"fetching\":\n      if (event.type === \"SUCCESS\") {\n        return { type: \"success\", data: event.data };\n      }\n      if (event.type === \"ERROR\") {\n        return { type: \"error\", error: event.error };\n      }\n      return state;\n    case \"success\":\n    case \"error\":\n      return event.type === \"RESET\" ? { type: \"idle\" } : state;\n  }\n}\n```\n\n## Type Inference Techniques\n\n### 1. Infer Keyword\n\n```typescript\n// Extract array element type\ntype ElementType<T> = T extends (infer U)[] ? U : never;\n\ntype NumArray = number[];\ntype Num = ElementType<NumArray>;  // number\n\n// Extract promise type\ntype PromiseType<T> = T extends Promise<infer U> ? U : never;\n\ntype AsyncNum = PromiseType<Promise<number>>;  // number\n\n// Extract function parameters\ntype Parameters<T> = T extends (...args: infer P) => any ? P : never;\n\nfunction foo(a: string, b: number) {}\ntype FooParams = Parameters<typeof foo>;  // [string, number]\n```\n\n### 2. Type Guards\n\n```typescript\nfunction isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nfunction isArrayOf<T>(\n  value: unknown,\n  guard: (item: unknown) => item is T\n): value is T[] {\n  return Array.isArray(value) && value.every(guard);\n}\n\nconst data: unknown = [\"a\", \"b\", \"c\"];\n\nif (isArrayOf(data, isString)) {\n  data.forEach(s => s.toUpperCase());  // Type: string[]\n}\n```\n\n### 3. Assertion Functions\n\n```typescript\nfunction assertIsString(value: unknown): asserts value is string {\n  if (typeof value !== \"string\") {\n    throw new Error(\"Not a string\");\n  }\n}\n\nfunction processValue(value: unknown) {\n  assertIsString(value);\n  // value is now typed as string\n  console.log(value.toUpperCase());\n}\n```\n\n## Best Practices\n\n1. **Use `unknown` over `any`**: Enforce type checking\n2. **Prefer `interface` for object shapes**: Better error messages\n3. **Use `type` for unions and complex types**: More flexible\n4. **Leverage type inference**: Let TypeScript infer when possible\n5. **Create helper types**: Build reusable type utilities\n6. **Use const assertions**: Preserve literal types\n7. **Avoid type assertions**: Use type guards instead\n8. **Document complex types**: Add JSDoc comments\n9. **Use strict mode**: Enable all strict compiler options\n10. **Test your types**: Use type tests to verify type behavior\n\n## Type Testing\n\n```typescript\n// Type assertion tests\ntype AssertEqual<T, U> =\n  [T] extends [U]\n    ? [U] extends [T]\n      ? true\n      : false\n    : false;\n\ntype Test1 = AssertEqual<string, string>;        // true\ntype Test2 = AssertEqual<string, number>;        // false\ntype Test3 = AssertEqual<string | number, string>; // false\n\n// Expect error helper\ntype ExpectError<T extends never> = T;\n\n// Example usage\ntype ShouldError = ExpectError<AssertEqual<string, number>>;\n```\n\n## Common Pitfalls\n\n1. **Over-using `any`**: Defeats the purpose of TypeScript\n2. **Ignoring strict null checks**: Can lead to runtime errors\n3. **Too complex types**: Can slow down compilation\n4. **Not using discriminated unions**: Misses type narrowing opportunities\n5. **Forgetting readonly modifiers**: Allows unintended mutations\n6. **Circular type references**: Can cause compiler errors\n7. **Not handling edge cases**: Like empty arrays or null values\n\n## Performance Considerations\n\n- Avoid deeply nested conditional types\n- Use simple types when possible\n- Cache complex type computations\n- Limit recursion depth in recursive types\n- Use build tools to skip type checking in production\n\n## Resources\n\n- **TypeScript Handbook**: https://www.typescriptlang.org/docs/handbook/\n- **Type Challenges**: https://github.com/type-challenges/type-challenges\n- **TypeScript Deep Dive**: https://basarat.gitbook.io/typescript/\n- **Effective TypeScript**: Book by Dan Vanderkam\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "nodejs-backend-patterns",
      "description": "Build production-ready Node.js backend services with Express/Fastify, implementing middleware patterns, error handling, authentication, database integration, and API design best practices. Use when creating Node.js servers, REST APIs, GraphQL backends, or microservices architectures.",
      "plugin": "javascript-typescript",
      "source_path": "plugins/javascript-typescript/skills/nodejs-backend-patterns/SKILL.md",
      "category": "languages",
      "keywords": [
        "javascript",
        "typescript",
        "es6",
        "nodejs",
        "react"
      ],
      "content": "---\nname: nodejs-backend-patterns\ndescription: Build production-ready Node.js backend services with Express/Fastify, implementing middleware patterns, error handling, authentication, database integration, and API design best practices. Use when creating Node.js servers, REST APIs, GraphQL backends, or microservices architectures.\n---\n\n# Node.js Backend Patterns\n\nComprehensive guidance for building scalable, maintainable, and production-ready Node.js backend applications with modern frameworks, architectural patterns, and best practices.\n\n## When to Use This Skill\n\n- Building REST APIs or GraphQL servers\n- Creating microservices with Node.js\n- Implementing authentication and authorization\n- Designing scalable backend architectures\n- Setting up middleware and error handling\n- Integrating databases (SQL and NoSQL)\n- Building real-time applications with WebSockets\n- Implementing background job processing\n\n## Core Frameworks\n\n### Express.js - Minimalist Framework\n\n**Basic Setup:**\n```typescript\nimport express, { Request, Response, NextFunction } from 'express';\nimport helmet from 'helmet';\nimport cors from 'cors';\nimport compression from 'compression';\n\nconst app = express();\n\n// Security middleware\napp.use(helmet());\napp.use(cors({ origin: process.env.ALLOWED_ORIGINS?.split(',') }));\napp.use(compression());\n\n// Body parsing\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Request logging\napp.use((req: Request, res: Response, next: NextFunction) => {\n  console.log(`${req.method} ${req.path}`);\n  next();\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```\n\n### Fastify - High Performance Framework\n\n**Basic Setup:**\n```typescript\nimport Fastify from 'fastify';\nimport helmet from '@fastify/helmet';\nimport cors from '@fastify/cors';\nimport compress from '@fastify/compress';\n\nconst fastify = Fastify({\n  logger: {\n    level: process.env.LOG_LEVEL || 'info',\n    transport: {\n      target: 'pino-pretty',\n      options: { colorize: true }\n    }\n  }\n});\n\n// Plugins\nawait fastify.register(helmet);\nawait fastify.register(cors, { origin: true });\nawait fastify.register(compress);\n\n// Type-safe routes with schema validation\nfastify.post<{\n  Body: { name: string; email: string };\n  Reply: { id: string; name: string };\n}>('/users', {\n  schema: {\n    body: {\n      type: 'object',\n      required: ['name', 'email'],\n      properties: {\n        name: { type: 'string', minLength: 1 },\n        email: { type: 'string', format: 'email' }\n      }\n    }\n  }\n}, async (request, reply) => {\n  const { name, email } = request.body;\n  return { id: '123', name };\n});\n\nawait fastify.listen({ port: 3000, host: '0.0.0.0' });\n```\n\n## Architectural Patterns\n\n### Pattern 1: Layered Architecture\n\n**Structure:**\n```\nsrc/\n\u251c\u2500\u2500 controllers/     # Handle HTTP requests/responses\n\u251c\u2500\u2500 services/        # Business logic\n\u251c\u2500\u2500 repositories/    # Data access layer\n\u251c\u2500\u2500 models/          # Data models\n\u251c\u2500\u2500 middleware/      # Express/Fastify middleware\n\u251c\u2500\u2500 routes/          # Route definitions\n\u251c\u2500\u2500 utils/           # Helper functions\n\u251c\u2500\u2500 config/          # Configuration\n\u2514\u2500\u2500 types/           # TypeScript types\n```\n\n**Controller Layer:**\n```typescript\n// controllers/user.controller.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { UserService } from '../services/user.service';\nimport { CreateUserDTO, UpdateUserDTO } from '../types/user.types';\n\nexport class UserController {\n  constructor(private userService: UserService) {}\n\n  async createUser(req: Request, res: Response, next: NextFunction) {\n    try {\n      const userData: CreateUserDTO = req.body;\n      const user = await this.userService.createUser(userData);\n      res.status(201).json(user);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async getUser(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const user = await this.userService.getUserById(id);\n      res.json(user);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async updateUser(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      const updates: UpdateUserDTO = req.body;\n      const user = await this.userService.updateUser(id, updates);\n      res.json(user);\n    } catch (error) {\n      next(error);\n    }\n  }\n\n  async deleteUser(req: Request, res: Response, next: NextFunction) {\n    try {\n      const { id } = req.params;\n      await this.userService.deleteUser(id);\n      res.status(204).send();\n    } catch (error) {\n      next(error);\n    }\n  }\n}\n```\n\n**Service Layer:**\n```typescript\n// services/user.service.ts\nimport { UserRepository } from '../repositories/user.repository';\nimport { CreateUserDTO, UpdateUserDTO, User } from '../types/user.types';\nimport { NotFoundError, ValidationError } from '../utils/errors';\nimport bcrypt from 'bcrypt';\n\nexport class UserService {\n  constructor(private userRepository: UserRepository) {}\n\n  async createUser(userData: CreateUserDTO): Promise<User> {\n    // Validation\n    const existingUser = await this.userRepository.findByEmail(userData.email);\n    if (existingUser) {\n      throw new ValidationError('Email already exists');\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(userData.password, 10);\n\n    // Create user\n    const user = await this.userRepository.create({\n      ...userData,\n      password: hashedPassword\n    });\n\n    // Remove password from response\n    const { password, ...userWithoutPassword } = user;\n    return userWithoutPassword as User;\n  }\n\n  async getUserById(id: string): Promise<User> {\n    const user = await this.userRepository.findById(id);\n    if (!user) {\n      throw new NotFoundError('User not found');\n    }\n    const { password, ...userWithoutPassword } = user;\n    return userWithoutPassword as User;\n  }\n\n  async updateUser(id: string, updates: UpdateUserDTO): Promise<User> {\n    const user = await this.userRepository.update(id, updates);\n    if (!user) {\n      throw new NotFoundError('User not found');\n    }\n    const { password, ...userWithoutPassword } = user;\n    return userWithoutPassword as User;\n  }\n\n  async deleteUser(id: string): Promise<void> {\n    const deleted = await this.userRepository.delete(id);\n    if (!deleted) {\n      throw new NotFoundError('User not found');\n    }\n  }\n}\n```\n\n**Repository Layer:**\n```typescript\n// repositories/user.repository.ts\nimport { Pool } from 'pg';\nimport { CreateUserDTO, UpdateUserDTO, UserEntity } from '../types/user.types';\n\nexport class UserRepository {\n  constructor(private db: Pool) {}\n\n  async create(userData: CreateUserDTO & { password: string }): Promise<UserEntity> {\n    const query = `\n      INSERT INTO users (name, email, password)\n      VALUES ($1, $2, $3)\n      RETURNING id, name, email, password, created_at, updated_at\n    `;\n    const { rows } = await this.db.query(query, [\n      userData.name,\n      userData.email,\n      userData.password\n    ]);\n    return rows[0];\n  }\n\n  async findById(id: string): Promise<UserEntity | null> {\n    const query = 'SELECT * FROM users WHERE id = $1';\n    const { rows } = await this.db.query(query, [id]);\n    return rows[0] || null;\n  }\n\n  async findByEmail(email: string): Promise<UserEntity | null> {\n    const query = 'SELECT * FROM users WHERE email = $1';\n    const { rows } = await this.db.query(query, [email]);\n    return rows[0] || null;\n  }\n\n  async update(id: string, updates: UpdateUserDTO): Promise<UserEntity | null> {\n    const fields = Object.keys(updates);\n    const values = Object.values(updates);\n\n    const setClause = fields\n      .map((field, idx) => `${field} = $${idx + 2}`)\n      .join(', ');\n\n    const query = `\n      UPDATE users\n      SET ${setClause}, updated_at = CURRENT_TIMESTAMP\n      WHERE id = $1\n      RETURNING *\n    `;\n\n    const { rows } = await this.db.query(query, [id, ...values]);\n    return rows[0] || null;\n  }\n\n  async delete(id: string): Promise<boolean> {\n    const query = 'DELETE FROM users WHERE id = $1';\n    const { rowCount } = await this.db.query(query, [id]);\n    return rowCount > 0;\n  }\n}\n```\n\n### Pattern 2: Dependency Injection\n\n**DI Container:**\n```typescript\n// di-container.ts\nimport { Pool } from 'pg';\nimport { UserRepository } from './repositories/user.repository';\nimport { UserService } from './services/user.service';\nimport { UserController } from './controllers/user.controller';\nimport { AuthService } from './services/auth.service';\n\nclass Container {\n  private instances = new Map<string, any>();\n\n  register<T>(key: string, factory: () => T): void {\n    this.instances.set(key, factory);\n  }\n\n  resolve<T>(key: string): T {\n    const factory = this.instances.get(key);\n    if (!factory) {\n      throw new Error(`No factory registered for ${key}`);\n    }\n    return factory();\n  }\n\n  singleton<T>(key: string, factory: () => T): void {\n    let instance: T;\n    this.instances.set(key, () => {\n      if (!instance) {\n        instance = factory();\n      }\n      return instance;\n    });\n  }\n}\n\nexport const container = new Container();\n\n// Register dependencies\ncontainer.singleton('db', () => new Pool({\n  host: process.env.DB_HOST,\n  port: parseInt(process.env.DB_PORT || '5432'),\n  database: process.env.DB_NAME,\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD,\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000,\n}));\n\ncontainer.singleton('userRepository', () =>\n  new UserRepository(container.resolve('db'))\n);\n\ncontainer.singleton('userService', () =>\n  new UserService(container.resolve('userRepository'))\n);\n\ncontainer.register('userController', () =>\n  new UserController(container.resolve('userService'))\n);\n\ncontainer.singleton('authService', () =>\n  new AuthService(container.resolve('userRepository'))\n);\n```\n\n## Middleware Patterns\n\n### Authentication Middleware\n\n```typescript\n// middleware/auth.middleware.ts\nimport { Request, Response, NextFunction } from 'express';\nimport jwt from 'jsonwebtoken';\nimport { UnauthorizedError } from '../utils/errors';\n\ninterface JWTPayload {\n  userId: string;\n  email: string;\n}\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: JWTPayload;\n    }\n  }\n}\n\nexport const authenticate = async (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  try {\n    const token = req.headers.authorization?.replace('Bearer ', '');\n\n    if (!token) {\n      throw new UnauthorizedError('No token provided');\n    }\n\n    const payload = jwt.verify(\n      token,\n      process.env.JWT_SECRET!\n    ) as JWTPayload;\n\n    req.user = payload;\n    next();\n  } catch (error) {\n    next(new UnauthorizedError('Invalid token'));\n  }\n};\n\nexport const authorize = (...roles: string[]) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    if (!req.user) {\n      return next(new UnauthorizedError('Not authenticated'));\n    }\n\n    // Check if user has required role\n    const hasRole = roles.some(role =>\n      req.user?.roles?.includes(role)\n    );\n\n    if (!hasRole) {\n      return next(new UnauthorizedError('Insufficient permissions'));\n    }\n\n    next();\n  };\n};\n```\n\n### Validation Middleware\n\n```typescript\n// middleware/validation.middleware.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { AnyZodObject, ZodError } from 'zod';\nimport { ValidationError } from '../utils/errors';\n\nexport const validate = (schema: AnyZodObject) => {\n  return async (req: Request, res: Response, next: NextFunction) => {\n    try {\n      await schema.parseAsync({\n        body: req.body,\n        query: req.query,\n        params: req.params\n      });\n      next();\n    } catch (error) {\n      if (error instanceof ZodError) {\n        const errors = error.errors.map(err => ({\n          field: err.path.join('.'),\n          message: err.message\n        }));\n        next(new ValidationError('Validation failed', errors));\n      } else {\n        next(error);\n      }\n    }\n  };\n};\n\n// Usage with Zod\nimport { z } from 'zod';\n\nconst createUserSchema = z.object({\n  body: z.object({\n    name: z.string().min(1),\n    email: z.string().email(),\n    password: z.string().min(8)\n  })\n});\n\nrouter.post('/users', validate(createUserSchema), userController.createUser);\n```\n\n### Rate Limiting Middleware\n\n```typescript\n// middleware/rate-limit.middleware.ts\nimport rateLimit from 'express-rate-limit';\nimport RedisStore from 'rate-limit-redis';\nimport Redis from 'ioredis';\n\nconst redis = new Redis({\n  host: process.env.REDIS_HOST,\n  port: parseInt(process.env.REDIS_PORT || '6379')\n});\n\nexport const apiLimiter = rateLimit({\n  store: new RedisStore({\n    client: redis,\n    prefix: 'rl:',\n  }),\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  message: 'Too many requests from this IP, please try again later',\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nexport const authLimiter = rateLimit({\n  store: new RedisStore({\n    client: redis,\n    prefix: 'rl:auth:',\n  }),\n  windowMs: 15 * 60 * 1000,\n  max: 5, // Stricter limit for auth endpoints\n  skipSuccessfulRequests: true,\n});\n```\n\n### Request Logging Middleware\n\n```typescript\n// middleware/logger.middleware.ts\nimport { Request, Response, NextFunction } from 'express';\nimport pino from 'pino';\n\nconst logger = pino({\n  level: process.env.LOG_LEVEL || 'info',\n  transport: {\n    target: 'pino-pretty',\n    options: { colorize: true }\n  }\n});\n\nexport const requestLogger = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  const start = Date.now();\n\n  // Log response when finished\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    logger.info({\n      method: req.method,\n      url: req.url,\n      status: res.statusCode,\n      duration: `${duration}ms`,\n      userAgent: req.headers['user-agent'],\n      ip: req.ip\n    });\n  });\n\n  next();\n};\n\nexport { logger };\n```\n\n## Error Handling\n\n### Custom Error Classes\n\n```typescript\n// utils/errors.ts\nexport class AppError extends Error {\n  constructor(\n    public message: string,\n    public statusCode: number = 500,\n    public isOperational: boolean = true\n  ) {\n    super(message);\n    Object.setPrototypeOf(this, AppError.prototype);\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(message: string, public errors?: any[]) {\n    super(message, 400);\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(message: string = 'Resource not found') {\n    super(message, 404);\n  }\n}\n\nexport class UnauthorizedError extends AppError {\n  constructor(message: string = 'Unauthorized') {\n    super(message, 401);\n  }\n}\n\nexport class ForbiddenError extends AppError {\n  constructor(message: string = 'Forbidden') {\n    super(message, 403);\n  }\n}\n\nexport class ConflictError extends AppError {\n  constructor(message: string) {\n    super(message, 409);\n  }\n}\n```\n\n### Global Error Handler\n\n```typescript\n// middleware/error-handler.ts\nimport { Request, Response, NextFunction } from 'express';\nimport { AppError } from '../utils/errors';\nimport { logger } from './logger.middleware';\n\nexport const errorHandler = (\n  err: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  if (err instanceof AppError) {\n    return res.status(err.statusCode).json({\n      status: 'error',\n      message: err.message,\n      ...(err instanceof ValidationError && { errors: err.errors })\n    });\n  }\n\n  // Log unexpected errors\n  logger.error({\n    error: err.message,\n    stack: err.stack,\n    url: req.url,\n    method: req.method\n  });\n\n  // Don't leak error details in production\n  const message = process.env.NODE_ENV === 'production'\n    ? 'Internal server error'\n    : err.message;\n\n  res.status(500).json({\n    status: 'error',\n    message\n  });\n};\n\n// Async error wrapper\nexport const asyncHandler = (\n  fn: (req: Request, res: Response, next: NextFunction) => Promise<any>\n) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n```\n\n## Database Patterns\n\n### PostgreSQL with Connection Pool\n\n```typescript\n// config/database.ts\nimport { Pool, PoolConfig } from 'pg';\n\nconst poolConfig: PoolConfig = {\n  host: process.env.DB_HOST,\n  port: parseInt(process.env.DB_PORT || '5432'),\n  database: process.env.DB_NAME,\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD,\n  max: 20,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000,\n};\n\nexport const pool = new Pool(poolConfig);\n\n// Test connection\npool.on('connect', () => {\n  console.log('Database connected');\n});\n\npool.on('error', (err) => {\n  console.error('Unexpected database error', err);\n  process.exit(-1);\n});\n\n// Graceful shutdown\nexport const closeDatabase = async () => {\n  await pool.end();\n  console.log('Database connection closed');\n};\n```\n\n### MongoDB with Mongoose\n\n```typescript\n// config/mongoose.ts\nimport mongoose from 'mongoose';\n\nconst connectDB = async () => {\n  try {\n    await mongoose.connect(process.env.MONGODB_URI!, {\n      maxPoolSize: 10,\n      serverSelectionTimeoutMS: 5000,\n      socketTimeoutMS: 45000,\n    });\n\n    console.log('MongoDB connected');\n  } catch (error) {\n    console.error('MongoDB connection error:', error);\n    process.exit(1);\n  }\n};\n\nmongoose.connection.on('disconnected', () => {\n  console.log('MongoDB disconnected');\n});\n\nmongoose.connection.on('error', (err) => {\n  console.error('MongoDB error:', err);\n});\n\nexport { connectDB };\n\n// Model example\nimport { Schema, model, Document } from 'mongoose';\n\ninterface IUser extends Document {\n  name: string;\n  email: string;\n  password: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nconst userSchema = new Schema<IUser>({\n  name: { type: String, required: true },\n  email: { type: String, required: true, unique: true },\n  password: { type: String, required: true },\n}, {\n  timestamps: true\n});\n\n// Indexes\nuserSchema.index({ email: 1 });\n\nexport const User = model<IUser>('User', userSchema);\n```\n\n### Transaction Pattern\n\n```typescript\n// services/order.service.ts\nimport { Pool } from 'pg';\n\nexport class OrderService {\n  constructor(private db: Pool) {}\n\n  async createOrder(userId: string, items: any[]) {\n    const client = await this.db.connect();\n\n    try {\n      await client.query('BEGIN');\n\n      // Create order\n      const orderResult = await client.query(\n        'INSERT INTO orders (user_id, total) VALUES ($1, $2) RETURNING id',\n        [userId, calculateTotal(items)]\n      );\n      const orderId = orderResult.rows[0].id;\n\n      // Create order items\n      for (const item of items) {\n        await client.query(\n          'INSERT INTO order_items (order_id, product_id, quantity, price) VALUES ($1, $2, $3, $4)',\n          [orderId, item.productId, item.quantity, item.price]\n        );\n\n        // Update inventory\n        await client.query(\n          'UPDATE products SET stock = stock - $1 WHERE id = $2',\n          [item.quantity, item.productId]\n        );\n      }\n\n      await client.query('COMMIT');\n      return orderId;\n    } catch (error) {\n      await client.query('ROLLBACK');\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n}\n```\n\n## Authentication & Authorization\n\n### JWT Authentication\n\n```typescript\n// services/auth.service.ts\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcrypt';\nimport { UserRepository } from '../repositories/user.repository';\nimport { UnauthorizedError } from '../utils/errors';\n\nexport class AuthService {\n  constructor(private userRepository: UserRepository) {}\n\n  async login(email: string, password: string) {\n    const user = await this.userRepository.findByEmail(email);\n\n    if (!user) {\n      throw new UnauthorizedError('Invalid credentials');\n    }\n\n    const isValid = await bcrypt.compare(password, user.password);\n\n    if (!isValid) {\n      throw new UnauthorizedError('Invalid credentials');\n    }\n\n    const token = this.generateToken({\n      userId: user.id,\n      email: user.email\n    });\n\n    const refreshToken = this.generateRefreshToken({\n      userId: user.id\n    });\n\n    return {\n      token,\n      refreshToken,\n      user: {\n        id: user.id,\n        name: user.name,\n        email: user.email\n      }\n    };\n  }\n\n  async refreshToken(refreshToken: string) {\n    try {\n      const payload = jwt.verify(\n        refreshToken,\n        process.env.REFRESH_TOKEN_SECRET!\n      ) as { userId: string };\n\n      const user = await this.userRepository.findById(payload.userId);\n\n      if (!user) {\n        throw new UnauthorizedError('User not found');\n      }\n\n      const token = this.generateToken({\n        userId: user.id,\n        email: user.email\n      });\n\n      return { token };\n    } catch (error) {\n      throw new UnauthorizedError('Invalid refresh token');\n    }\n  }\n\n  private generateToken(payload: any): string {\n    return jwt.sign(payload, process.env.JWT_SECRET!, {\n      expiresIn: '15m'\n    });\n  }\n\n  private generateRefreshToken(payload: any): string {\n    return jwt.sign(payload, process.env.REFRESH_TOKEN_SECRET!, {\n      expiresIn: '7d'\n    });\n  }\n}\n```\n\n## Caching Strategies\n\n```typescript\n// utils/cache.ts\nimport Redis from 'ioredis';\n\nconst redis = new Redis({\n  host: process.env.REDIS_HOST,\n  port: parseInt(process.env.REDIS_PORT || '6379'),\n  retryStrategy: (times) => {\n    const delay = Math.min(times * 50, 2000);\n    return delay;\n  }\n});\n\nexport class CacheService {\n  async get<T>(key: string): Promise<T | null> {\n    const data = await redis.get(key);\n    return data ? JSON.parse(data) : null;\n  }\n\n  async set(key: string, value: any, ttl?: number): Promise<void> {\n    const serialized = JSON.stringify(value);\n    if (ttl) {\n      await redis.setex(key, ttl, serialized);\n    } else {\n      await redis.set(key, serialized);\n    }\n  }\n\n  async delete(key: string): Promise<void> {\n    await redis.del(key);\n  }\n\n  async invalidatePattern(pattern: string): Promise<void> {\n    const keys = await redis.keys(pattern);\n    if (keys.length > 0) {\n      await redis.del(...keys);\n    }\n  }\n}\n\n// Cache decorator\nexport function Cacheable(ttl: number = 300) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const cache = new CacheService();\n      const cacheKey = `${propertyKey}:${JSON.stringify(args)}`;\n\n      const cached = await cache.get(cacheKey);\n      if (cached) {\n        return cached;\n      }\n\n      const result = await originalMethod.apply(this, args);\n      await cache.set(cacheKey, result, ttl);\n\n      return result;\n    };\n\n    return descriptor;\n  };\n}\n```\n\n## API Response Format\n\n```typescript\n// utils/response.ts\nimport { Response } from 'express';\n\nexport class ApiResponse {\n  static success<T>(res: Response, data: T, message?: string, statusCode = 200) {\n    return res.status(statusCode).json({\n      status: 'success',\n      message,\n      data\n    });\n  }\n\n  static error(res: Response, message: string, statusCode = 500, errors?: any) {\n    return res.status(statusCode).json({\n      status: 'error',\n      message,\n      ...(errors && { errors })\n    });\n  }\n\n  static paginated<T>(\n    res: Response,\n    data: T[],\n    page: number,\n    limit: number,\n    total: number\n  ) {\n    return res.json({\n      status: 'success',\n      data,\n      pagination: {\n        page,\n        limit,\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  }\n}\n```\n\n## Best Practices\n\n1. **Use TypeScript**: Type safety prevents runtime errors\n2. **Implement proper error handling**: Use custom error classes\n3. **Validate input**: Use libraries like Zod or Joi\n4. **Use environment variables**: Never hardcode secrets\n5. **Implement logging**: Use structured logging (Pino, Winston)\n6. **Add rate limiting**: Prevent abuse\n7. **Use HTTPS**: Always in production\n8. **Implement CORS properly**: Don't use `*` in production\n9. **Use dependency injection**: Easier testing and maintenance\n10. **Write tests**: Unit, integration, and E2E tests\n11. **Handle graceful shutdown**: Clean up resources\n12. **Use connection pooling**: For databases\n13. **Implement health checks**: For monitoring\n14. **Use compression**: Reduce response size\n15. **Monitor performance**: Use APM tools\n\n## Testing Patterns\n\nSee `javascript-testing-patterns` skill for comprehensive testing guidance.\n\n## Resources\n\n- **Node.js Best Practices**: https://github.com/goldbergyoni/nodebestpractices\n- **Express.js Guide**: https://expressjs.com/en/guide/\n- **Fastify Documentation**: https://www.fastify.io/docs/\n- **TypeScript Node Starter**: https://github.com/microsoft/TypeScript-Node-Starter\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "javascript-testing-patterns",
      "description": "Implement comprehensive testing strategies using Jest, Vitest, and Testing Library for unit tests, integration tests, and end-to-end testing with mocking, fixtures, and test-driven development. Use when writing JavaScript/TypeScript tests, setting up test infrastructure, or implementing TDD/BDD workflows.",
      "plugin": "javascript-typescript",
      "source_path": "plugins/javascript-typescript/skills/javascript-testing-patterns/SKILL.md",
      "category": "languages",
      "keywords": [
        "javascript",
        "typescript",
        "es6",
        "nodejs",
        "react"
      ],
      "content": "---\nname: javascript-testing-patterns\ndescription: Implement comprehensive testing strategies using Jest, Vitest, and Testing Library for unit tests, integration tests, and end-to-end testing with mocking, fixtures, and test-driven development. Use when writing JavaScript/TypeScript tests, setting up test infrastructure, or implementing TDD/BDD workflows.\n---\n\n# JavaScript Testing Patterns\n\nComprehensive guide for implementing robust testing strategies in JavaScript/TypeScript applications using modern testing frameworks and best practices.\n\n## When to Use This Skill\n\n- Setting up test infrastructure for new projects\n- Writing unit tests for functions and classes\n- Creating integration tests for APIs and services\n- Implementing end-to-end tests for user flows\n- Mocking external dependencies and APIs\n- Testing React, Vue, or other frontend components\n- Implementing test-driven development (TDD)\n- Setting up continuous testing in CI/CD pipelines\n\n## Testing Frameworks\n\n### Jest - Full-Featured Testing Framework\n\n**Setup:**\n```typescript\n// jest.config.ts\nimport type { Config } from 'jest';\n\nconst config: Config = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/**/*.interface.ts',\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80,\n    },\n  },\n  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],\n};\n\nexport default config;\n```\n\n### Vitest - Fast, Vite-Native Testing\n\n**Setup:**\n```typescript\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config';\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: 'node',\n    coverage: {\n      provider: 'v8',\n      reporter: ['text', 'json', 'html'],\n      exclude: ['**/*.d.ts', '**/*.config.ts', '**/dist/**'],\n    },\n    setupFiles: ['./src/test/setup.ts'],\n  },\n});\n```\n\n## Unit Testing Patterns\n\n### Pattern 1: Testing Pure Functions\n\n```typescript\n// utils/calculator.ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    throw new Error('Division by zero');\n  }\n  return a / b;\n}\n\n// utils/calculator.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { add, divide } from './calculator';\n\ndescribe('Calculator', () => {\n  describe('add', () => {\n    it('should add two positive numbers', () => {\n      expect(add(2, 3)).toBe(5);\n    });\n\n    it('should add negative numbers', () => {\n      expect(add(-2, -3)).toBe(-5);\n    });\n\n    it('should handle zero', () => {\n      expect(add(0, 5)).toBe(5);\n      expect(add(5, 0)).toBe(5);\n    });\n  });\n\n  describe('divide', () => {\n    it('should divide two numbers', () => {\n      expect(divide(10, 2)).toBe(5);\n    });\n\n    it('should handle decimal results', () => {\n      expect(divide(5, 2)).toBe(2.5);\n    });\n\n    it('should throw error when dividing by zero', () => {\n      expect(() => divide(10, 0)).toThrow('Division by zero');\n    });\n  });\n});\n```\n\n### Pattern 2: Testing Classes\n\n```typescript\n// services/user.service.ts\nexport class UserService {\n  private users: Map<string, User> = new Map();\n\n  create(user: User): User {\n    if (this.users.has(user.id)) {\n      throw new Error('User already exists');\n    }\n    this.users.set(user.id, user);\n    return user;\n  }\n\n  findById(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  update(id: string, updates: Partial<User>): User {\n    const user = this.users.get(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    const updated = { ...user, ...updates };\n    this.users.set(id, updated);\n    return updated;\n  }\n\n  delete(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\n\n// services/user.service.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { UserService } from './user.service';\n\ndescribe('UserService', () => {\n  let service: UserService;\n\n  beforeEach(() => {\n    service = new UserService();\n  });\n\n  describe('create', () => {\n    it('should create a new user', () => {\n      const user = { id: '1', name: 'John', email: 'john@example.com' };\n      const created = service.create(user);\n\n      expect(created).toEqual(user);\n      expect(service.findById('1')).toEqual(user);\n    });\n\n    it('should throw error if user already exists', () => {\n      const user = { id: '1', name: 'John', email: 'john@example.com' };\n      service.create(user);\n\n      expect(() => service.create(user)).toThrow('User already exists');\n    });\n  });\n\n  describe('update', () => {\n    it('should update existing user', () => {\n      const user = { id: '1', name: 'John', email: 'john@example.com' };\n      service.create(user);\n\n      const updated = service.update('1', { name: 'Jane' });\n\n      expect(updated.name).toBe('Jane');\n      expect(updated.email).toBe('john@example.com');\n    });\n\n    it('should throw error if user not found', () => {\n      expect(() => service.update('999', { name: 'Jane' }))\n        .toThrow('User not found');\n    });\n  });\n});\n```\n\n### Pattern 3: Testing Async Functions\n\n```typescript\n// services/api.service.ts\nexport class ApiService {\n  async fetchUser(id: string): Promise<User> {\n    const response = await fetch(`https://api.example.com/users/${id}`);\n    if (!response.ok) {\n      throw new Error('User not found');\n    }\n    return response.json();\n  }\n\n  async createUser(user: CreateUserDTO): Promise<User> {\n    const response = await fetch('https://api.example.com/users', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(user),\n    });\n    return response.json();\n  }\n}\n\n// services/api.service.test.ts\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { ApiService } from './api.service';\n\n// Mock fetch globally\nglobal.fetch = vi.fn();\n\ndescribe('ApiService', () => {\n  let service: ApiService;\n\n  beforeEach(() => {\n    service = new ApiService();\n    vi.clearAllMocks();\n  });\n\n  describe('fetchUser', () => {\n    it('should fetch user successfully', async () => {\n      const mockUser = { id: '1', name: 'John', email: 'john@example.com' };\n\n      (fetch as any).mockResolvedValueOnce({\n        ok: true,\n        json: async () => mockUser,\n      });\n\n      const user = await service.fetchUser('1');\n\n      expect(user).toEqual(mockUser);\n      expect(fetch).toHaveBeenCalledWith('https://api.example.com/users/1');\n    });\n\n    it('should throw error if user not found', async () => {\n      (fetch as any).mockResolvedValueOnce({\n        ok: false,\n      });\n\n      await expect(service.fetchUser('999')).rejects.toThrow('User not found');\n    });\n  });\n\n  describe('createUser', () => {\n    it('should create user successfully', async () => {\n      const newUser = { name: 'John', email: 'john@example.com' };\n      const createdUser = { id: '1', ...newUser };\n\n      (fetch as any).mockResolvedValueOnce({\n        ok: true,\n        json: async () => createdUser,\n      });\n\n      const user = await service.createUser(newUser);\n\n      expect(user).toEqual(createdUser);\n      expect(fetch).toHaveBeenCalledWith(\n        'https://api.example.com/users',\n        expect.objectContaining({\n          method: 'POST',\n          body: JSON.stringify(newUser),\n        })\n      );\n    });\n  });\n});\n```\n\n## Mocking Patterns\n\n### Pattern 1: Mocking Modules\n\n```typescript\n// services/email.service.ts\nimport nodemailer from 'nodemailer';\n\nexport class EmailService {\n  private transporter = nodemailer.createTransport({\n    host: process.env.SMTP_HOST,\n    port: 587,\n    auth: {\n      user: process.env.SMTP_USER,\n      pass: process.env.SMTP_PASS,\n    },\n  });\n\n  async sendEmail(to: string, subject: string, html: string) {\n    await this.transporter.sendMail({\n      from: process.env.EMAIL_FROM,\n      to,\n      subject,\n      html,\n    });\n  }\n}\n\n// services/email.service.test.ts\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { EmailService } from './email.service';\n\nvi.mock('nodemailer', () => ({\n  default: {\n    createTransport: vi.fn(() => ({\n      sendMail: vi.fn().mockResolvedValue({ messageId: '123' }),\n    })),\n  },\n}));\n\ndescribe('EmailService', () => {\n  let service: EmailService;\n\n  beforeEach(() => {\n    service = new EmailService();\n  });\n\n  it('should send email successfully', async () => {\n    await service.sendEmail(\n      'test@example.com',\n      'Test Subject',\n      '<p>Test Body</p>'\n    );\n\n    expect(service['transporter'].sendMail).toHaveBeenCalledWith(\n      expect.objectContaining({\n        to: 'test@example.com',\n        subject: 'Test Subject',\n      })\n    );\n  });\n});\n```\n\n### Pattern 2: Dependency Injection for Testing\n\n```typescript\n// services/user.service.ts\nexport interface IUserRepository {\n  findById(id: string): Promise<User | null>;\n  create(user: User): Promise<User>;\n}\n\nexport class UserService {\n  constructor(private userRepository: IUserRepository) {}\n\n  async getUser(id: string): Promise<User> {\n    const user = await this.userRepository.findById(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    return user;\n  }\n\n  async createUser(userData: CreateUserDTO): Promise<User> {\n    // Business logic here\n    const user = { id: generateId(), ...userData };\n    return this.userRepository.create(user);\n  }\n}\n\n// services/user.service.test.ts\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { UserService, IUserRepository } from './user.service';\n\ndescribe('UserService', () => {\n  let service: UserService;\n  let mockRepository: IUserRepository;\n\n  beforeEach(() => {\n    mockRepository = {\n      findById: vi.fn(),\n      create: vi.fn(),\n    };\n    service = new UserService(mockRepository);\n  });\n\n  describe('getUser', () => {\n    it('should return user if found', async () => {\n      const mockUser = { id: '1', name: 'John', email: 'john@example.com' };\n      vi.mocked(mockRepository.findById).mockResolvedValue(mockUser);\n\n      const user = await service.getUser('1');\n\n      expect(user).toEqual(mockUser);\n      expect(mockRepository.findById).toHaveBeenCalledWith('1');\n    });\n\n    it('should throw error if user not found', async () => {\n      vi.mocked(mockRepository.findById).mockResolvedValue(null);\n\n      await expect(service.getUser('999')).rejects.toThrow('User not found');\n    });\n  });\n\n  describe('createUser', () => {\n    it('should create user successfully', async () => {\n      const userData = { name: 'John', email: 'john@example.com' };\n      const createdUser = { id: '1', ...userData };\n\n      vi.mocked(mockRepository.create).mockResolvedValue(createdUser);\n\n      const user = await service.createUser(userData);\n\n      expect(user).toEqual(createdUser);\n      expect(mockRepository.create).toHaveBeenCalled();\n    });\n  });\n});\n```\n\n### Pattern 3: Spying on Functions\n\n```typescript\n// utils/logger.ts\nexport const logger = {\n  info: (message: string) => console.log(`INFO: ${message}`),\n  error: (message: string) => console.error(`ERROR: ${message}`),\n};\n\n// services/order.service.ts\nimport { logger } from '../utils/logger';\n\nexport class OrderService {\n  async processOrder(orderId: string): Promise<void> {\n    logger.info(`Processing order ${orderId}`);\n    // Process order logic\n    logger.info(`Order ${orderId} processed successfully`);\n  }\n}\n\n// services/order.service.test.ts\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { OrderService } from './order.service';\nimport { logger } from '../utils/logger';\n\ndescribe('OrderService', () => {\n  let service: OrderService;\n  let loggerSpy: any;\n\n  beforeEach(() => {\n    service = new OrderService();\n    loggerSpy = vi.spyOn(logger, 'info');\n  });\n\n  afterEach(() => {\n    loggerSpy.mockRestore();\n  });\n\n  it('should log order processing', async () => {\n    await service.processOrder('123');\n\n    expect(loggerSpy).toHaveBeenCalledWith('Processing order 123');\n    expect(loggerSpy).toHaveBeenCalledWith('Order 123 processed successfully');\n    expect(loggerSpy).toHaveBeenCalledTimes(2);\n  });\n});\n```\n\n## Integration Testing\n\n### Pattern 1: API Integration Tests\n\n```typescript\n// tests/integration/user.api.test.ts\nimport request from 'supertest';\nimport { app } from '../../src/app';\nimport { pool } from '../../src/config/database';\n\ndescribe('User API Integration Tests', () => {\n  beforeAll(async () => {\n    // Setup test database\n    await pool.query('CREATE TABLE IF NOT EXISTS users (...)');\n  });\n\n  afterAll(async () => {\n    // Cleanup\n    await pool.query('DROP TABLE IF EXISTS users');\n    await pool.end();\n  });\n\n  beforeEach(async () => {\n    // Clear data before each test\n    await pool.query('TRUNCATE TABLE users CASCADE');\n  });\n\n  describe('POST /api/users', () => {\n    it('should create a new user', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123',\n      };\n\n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(201);\n\n      expect(response.body).toMatchObject({\n        name: userData.name,\n        email: userData.email,\n      });\n      expect(response.body).toHaveProperty('id');\n      expect(response.body).not.toHaveProperty('password');\n    });\n\n    it('should return 400 if email is invalid', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'invalid-email',\n        password: 'password123',\n      };\n\n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(400);\n\n      expect(response.body).toHaveProperty('error');\n    });\n\n    it('should return 409 if email already exists', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123',\n      };\n\n      await request(app).post('/api/users').send(userData);\n\n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(409);\n\n      expect(response.body.error).toContain('already exists');\n    });\n  });\n\n  describe('GET /api/users/:id', () => {\n    it('should get user by id', async () => {\n      const createResponse = await request(app)\n        .post('/api/users')\n        .send({\n          name: 'John Doe',\n          email: 'john@example.com',\n          password: 'password123',\n        });\n\n      const userId = createResponse.body.id;\n\n      const response = await request(app)\n        .get(`/api/users/${userId}`)\n        .expect(200);\n\n      expect(response.body).toMatchObject({\n        id: userId,\n        name: 'John Doe',\n        email: 'john@example.com',\n      });\n    });\n\n    it('should return 404 if user not found', async () => {\n      await request(app)\n        .get('/api/users/999')\n        .expect(404);\n    });\n  });\n\n  describe('Authentication', () => {\n    it('should require authentication for protected routes', async () => {\n      await request(app)\n        .get('/api/users/me')\n        .expect(401);\n    });\n\n    it('should allow access with valid token', async () => {\n      // Create user and login\n      await request(app)\n        .post('/api/users')\n        .send({\n          name: 'John Doe',\n          email: 'john@example.com',\n          password: 'password123',\n        });\n\n      const loginResponse = await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'john@example.com',\n          password: 'password123',\n        });\n\n      const token = loginResponse.body.token;\n\n      const response = await request(app)\n        .get('/api/users/me')\n        .set('Authorization', `Bearer ${token}`)\n        .expect(200);\n\n      expect(response.body.email).toBe('john@example.com');\n    });\n  });\n});\n```\n\n### Pattern 2: Database Integration Tests\n\n```typescript\n// tests/integration/user.repository.test.ts\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { Pool } from 'pg';\nimport { UserRepository } from '../../src/repositories/user.repository';\n\ndescribe('UserRepository Integration Tests', () => {\n  let pool: Pool;\n  let repository: UserRepository;\n\n  beforeAll(async () => {\n    pool = new Pool({\n      host: 'localhost',\n      port: 5432,\n      database: 'test_db',\n      user: 'test_user',\n      password: 'test_password',\n    });\n\n    repository = new UserRepository(pool);\n\n    // Create tables\n    await pool.query(`\n      CREATE TABLE IF NOT EXISTS users (\n        id SERIAL PRIMARY KEY,\n        name VARCHAR(255) NOT NULL,\n        email VARCHAR(255) UNIQUE NOT NULL,\n        password VARCHAR(255) NOT NULL,\n        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n  });\n\n  afterAll(async () => {\n    await pool.query('DROP TABLE IF EXISTS users');\n    await pool.end();\n  });\n\n  beforeEach(async () => {\n    await pool.query('TRUNCATE TABLE users CASCADE');\n  });\n\n  it('should create a user', async () => {\n    const user = await repository.create({\n      name: 'John Doe',\n      email: 'john@example.com',\n      password: 'hashed_password',\n    });\n\n    expect(user).toHaveProperty('id');\n    expect(user.name).toBe('John Doe');\n    expect(user.email).toBe('john@example.com');\n  });\n\n  it('should find user by email', async () => {\n    await repository.create({\n      name: 'John Doe',\n      email: 'john@example.com',\n      password: 'hashed_password',\n    });\n\n    const user = await repository.findByEmail('john@example.com');\n\n    expect(user).toBeTruthy();\n    expect(user?.name).toBe('John Doe');\n  });\n\n  it('should return null if user not found', async () => {\n    const user = await repository.findByEmail('nonexistent@example.com');\n    expect(user).toBeNull();\n  });\n});\n```\n\n## Frontend Testing with Testing Library\n\n### Pattern 1: React Component Testing\n\n```typescript\n// components/UserForm.tsx\nimport { useState } from 'react';\n\ninterface Props {\n  onSubmit: (user: { name: string; email: string }) => void;\n}\n\nexport function UserForm({ onSubmit }: Props) {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSubmit({ name, email });\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        placeholder=\"Name\"\n        value={name}\n        onChange={(e) => setName(e.target.value)}\n        data-testid=\"name-input\"\n      />\n      <input\n        type=\"email\"\n        placeholder=\"Email\"\n        value={email}\n        onChange={(e) => setEmail(e.target.value)}\n        data-testid=\"email-input\"\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\n// components/UserForm.test.tsx\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { describe, it, expect, vi } from 'vitest';\nimport { UserForm } from './UserForm';\n\ndescribe('UserForm', () => {\n  it('should render form inputs', () => {\n    render(<UserForm onSubmit={vi.fn()} />);\n\n    expect(screen.getByPlaceholderText('Name')).toBeInTheDocument();\n    expect(screen.getByPlaceholderText('Email')).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: 'Submit' })).toBeInTheDocument();\n  });\n\n  it('should update input values', () => {\n    render(<UserForm onSubmit={vi.fn()} />);\n\n    const nameInput = screen.getByTestId('name-input') as HTMLInputElement;\n    const emailInput = screen.getByTestId('email-input') as HTMLInputElement;\n\n    fireEvent.change(nameInput, { target: { value: 'John Doe' } });\n    fireEvent.change(emailInput, { target: { value: 'john@example.com' } });\n\n    expect(nameInput.value).toBe('John Doe');\n    expect(emailInput.value).toBe('john@example.com');\n  });\n\n  it('should call onSubmit with form data', () => {\n    const onSubmit = vi.fn();\n    render(<UserForm onSubmit={onSubmit} />);\n\n    fireEvent.change(screen.getByTestId('name-input'), {\n      target: { value: 'John Doe' },\n    });\n    fireEvent.change(screen.getByTestId('email-input'), {\n      target: { value: 'john@example.com' },\n    });\n    fireEvent.click(screen.getByRole('button', { name: 'Submit' }));\n\n    expect(onSubmit).toHaveBeenCalledWith({\n      name: 'John Doe',\n      email: 'john@example.com',\n    });\n  });\n});\n```\n\n### Pattern 2: Testing Hooks\n\n```typescript\n// hooks/useCounter.ts\nimport { useState, useCallback } from 'react';\n\nexport function useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n\n  const increment = useCallback(() => setCount((c) => c + 1), []);\n  const decrement = useCallback(() => setCount((c) => c - 1), []);\n  const reset = useCallback(() => setCount(initialValue), [initialValue]);\n\n  return { count, increment, decrement, reset };\n}\n\n// hooks/useCounter.test.ts\nimport { renderHook, act } from '@testing-library/react';\nimport { describe, it, expect } from 'vitest';\nimport { useCounter } from './useCounter';\n\ndescribe('useCounter', () => {\n  it('should initialize with default value', () => {\n    const { result } = renderHook(() => useCounter());\n    expect(result.current.count).toBe(0);\n  });\n\n  it('should initialize with custom value', () => {\n    const { result } = renderHook(() => useCounter(10));\n    expect(result.current.count).toBe(10);\n  });\n\n  it('should increment count', () => {\n    const { result } = renderHook(() => useCounter());\n\n    act(() => {\n      result.current.increment();\n    });\n\n    expect(result.current.count).toBe(1);\n  });\n\n  it('should decrement count', () => {\n    const { result } = renderHook(() => useCounter(5));\n\n    act(() => {\n      result.current.decrement();\n    });\n\n    expect(result.current.count).toBe(4);\n  });\n\n  it('should reset to initial value', () => {\n    const { result } = renderHook(() => useCounter(10));\n\n    act(() => {\n      result.current.increment();\n      result.current.increment();\n    });\n\n    expect(result.current.count).toBe(12);\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.count).toBe(10);\n  });\n});\n```\n\n## Test Fixtures and Factories\n\n```typescript\n// tests/fixtures/user.fixture.ts\nimport { faker } from '@faker-js/faker';\n\nexport function createUserFixture(overrides?: Partial<User>): User {\n  return {\n    id: faker.string.uuid(),\n    name: faker.person.fullName(),\n    email: faker.internet.email(),\n    createdAt: faker.date.past(),\n    ...overrides,\n  };\n}\n\nexport function createUsersFixture(count: number): User[] {\n  return Array.from({ length: count }, () => createUserFixture());\n}\n\n// Usage in tests\nimport { createUserFixture, createUsersFixture } from '../fixtures/user.fixture';\n\ndescribe('UserService', () => {\n  it('should process user', () => {\n    const user = createUserFixture({ name: 'John Doe' });\n    // Use user in test\n  });\n\n  it('should handle multiple users', () => {\n    const users = createUsersFixture(10);\n    // Use users in test\n  });\n});\n```\n\n## Snapshot Testing\n\n```typescript\n// components/UserCard.test.tsx\nimport { render } from '@testing-library/react';\nimport { describe, it, expect } from 'vitest';\nimport { UserCard } from './UserCard';\n\ndescribe('UserCard', () => {\n  it('should match snapshot', () => {\n    const user = {\n      id: '1',\n      name: 'John Doe',\n      email: 'john@example.com',\n      avatar: 'https://example.com/avatar.jpg',\n    };\n\n    const { container } = render(<UserCard user={user} />);\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  it('should match snapshot with loading state', () => {\n    const { container } = render(<UserCard loading />);\n    expect(container.firstChild).toMatchSnapshot();\n  });\n});\n```\n\n## Coverage Reports\n\n```typescript\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"test:coverage\": \"vitest --coverage\",\n    \"test:ui\": \"vitest --ui\"\n  }\n}\n```\n\n## Best Practices\n\n1. **Follow AAA Pattern**: Arrange, Act, Assert\n2. **One assertion per test**: Or logically related assertions\n3. **Descriptive test names**: Should describe what is being tested\n4. **Use beforeEach/afterEach**: For setup and teardown\n5. **Mock external dependencies**: Keep tests isolated\n6. **Test edge cases**: Not just happy paths\n7. **Avoid implementation details**: Test behavior, not implementation\n8. **Use test factories**: For consistent test data\n9. **Keep tests fast**: Mock slow operations\n10. **Write tests first (TDD)**: When possible\n11. **Maintain test coverage**: Aim for 80%+ coverage\n12. **Use TypeScript**: For type-safe tests\n13. **Test error handling**: Not just success cases\n14. **Use data-testid sparingly**: Prefer semantic queries\n15. **Clean up after tests**: Prevent test pollution\n\n## Common Patterns\n\n### Test Organization\n\n```typescript\ndescribe('UserService', () => {\n  describe('createUser', () => {\n    it('should create user successfully', () => {});\n    it('should throw error if email exists', () => {});\n    it('should hash password', () => {});\n  });\n\n  describe('updateUser', () => {\n    it('should update user', () => {});\n    it('should throw error if not found', () => {});\n  });\n});\n```\n\n### Testing Promises\n\n```typescript\n// Using async/await\nit('should fetch user', async () => {\n  const user = await service.fetchUser('1');\n  expect(user).toBeDefined();\n});\n\n// Testing rejections\nit('should throw error', async () => {\n  await expect(service.fetchUser('invalid')).rejects.toThrow('Not found');\n});\n```\n\n### Testing Timers\n\n```typescript\nimport { vi } from 'vitest';\n\nit('should call function after delay', () => {\n  vi.useFakeTimers();\n\n  const callback = vi.fn();\n  setTimeout(callback, 1000);\n\n  expect(callback).not.toHaveBeenCalled();\n\n  vi.advanceTimersByTime(1000);\n\n  expect(callback).toHaveBeenCalled();\n\n  vi.useRealTimers();\n});\n```\n\n## Resources\n\n- **Jest Documentation**: https://jestjs.io/\n- **Vitest Documentation**: https://vitest.dev/\n- **Testing Library**: https://testing-library.com/\n- **Kent C. Dodds Testing Blog**: https://kentcdodds.com/blog/\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "modern-javascript-patterns",
      "description": "Master ES6+ features including async/await, destructuring, spread operators, arrow functions, promises, modules, iterators, generators, and functional programming patterns for writing clean, efficient JavaScript code. Use when refactoring legacy code, implementing modern patterns, or optimizing JavaScript applications.",
      "plugin": "javascript-typescript",
      "source_path": "plugins/javascript-typescript/skills/modern-javascript-patterns/SKILL.md",
      "category": "languages",
      "keywords": [
        "javascript",
        "typescript",
        "es6",
        "nodejs",
        "react"
      ],
      "content": "---\nname: modern-javascript-patterns\ndescription: Master ES6+ features including async/await, destructuring, spread operators, arrow functions, promises, modules, iterators, generators, and functional programming patterns for writing clean, efficient JavaScript code. Use when refactoring legacy code, implementing modern patterns, or optimizing JavaScript applications.\n---\n\n# Modern JavaScript Patterns\n\nComprehensive guide for mastering modern JavaScript (ES6+) features, functional programming patterns, and best practices for writing clean, maintainable, and performant code.\n\n## When to Use This Skill\n\n- Refactoring legacy JavaScript to modern syntax\n- Implementing functional programming patterns\n- Optimizing JavaScript performance\n- Writing maintainable and readable code\n- Working with asynchronous operations\n- Building modern web applications\n- Migrating from callbacks to Promises/async-await\n- Implementing data transformation pipelines\n\n## ES6+ Core Features\n\n### 1. Arrow Functions\n\n**Syntax and Use Cases:**\n```javascript\n// Traditional function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function\nconst add = (a, b) => a + b;\n\n// Single parameter (parentheses optional)\nconst double = x => x * 2;\n\n// No parameters\nconst getRandom = () => Math.random();\n\n// Multiple statements (need curly braces)\nconst processUser = user => {\n  const normalized = user.name.toLowerCase();\n  return { ...user, name: normalized };\n};\n\n// Returning objects (wrap in parentheses)\nconst createUser = (name, age) => ({ name, age });\n```\n\n**Lexical 'this' Binding:**\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n\n  // Arrow function preserves 'this' context\n  increment = () => {\n    this.count++;\n  };\n\n  // Traditional function loses 'this' in callbacks\n  incrementTraditional() {\n    setTimeout(function() {\n      this.count++;  // 'this' is undefined\n    }, 1000);\n  }\n\n  // Arrow function maintains 'this'\n  incrementArrow() {\n    setTimeout(() => {\n      this.count++;  // 'this' refers to Counter instance\n    }, 1000);\n  }\n}\n```\n\n### 2. Destructuring\n\n**Object Destructuring:**\n```javascript\nconst user = {\n  id: 1,\n  name: 'John Doe',\n  email: 'john@example.com',\n  address: {\n    city: 'New York',\n    country: 'USA'\n  }\n};\n\n// Basic destructuring\nconst { name, email } = user;\n\n// Rename variables\nconst { name: userName, email: userEmail } = user;\n\n// Default values\nconst { age = 25 } = user;\n\n// Nested destructuring\nconst { address: { city, country } } = user;\n\n// Rest operator\nconst { id, ...userWithoutId } = user;\n\n// Function parameters\nfunction greet({ name, age = 18 }) {\n  console.log(`Hello ${name}, you are ${age}`);\n}\ngreet(user);\n```\n\n**Array Destructuring:**\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// Basic destructuring\nconst [first, second] = numbers;\n\n// Skip elements\nconst [, , third] = numbers;\n\n// Rest operator\nconst [head, ...tail] = numbers;\n\n// Swapping variables\nlet a = 1, b = 2;\n[a, b] = [b, a];\n\n// Function return values\nfunction getCoordinates() {\n  return [10, 20];\n}\nconst [x, y] = getCoordinates();\n\n// Default values\nconst [one, two, three = 0] = [1, 2];\n```\n\n### 3. Spread and Rest Operators\n\n**Spread Operator:**\n```javascript\n// Array spreading\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = [...arr1, ...arr2];\n\n// Object spreading\nconst defaults = { theme: 'dark', lang: 'en' };\nconst userPrefs = { theme: 'light' };\nconst settings = { ...defaults, ...userPrefs };\n\n// Function arguments\nconst numbers = [1, 2, 3];\nMath.max(...numbers);\n\n// Copying arrays/objects (shallow copy)\nconst copy = [...arr1];\nconst objCopy = { ...user };\n\n// Adding items immutably\nconst newArr = [...arr1, 4, 5];\nconst newObj = { ...user, age: 30 };\n```\n\n**Rest Parameters:**\n```javascript\n// Collect function arguments\nfunction sum(...numbers) {\n  return numbers.reduce((total, num) => total + num, 0);\n}\nsum(1, 2, 3, 4, 5);\n\n// With regular parameters\nfunction greet(greeting, ...names) {\n  return `${greeting} ${names.join(', ')}`;\n}\ngreet('Hello', 'John', 'Jane', 'Bob');\n\n// Object rest\nconst { id, ...userData } = user;\n\n// Array rest\nconst [first, ...rest] = [1, 2, 3, 4, 5];\n```\n\n### 4. Template Literals\n\n```javascript\n// Basic usage\nconst name = 'John';\nconst greeting = `Hello, ${name}!`;\n\n// Multi-line strings\nconst html = `\n  <div>\n    <h1>${title}</h1>\n    <p>${content}</p>\n  </div>\n`;\n\n// Expression evaluation\nconst price = 19.99;\nconst total = `Total: $${(price * 1.2).toFixed(2)}`;\n\n// Tagged template literals\nfunction highlight(strings, ...values) {\n  return strings.reduce((result, str, i) => {\n    const value = values[i] || '';\n    return result + str + `<mark>${value}</mark>`;\n  }, '');\n}\n\nconst name = 'John';\nconst age = 30;\nconst html = highlight`Name: ${name}, Age: ${age}`;\n// Output: \"Name: <mark>John</mark>, Age: <mark>30</mark>\"\n```\n\n### 5. Enhanced Object Literals\n\n```javascript\nconst name = 'John';\nconst age = 30;\n\n// Shorthand property names\nconst user = { name, age };\n\n// Shorthand method names\nconst calculator = {\n  add(a, b) {\n    return a + b;\n  },\n  subtract(a, b) {\n    return a - b;\n  }\n};\n\n// Computed property names\nconst field = 'email';\nconst user = {\n  name: 'John',\n  [field]: 'john@example.com',\n  [`get${field.charAt(0).toUpperCase()}${field.slice(1)}`]() {\n    return this[field];\n  }\n};\n\n// Dynamic property creation\nconst createUser = (name, ...props) => {\n  return props.reduce((user, [key, value]) => ({\n    ...user,\n    [key]: value\n  }), { name });\n};\n\nconst user = createUser('John', ['age', 30], ['email', 'john@example.com']);\n```\n\n## Asynchronous Patterns\n\n### 1. Promises\n\n**Creating and Using Promises:**\n```javascript\n// Creating a promise\nconst fetchUser = (id) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id > 0) {\n        resolve({ id, name: 'John' });\n      } else {\n        reject(new Error('Invalid ID'));\n      }\n    }, 1000);\n  });\n};\n\n// Using promises\nfetchUser(1)\n  .then(user => console.log(user))\n  .catch(error => console.error(error))\n  .finally(() => console.log('Done'));\n\n// Chaining promises\nfetchUser(1)\n  .then(user => fetchUserPosts(user.id))\n  .then(posts => processPosts(posts))\n  .then(result => console.log(result))\n  .catch(error => console.error(error));\n```\n\n**Promise Combinators:**\n```javascript\n// Promise.all - Wait for all promises\nconst promises = [\n  fetchUser(1),\n  fetchUser(2),\n  fetchUser(3)\n];\n\nPromise.all(promises)\n  .then(users => console.log(users))\n  .catch(error => console.error('At least one failed:', error));\n\n// Promise.allSettled - Wait for all, regardless of outcome\nPromise.allSettled(promises)\n  .then(results => {\n    results.forEach(result => {\n      if (result.status === 'fulfilled') {\n        console.log('Success:', result.value);\n      } else {\n        console.log('Error:', result.reason);\n      }\n    });\n  });\n\n// Promise.race - First to complete\nPromise.race(promises)\n  .then(winner => console.log('First:', winner))\n  .catch(error => console.error(error));\n\n// Promise.any - First to succeed\nPromise.any(promises)\n  .then(first => console.log('First success:', first))\n  .catch(error => console.error('All failed:', error));\n```\n\n### 2. Async/Await\n\n**Basic Usage:**\n```javascript\n// Async function always returns a Promise\nasync function fetchUser(id) {\n  const response = await fetch(`/api/users/${id}`);\n  const user = await response.json();\n  return user;\n}\n\n// Error handling with try/catch\nasync function getUserData(id) {\n  try {\n    const user = await fetchUser(id);\n    const posts = await fetchUserPosts(user.id);\n    return { user, posts };\n  } catch (error) {\n    console.error('Error fetching data:', error);\n    throw error;\n  }\n}\n\n// Sequential vs Parallel execution\nasync function sequential() {\n  const user1 = await fetchUser(1);  // Wait\n  const user2 = await fetchUser(2);  // Then wait\n  return [user1, user2];\n}\n\nasync function parallel() {\n  const [user1, user2] = await Promise.all([\n    fetchUser(1),\n    fetchUser(2)\n  ]);\n  return [user1, user2];\n}\n```\n\n**Advanced Patterns:**\n```javascript\n// Async IIFE\n(async () => {\n  const result = await someAsyncOperation();\n  console.log(result);\n})();\n\n// Async iteration\nasync function processUsers(userIds) {\n  for (const id of userIds) {\n    const user = await fetchUser(id);\n    await processUser(user);\n  }\n}\n\n// Top-level await (ES2022)\nconst config = await fetch('/config.json').then(r => r.json());\n\n// Retry logic\nasync function fetchWithRetry(url, retries = 3) {\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await fetch(url);\n    } catch (error) {\n      if (i === retries - 1) throw error;\n      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n    }\n  }\n}\n\n// Timeout wrapper\nasync function withTimeout(promise, ms) {\n  const timeout = new Promise((_, reject) =>\n    setTimeout(() => reject(new Error('Timeout')), ms)\n  );\n  return Promise.race([promise, timeout]);\n}\n```\n\n## Functional Programming Patterns\n\n### 1. Array Methods\n\n**Map, Filter, Reduce:**\n```javascript\nconst users = [\n  { id: 1, name: 'John', age: 30, active: true },\n  { id: 2, name: 'Jane', age: 25, active: false },\n  { id: 3, name: 'Bob', age: 35, active: true }\n];\n\n// Map - Transform array\nconst names = users.map(user => user.name);\nconst upperNames = users.map(user => user.name.toUpperCase());\n\n// Filter - Select elements\nconst activeUsers = users.filter(user => user.active);\nconst adults = users.filter(user => user.age >= 18);\n\n// Reduce - Aggregate data\nconst totalAge = users.reduce((sum, user) => sum + user.age, 0);\nconst avgAge = totalAge / users.length;\n\n// Group by property\nconst byActive = users.reduce((groups, user) => {\n  const key = user.active ? 'active' : 'inactive';\n  return {\n    ...groups,\n    [key]: [...(groups[key] || []), user]\n  };\n}, {});\n\n// Chaining methods\nconst result = users\n  .filter(user => user.active)\n  .map(user => user.name)\n  .sort()\n  .join(', ');\n```\n\n**Advanced Array Methods:**\n```javascript\n// Find - First matching element\nconst user = users.find(u => u.id === 2);\n\n// FindIndex - Index of first match\nconst index = users.findIndex(u => u.name === 'Jane');\n\n// Some - At least one matches\nconst hasActive = users.some(u => u.active);\n\n// Every - All match\nconst allAdults = users.every(u => u.age >= 18);\n\n// FlatMap - Map and flatten\nconst userTags = [\n  { name: 'John', tags: ['admin', 'user'] },\n  { name: 'Jane', tags: ['user'] }\n];\nconst allTags = userTags.flatMap(u => u.tags);\n\n// From - Create array from iterable\nconst str = 'hello';\nconst chars = Array.from(str);\nconst numbers = Array.from({ length: 5 }, (_, i) => i + 1);\n\n// Of - Create array from arguments\nconst arr = Array.of(1, 2, 3);\n```\n\n### 2. Higher-Order Functions\n\n**Functions as Arguments:**\n```javascript\n// Custom forEach\nfunction forEach(array, callback) {\n  for (let i = 0; i < array.length; i++) {\n    callback(array[i], i, array);\n  }\n}\n\n// Custom map\nfunction map(array, transform) {\n  const result = [];\n  for (const item of array) {\n    result.push(transform(item));\n  }\n  return result;\n}\n\n// Custom filter\nfunction filter(array, predicate) {\n  const result = [];\n  for (const item of array) {\n    if (predicate(item)) {\n      result.push(item);\n    }\n  }\n  return result;\n}\n```\n\n**Functions Returning Functions:**\n```javascript\n// Currying\nconst multiply = a => b => a * b;\nconst double = multiply(2);\nconst triple = multiply(3);\n\nconsole.log(double(5));  // 10\nconsole.log(triple(5));  // 15\n\n// Partial application\nfunction partial(fn, ...args) {\n  return (...moreArgs) => fn(...args, ...moreArgs);\n}\n\nconst add = (a, b, c) => a + b + c;\nconst add5 = partial(add, 5);\nconsole.log(add5(3, 2));  // 10\n\n// Memoization\nfunction memoize(fn) {\n  const cache = new Map();\n  return (...args) => {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\nconst fibonacci = memoize((n) => {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n});\n```\n\n### 3. Composition and Piping\n\n```javascript\n// Function composition\nconst compose = (...fns) => x =>\n  fns.reduceRight((acc, fn) => fn(acc), x);\n\nconst pipe = (...fns) => x =>\n  fns.reduce((acc, fn) => fn(acc), x);\n\n// Example usage\nconst addOne = x => x + 1;\nconst double = x => x * 2;\nconst square = x => x * x;\n\nconst composed = compose(square, double, addOne);\nconsole.log(composed(3));  // ((3 + 1) * 2)^2 = 64\n\nconst piped = pipe(addOne, double, square);\nconsole.log(piped(3));  // ((3 + 1) * 2)^2 = 64\n\n// Practical example\nconst processUser = pipe(\n  user => ({ ...user, name: user.name.trim() }),\n  user => ({ ...user, email: user.email.toLowerCase() }),\n  user => ({ ...user, age: parseInt(user.age) })\n);\n\nconst user = processUser({\n  name: '  John  ',\n  email: 'JOHN@EXAMPLE.COM',\n  age: '30'\n});\n```\n\n### 4. Pure Functions and Immutability\n\n```javascript\n// Impure function (modifies input)\nfunction addItemImpure(cart, item) {\n  cart.items.push(item);\n  cart.total += item.price;\n  return cart;\n}\n\n// Pure function (no side effects)\nfunction addItemPure(cart, item) {\n  return {\n    ...cart,\n    items: [...cart.items, item],\n    total: cart.total + item.price\n  };\n}\n\n// Immutable array operations\nconst numbers = [1, 2, 3, 4, 5];\n\n// Add to array\nconst withSix = [...numbers, 6];\n\n// Remove from array\nconst withoutThree = numbers.filter(n => n !== 3);\n\n// Update array element\nconst doubled = numbers.map(n => n === 3 ? n * 2 : n);\n\n// Immutable object operations\nconst user = { name: 'John', age: 30 };\n\n// Update property\nconst olderUser = { ...user, age: 31 };\n\n// Add property\nconst withEmail = { ...user, email: 'john@example.com' };\n\n// Remove property\nconst { age, ...withoutAge } = user;\n\n// Deep cloning (simple approach)\nconst deepClone = obj => JSON.parse(JSON.stringify(obj));\n\n// Better deep cloning\nconst structuredClone = obj => globalThis.structuredClone(obj);\n```\n\n## Modern Class Features\n\n```javascript\n// Class syntax\nclass User {\n  // Private fields\n  #password;\n\n  // Public fields\n  id;\n  name;\n\n  // Static field\n  static count = 0;\n\n  constructor(id, name, password) {\n    this.id = id;\n    this.name = name;\n    this.#password = password;\n    User.count++;\n  }\n\n  // Public method\n  greet() {\n    return `Hello, ${this.name}`;\n  }\n\n  // Private method\n  #hashPassword(password) {\n    return `hashed_${password}`;\n  }\n\n  // Getter\n  get displayName() {\n    return this.name.toUpperCase();\n  }\n\n  // Setter\n  set password(newPassword) {\n    this.#password = this.#hashPassword(newPassword);\n  }\n\n  // Static method\n  static create(id, name, password) {\n    return new User(id, name, password);\n  }\n}\n\n// Inheritance\nclass Admin extends User {\n  constructor(id, name, password, role) {\n    super(id, name, password);\n    this.role = role;\n  }\n\n  greet() {\n    return `${super.greet()}, I'm an admin`;\n  }\n}\n```\n\n## Modules (ES6)\n\n```javascript\n// Exporting\n// math.js\nexport const PI = 3.14159;\nexport function add(a, b) {\n  return a + b;\n}\nexport class Calculator {\n  // ...\n}\n\n// Default export\nexport default function multiply(a, b) {\n  return a * b;\n}\n\n// Importing\n// app.js\nimport multiply, { PI, add, Calculator } from './math.js';\n\n// Rename imports\nimport { add as sum } from './math.js';\n\n// Import all\nimport * as Math from './math.js';\n\n// Dynamic imports\nconst module = await import('./math.js');\nconst { add } = await import('./math.js');\n\n// Conditional loading\nif (condition) {\n  const module = await import('./feature.js');\n  module.init();\n}\n```\n\n## Iterators and Generators\n\n```javascript\n// Custom iterator\nconst range = {\n  from: 1,\n  to: 5,\n\n  [Symbol.iterator]() {\n    return {\n      current: this.from,\n      last: this.to,\n\n      next() {\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\nfor (const num of range) {\n  console.log(num);  // 1, 2, 3, 4, 5\n}\n\n// Generator function\nfunction* rangeGenerator(from, to) {\n  for (let i = from; i <= to; i++) {\n    yield i;\n  }\n}\n\nfor (const num of rangeGenerator(1, 5)) {\n  console.log(num);\n}\n\n// Infinite generator\nfunction* fibonacci() {\n  let [prev, curr] = [0, 1];\n  while (true) {\n    yield curr;\n    [prev, curr] = [curr, prev + curr];\n  }\n}\n\n// Async generator\nasync function* fetchPages(url) {\n  let page = 1;\n  while (true) {\n    const response = await fetch(`${url}?page=${page}`);\n    const data = await response.json();\n    if (data.length === 0) break;\n    yield data;\n    page++;\n  }\n}\n\nfor await (const page of fetchPages('/api/users')) {\n  console.log(page);\n}\n```\n\n## Modern Operators\n\n```javascript\n// Optional chaining\nconst user = { name: 'John', address: { city: 'NYC' } };\nconst city = user?.address?.city;\nconst zipCode = user?.address?.zipCode;  // undefined\n\n// Function call\nconst result = obj.method?.();\n\n// Array access\nconst first = arr?.[0];\n\n// Nullish coalescing\nconst value = null ?? 'default';      // 'default'\nconst value = undefined ?? 'default'; // 'default'\nconst value = 0 ?? 'default';         // 0 (not 'default')\nconst value = '' ?? 'default';        // '' (not 'default')\n\n// Logical assignment\nlet a = null;\na ??= 'default';  // a = 'default'\n\nlet b = 5;\nb ??= 10;  // b = 5 (unchanged)\n\nlet obj = { count: 0 };\nobj.count ||= 1;  // obj.count = 1\nobj.count &&= 2;  // obj.count = 2\n```\n\n## Performance Optimization\n\n```javascript\n// Debounce\nfunction debounce(fn, delay) {\n  let timeoutId;\n  return (...args) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn(...args), delay);\n  };\n}\n\nconst searchDebounced = debounce(search, 300);\n\n// Throttle\nfunction throttle(fn, limit) {\n  let inThrottle;\n  return (...args) => {\n    if (!inThrottle) {\n      fn(...args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\nconst scrollThrottled = throttle(handleScroll, 100);\n\n// Lazy evaluation\nfunction* lazyMap(iterable, transform) {\n  for (const item of iterable) {\n    yield transform(item);\n  }\n}\n\n// Use only what you need\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = lazyMap(numbers, x => x * 2);\nconst first = doubled.next().value;  // Only computes first value\n```\n\n## Best Practices\n\n1. **Use const by default**: Only use let when reassignment is needed\n2. **Prefer arrow functions**: Especially for callbacks\n3. **Use template literals**: Instead of string concatenation\n4. **Destructure objects and arrays**: For cleaner code\n5. **Use async/await**: Instead of Promise chains\n6. **Avoid mutating data**: Use spread operator and array methods\n7. **Use optional chaining**: Prevent \"Cannot read property of undefined\"\n8. **Use nullish coalescing**: For default values\n9. **Prefer array methods**: Over traditional loops\n10. **Use modules**: For better code organization\n11. **Write pure functions**: Easier to test and reason about\n12. **Use meaningful variable names**: Self-documenting code\n13. **Keep functions small**: Single responsibility principle\n14. **Handle errors properly**: Use try/catch with async/await\n15. **Use strict mode**: `'use strict'` for better error catching\n\n## Common Pitfalls\n\n1. **this binding confusion**: Use arrow functions or bind()\n2. **Async/await without error handling**: Always use try/catch\n3. **Promise creation unnecessary**: Don't wrap already async functions\n4. **Mutation of objects**: Use spread operator or Object.assign()\n5. **Forgetting await**: Async functions return promises\n6. **Blocking event loop**: Avoid synchronous operations\n7. **Memory leaks**: Clean up event listeners and timers\n8. **Not handling promise rejections**: Use catch() or try/catch\n\n## Resources\n\n- **MDN Web Docs**: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n- **JavaScript.info**: https://javascript.info/\n- **You Don't Know JS**: https://github.com/getify/You-Dont-Know-JS\n- **Eloquent JavaScript**: https://eloquentjavascript.net/\n- **ES6 Features**: http://es6-features.org/\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "bash-defensive-patterns",
      "description": "Master defensive Bash programming techniques for production-grade scripts. Use when writing robust shell scripts, CI/CD pipelines, or system utilities requiring fault tolerance and safety.",
      "plugin": "shell-scripting",
      "source_path": "plugins/shell-scripting/skills/bash-defensive-patterns/SKILL.md",
      "category": "languages",
      "keywords": [
        "bash",
        "shell",
        "scripting",
        "automation",
        "posix",
        "shellcheck",
        "testing"
      ],
      "content": "---\nname: bash-defensive-patterns\ndescription: Master defensive Bash programming techniques for production-grade scripts. Use when writing robust shell scripts, CI/CD pipelines, or system utilities requiring fault tolerance and safety.\n---\n\n# Bash Defensive Patterns\n\nComprehensive guidance for writing production-ready Bash scripts using defensive programming techniques, error handling, and safety best practices to prevent common pitfalls and ensure reliability.\n\n## When to Use This Skill\n\n- Writing production automation scripts\n- Building CI/CD pipeline scripts\n- Creating system administration utilities\n- Developing error-resilient deployment automation\n- Writing scripts that must handle edge cases safely\n- Building maintainable shell script libraries\n- Implementing comprehensive logging and monitoring\n- Creating scripts that must work across different platforms\n\n## Core Defensive Principles\n\n### 1. Strict Mode\nEnable bash strict mode at the start of every script to catch errors early.\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail  # Exit on error, unset variables, pipe failures\n```\n\n**Key flags:**\n- `set -E`: Inherit ERR trap in functions\n- `set -e`: Exit on any error (command returns non-zero)\n- `set -u`: Exit on undefined variable reference\n- `set -o pipefail`: Pipe fails if any command fails (not just last)\n\n### 2. Error Trapping and Cleanup\nImplement proper cleanup on script exit or error.\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\ntrap 'echo \"Error on line $LINENO\"' ERR\ntrap 'echo \"Cleaning up...\"; rm -rf \"$TMPDIR\"' EXIT\n\nTMPDIR=$(mktemp -d)\n# Script code here\n```\n\n### 3. Variable Safety\nAlways quote variables to prevent word splitting and globbing issues.\n\n```bash\n# Wrong - unsafe\ncp $source $dest\n\n# Correct - safe\ncp \"$source\" \"$dest\"\n\n# Required variables - fail with message if unset\n: \"${REQUIRED_VAR:?REQUIRED_VAR is not set}\"\n```\n\n### 4. Array Handling\nUse arrays safely for complex data handling.\n\n```bash\n# Safe array iteration\ndeclare -a items=(\"item 1\" \"item 2\" \"item 3\")\n\nfor item in \"${items[@]}\"; do\n    echo \"Processing: $item\"\ndone\n\n# Reading output into array safely\nmapfile -t lines < <(some_command)\nreadarray -t numbers < <(seq 1 10)\n```\n\n### 5. Conditional Safety\nUse `[[ ]]` for Bash-specific features, `[ ]` for POSIX.\n\n```bash\n# Bash - safer\nif [[ -f \"$file\" && -r \"$file\" ]]; then\n    content=$(<\"$file\")\nfi\n\n# POSIX - portable\nif [ -f \"$file\" ] && [ -r \"$file\" ]; then\n    content=$(cat \"$file\")\nfi\n\n# Test for existence before operations\nif [[ -z \"${VAR:-}\" ]]; then\n    echo \"VAR is not set or is empty\"\nfi\n```\n\n## Fundamental Patterns\n\n### Pattern 1: Safe Script Directory Detection\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Correctly determine script directory\nSCRIPT_DIR=\"$(cd -- \"$(dirname -- \"${BASH_SOURCE[0]}\")\" && pwd -P)\"\nSCRIPT_NAME=\"$(basename -- \"${BASH_SOURCE[0]}\")\"\n\necho \"Script location: $SCRIPT_DIR/$SCRIPT_NAME\"\n```\n\n### Pattern 2: Comprehensive Function Templat\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Prefix for functions: handle_*, process_*, check_*, validate_*\n# Include documentation and error handling\n\nvalidate_file() {\n    local -r file=\"$1\"\n    local -r message=\"${2:-File not found: $file}\"\n\n    if [[ ! -f \"$file\" ]]; then\n        echo \"ERROR: $message\" >&2\n        return 1\n    fi\n    return 0\n}\n\nprocess_files() {\n    local -r input_dir=\"$1\"\n    local -r output_dir=\"$2\"\n\n    # Validate inputs\n    [[ -d \"$input_dir\" ]] || { echo \"ERROR: input_dir not a directory\" >&2; return 1; }\n\n    # Create output directory if needed\n    mkdir -p \"$output_dir\" || { echo \"ERROR: Cannot create output_dir\" >&2; return 1; }\n\n    # Process files safely\n    while IFS= read -r -d '' file; do\n        echo \"Processing: $file\"\n        # Do work\n    done < <(find \"$input_dir\" -maxdepth 1 -type f -print0)\n\n    return 0\n}\n```\n\n### Pattern 3: Safe Temporary File Handling\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\ntrap 'rm -rf -- \"$TMPDIR\"' EXIT\n\n# Create temporary directory\nTMPDIR=$(mktemp -d) || { echo \"ERROR: Failed to create temp directory\" >&2; exit 1; }\n\n# Create temporary files in directory\nTMPFILE1=\"$TMPDIR/temp1.txt\"\nTMPFILE2=\"$TMPDIR/temp2.txt\"\n\n# Use temporary files\ntouch \"$TMPFILE1\" \"$TMPFILE2\"\n\necho \"Temp files created in: $TMPDIR\"\n```\n\n### Pattern 4: Robust Argument Parsing\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Default values\nVERBOSE=false\nDRY_RUN=false\nOUTPUT_FILE=\"\"\nTHREADS=4\n\nusage() {\n    cat <<EOF\nUsage: $0 [OPTIONS]\n\nOptions:\n    -v, --verbose       Enable verbose output\n    -d, --dry-run       Run without making changes\n    -o, --output FILE   Output file path\n    -j, --jobs NUM      Number of parallel jobs\n    -h, --help          Show this help message\nEOF\n    exit \"${1:-0}\"\n}\n\n# Parse arguments\nwhile [[ $# -gt 0 ]]; do\n    case \"$1\" in\n        -v|--verbose)\n            VERBOSE=true\n            shift\n            ;;\n        -d|--dry-run)\n            DRY_RUN=true\n            shift\n            ;;\n        -o|--output)\n            OUTPUT_FILE=\"$2\"\n            shift 2\n            ;;\n        -j|--jobs)\n            THREADS=\"$2\"\n            shift 2\n            ;;\n        -h|--help)\n            usage 0\n            ;;\n        --)\n            shift\n            break\n            ;;\n        *)\n            echo \"ERROR: Unknown option: $1\" >&2\n            usage 1\n            ;;\n    esac\ndone\n\n# Validate required arguments\n[[ -n \"$OUTPUT_FILE\" ]] || { echo \"ERROR: -o/--output is required\" >&2; usage 1; }\n```\n\n### Pattern 5: Structured Logging\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Logging functions\nlog_info() {\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] INFO: $*\" >&2\n}\n\nlog_warn() {\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] WARN: $*\" >&2\n}\n\nlog_error() {\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $*\" >&2\n}\n\nlog_debug() {\n    if [[ \"${DEBUG:-0}\" == \"1\" ]]; then\n        echo \"[$(date +'%Y-%m-%d %H:%M:%S')] DEBUG: $*\" >&2\n    fi\n}\n\n# Usage\nlog_info \"Starting script\"\nlog_debug \"Debug information\"\nlog_warn \"Warning message\"\nlog_error \"Error occurred\"\n```\n\n### Pattern 6: Process Orchestration with Signals\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Track background processes\nPIDS=()\n\ncleanup() {\n    log_info \"Shutting down...\"\n\n    # Terminate all background processes\n    for pid in \"${PIDS[@]}\"; do\n        if kill -0 \"$pid\" 2>/dev/null; then\n            kill -TERM \"$pid\" 2>/dev/null || true\n        fi\n    done\n\n    # Wait for graceful shutdown\n    for pid in \"${PIDS[@]}\"; do\n        wait \"$pid\" 2>/dev/null || true\n    done\n}\n\ntrap cleanup SIGTERM SIGINT\n\n# Start background tasks\nbackground_task &\nPIDS+=($!)\n\nanother_task &\nPIDS+=($!)\n\n# Wait for all background processes\nwait\n```\n\n### Pattern 7: Safe File Operations\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Use -i flag to move safely without overwriting\nsafe_move() {\n    local -r source=\"$1\"\n    local -r dest=\"$2\"\n\n    if [[ ! -e \"$source\" ]]; then\n        echo \"ERROR: Source does not exist: $source\" >&2\n        return 1\n    fi\n\n    if [[ -e \"$dest\" ]]; then\n        echo \"ERROR: Destination already exists: $dest\" >&2\n        return 1\n    fi\n\n    mv \"$source\" \"$dest\"\n}\n\n# Safe directory cleanup\nsafe_rmdir() {\n    local -r dir=\"$1\"\n\n    if [[ ! -d \"$dir\" ]]; then\n        echo \"ERROR: Not a directory: $dir\" >&2\n        return 1\n    fi\n\n    # Use -I flag to prompt before rm (BSD/GNU compatible)\n    rm -rI -- \"$dir\"\n}\n\n# Atomic file writes\natomic_write() {\n    local -r target=\"$1\"\n    local -r tmpfile\n    tmpfile=$(mktemp) || return 1\n\n    # Write to temp file first\n    cat > \"$tmpfile\"\n\n    # Atomic rename\n    mv \"$tmpfile\" \"$target\"\n}\n```\n\n### Pattern 8: Idempotent Script Design\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Check if resource already exists\nensure_directory() {\n    local -r dir=\"$1\"\n\n    if [[ -d \"$dir\" ]]; then\n        log_info \"Directory already exists: $dir\"\n        return 0\n    fi\n\n    mkdir -p \"$dir\" || {\n        log_error \"Failed to create directory: $dir\"\n        return 1\n    }\n\n    log_info \"Created directory: $dir\"\n}\n\n# Ensure configuration state\nensure_config() {\n    local -r config_file=\"$1\"\n    local -r default_value=\"$2\"\n\n    if [[ ! -f \"$config_file\" ]]; then\n        echo \"$default_value\" > \"$config_file\"\n        log_info \"Created config: $config_file\"\n    fi\n}\n\n# Rerunning script multiple times should be safe\nensure_directory \"/var/cache/myapp\"\nensure_config \"/etc/myapp/config\" \"DEBUG=false\"\n```\n\n### Pattern 9: Safe Command Substitution\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Use $() instead of backticks\nname=$(<\"$file\")  # Modern, safe variable assignment from file\noutput=$(command -v python3)  # Get command location safely\n\n# Handle command substitution with error checking\nresult=$(command -v node) || {\n    log_error \"node command not found\"\n    return 1\n}\n\n# For multiple lines\nmapfile -t lines < <(grep \"pattern\" \"$file\")\n\n# NUL-safe iteration\nwhile IFS= read -r -d '' file; do\n    echo \"Processing: $file\"\ndone < <(find /path -type f -print0)\n```\n\n### Pattern 10: Dry-Run Support\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\nDRY_RUN=\"${DRY_RUN:-false}\"\n\nrun_cmd() {\n    if [[ \"$DRY_RUN\" == \"true\" ]]; then\n        echo \"[DRY RUN] Would execute: $*\"\n        return 0\n    fi\n\n    \"$@\"\n}\n\n# Usage\nrun_cmd cp \"$source\" \"$dest\"\nrun_cmd rm \"$file\"\nrun_cmd chown \"$owner\" \"$target\"\n```\n\n## Advanced Defensive Techniques\n\n### Named Parameters Pattern\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\nprocess_data() {\n    local input_file=\"\"\n    local output_dir=\"\"\n    local format=\"json\"\n\n    # Parse named parameters\n    while [[ $# -gt 0 ]]; do\n        case \"$1\" in\n            --input=*)\n                input_file=\"${1#*=}\"\n                ;;\n            --output=*)\n                output_dir=\"${1#*=}\"\n                ;;\n            --format=*)\n                format=\"${1#*=}\"\n                ;;\n            *)\n                echo \"ERROR: Unknown parameter: $1\" >&2\n                return 1\n                ;;\n        esac\n        shift\n    done\n\n    # Validate required parameters\n    [[ -n \"$input_file\" ]] || { echo \"ERROR: --input is required\" >&2; return 1; }\n    [[ -n \"$output_dir\" ]] || { echo \"ERROR: --output is required\" >&2; return 1; }\n}\n```\n\n### Dependency Checking\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\ncheck_dependencies() {\n    local -a missing_deps=()\n    local -a required=(\"jq\" \"curl\" \"git\")\n\n    for cmd in \"${required[@]}\"; do\n        if ! command -v \"$cmd\" &>/dev/null; then\n            missing_deps+=(\"$cmd\")\n        fi\n    done\n\n    if [[ ${#missing_deps[@]} -gt 0 ]]; then\n        echo \"ERROR: Missing required commands: ${missing_deps[*]}\" >&2\n        return 1\n    fi\n}\n\ncheck_dependencies\n```\n\n## Best Practices Summary\n\n1. **Always use strict mode** - `set -Eeuo pipefail`\n2. **Quote all variables** - `\"$variable\"` prevents word splitting\n3. **Use [[ ]] conditionals** - More robust than [ ]\n4. **Implement error trapping** - Catch and handle errors gracefully\n5. **Validate all inputs** - Check file existence, permissions, formats\n6. **Use functions for reusability** - Prefix with meaningful names\n7. **Implement structured logging** - Include timestamps and levels\n8. **Support dry-run mode** - Allow users to preview changes\n9. **Handle temporary files safely** - Use mktemp, cleanup with trap\n10. **Design for idempotency** - Scripts should be safe to rerun\n11. **Document requirements** - List dependencies and minimum versions\n12. **Test error paths** - Ensure error handling works correctly\n13. **Use `command -v`** - Safer than `which` for checking executables\n14. **Prefer printf over echo** - More predictable across systems\n\n## Resources\n\n- **Bash Strict Mode**: http://redsymbol.net/articles/unofficial-bash-strict-mode/\n- **Google Shell Style Guide**: https://google.github.io/styleguide/shellguide.html\n- **Defensive BASH Programming**: https://www.lifepipe.net/\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "shellcheck-configuration",
      "description": "Master ShellCheck static analysis configuration and usage for shell script quality. Use when setting up linting infrastructure, fixing code issues, or ensuring script portability.",
      "plugin": "shell-scripting",
      "source_path": "plugins/shell-scripting/skills/shellcheck-configuration/SKILL.md",
      "category": "languages",
      "keywords": [
        "bash",
        "shell",
        "scripting",
        "automation",
        "posix",
        "shellcheck",
        "testing"
      ],
      "content": "---\nname: shellcheck-configuration\ndescription: Master ShellCheck static analysis configuration and usage for shell script quality. Use when setting up linting infrastructure, fixing code issues, or ensuring script portability.\n---\n\n# ShellCheck Configuration and Static Analysis\n\nComprehensive guidance for configuring and using ShellCheck to improve shell script quality, catch common pitfalls, and enforce best practices through static code analysis.\n\n## When to Use This Skill\n\n- Setting up linting for shell scripts in CI/CD pipelines\n- Analyzing existing shell scripts for issues\n- Understanding ShellCheck error codes and warnings\n- Configuring ShellCheck for specific project requirements\n- Integrating ShellCheck into development workflows\n- Suppressing false positives and configuring rule sets\n- Enforcing consistent code quality standards\n- Migrating scripts to meet quality gates\n\n## ShellCheck Fundamentals\n\n### What is ShellCheck?\n\nShellCheck is a static analysis tool that analyzes shell scripts and detects problematic patterns. It supports:\n- Bash, sh, dash, ksh, and other POSIX shells\n- Over 100 different warnings and errors\n- Configuration for target shell and flags\n- Integration with editors and CI/CD systems\n\n### Installation\n\n```bash\n# macOS with Homebrew\nbrew install shellcheck\n\n# Ubuntu/Debian\napt-get install shellcheck\n\n# From source\ngit clone https://github.com/koalaman/shellcheck.git\ncd shellcheck\nmake build\nmake install\n\n# Verify installation\nshellcheck --version\n```\n\n## Configuration Files\n\n### .shellcheckrc (Project Level)\n\nCreate `.shellcheckrc` in your project root:\n\n```\n# Specify target shell\nshell=bash\n\n# Enable optional checks\nenable=avoid-nullary-conditions\nenable=require-variable-braces\n\n# Disable specific warnings\ndisable=SC1091\ndisable=SC2086\n```\n\n### Environment Variables\n\n```bash\n# Set default shell target\nexport SHELLCHECK_SHELL=bash\n\n# Enable strict mode\nexport SHELLCHECK_STRICT=true\n\n# Specify configuration file location\nexport SHELLCHECK_CONFIG=~/.shellcheckrc\n```\n\n## Common ShellCheck Error Codes\n\n### SC1000-1099: Parser Errors\n```bash\n# SC1004: Backslash continuation not followed by newline\necho hello\\\nworld  # Error - needs line continuation\n\n# SC1008: Invalid data for operator `=='\nif [[ $var =  \"value\" ]]; then  # Space before ==\n    true\nfi\n```\n\n### SC2000-2099: Shell Issues\n\n```bash\n# SC2009: Consider using pgrep or pidof instead of grep|grep\nps aux | grep -v grep | grep myprocess  # Use pgrep instead\n\n# SC2012: Use `ls` only for viewing. Use `find` for reliable output\nfor file in $(ls -la)  # Better: use find or globbing\n\n# SC2015: Avoid using && and || instead of if-then-else\n[[ -f \"$file\" ]] && echo \"found\" || echo \"not found\"  # Less clear\n\n# SC2016: Expressions don't expand in single quotes\necho '$VAR'  # Literal $VAR, not variable expansion\n\n# SC2026: This word is non-standard. Set POSIXLY_CORRECT\n# when using with scripts for other shells\n```\n\n### SC2100-2199: Quoting Issues\n\n```bash\n# SC2086: Double quote to prevent globbing and word splitting\nfor i in $list; do  # Should be: for i in $list or for i in \"$list\"\n    echo \"$i\"\ndone\n\n# SC2115: Literal tilde in path not expanded. Use $HOME instead\n~/.bashrc  # In strings, use \"$HOME/.bashrc\"\n\n# SC2181: Check exit code directly with `if`, not indirectly in a list\nsome_command\nif [ $? -eq 0 ]; then  # Better: if some_command; then\n\n# SC2206: Quote to prevent word splitting or set IFS\narray=( $items )  # Should use: array=( $items )\n```\n\n### SC3000-3999: POSIX Compliance Issues\n\n```bash\n# SC3010: In POSIX sh, use 'case' instead of 'cond && foo'\n[[ $var == \"value\" ]] && do_something  # Not POSIX\n\n# SC3043: In POSIX sh, use 'local' is undefined\nfunction my_func() {\n    local var=value  # Not POSIX in some shells\n}\n```\n\n## Practical Configuration Examples\n\n### Minimal Configuration (Strict POSIX)\n\n```bash\n#!/bin/bash\n# Configure for maximum portability\n\nshellcheck \\\n  --shell=sh \\\n  --external-sources \\\n  --check-sourced \\\n  script.sh\n```\n\n### Development Configuration (Bash with Relaxed Rules)\n\n```bash\n#!/bin/bash\n# Configure for Bash development\n\nshellcheck \\\n  --shell=bash \\\n  --exclude=SC1091,SC2119 \\\n  --enable=all \\\n  script.sh\n```\n\n### CI/CD Integration Configuration\n\n```bash\n#!/bin/bash\nset -Eeuo pipefail\n\n# Analyze all shell scripts and fail on issues\nfind . -type f -name \"*.sh\" | while read -r script; do\n    echo \"Checking: $script\"\n    shellcheck \\\n        --shell=bash \\\n        --format=gcc \\\n        --exclude=SC1091 \\\n        \"$script\" || exit 1\ndone\n```\n\n### .shellcheckrc for Project\n\n```\n# Shell dialect to analyze against\nshell=bash\n\n# Enable optional checks\nenable=avoid-nullary-conditions,require-variable-braces,check-unassigned-uppercase\n\n# Disable specific warnings\n# SC1091: Not following sourced files (many false positives)\ndisable=SC1091\n\n# SC2119: Use function_name instead of function_name -- (arguments)\ndisable=SC2119\n\n# External files to source for context\nexternal-sources=true\n```\n\n## Integration Patterns\n\n### Pre-commit Hook Configuration\n\n```bash\n#!/bin/bash\n# .git/hooks/pre-commit\n\n#!/bin/bash\nset -e\n\n# Find all shell scripts changed in this commit\ngit diff --cached --name-only | grep '\\.sh$' | while read -r script; do\n    echo \"Linting: $script\"\n\n    if ! shellcheck \"$script\"; then\n        echo \"ShellCheck failed on $script\"\n        exit 1\n    fi\ndone\n```\n\n### GitHub Actions Workflow\n\n```yaml\nname: ShellCheck\n\non: [push, pull_request]\n\njobs:\n  shellcheck:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Run ShellCheck\n        run: |\n          sudo apt-get install shellcheck\n          find . -type f -name \"*.sh\" -exec shellcheck {} \\;\n```\n\n### GitLab CI Pipeline\n\n```yaml\nshellcheck:\n  stage: lint\n  image: koalaman/shellcheck-alpine\n  script:\n    - find . -type f -name \"*.sh\" -exec shellcheck {} \\;\n  allow_failure: false\n```\n\n## Handling ShellCheck Violations\n\n### Suppressing Specific Warnings\n\n```bash\n#!/bin/bash\n\n# Disable warning for entire line\n# shellcheck disable=SC2086\nfor file in $(ls -la); do\n    echo \"$file\"\ndone\n\n# Disable for entire script\n# shellcheck disable=SC1091,SC2119\n\n# Disable multiple warnings (format varies)\ncommand_that_fails() {\n    # shellcheck disable=SC2015\n    [ -f \"$1\" ] && echo \"found\" || echo \"not found\"\n}\n\n# Disable specific check for source directive\n# shellcheck source=./helper.sh\nsource helper.sh\n```\n\n### Common Violations and Fixes\n\n#### SC2086: Double quote to prevent word splitting\n\n```bash\n# Problem\nfor i in $list; do done\n\n# Solution\nfor i in $list; do done  # If $list is already quoted, or\nfor i in \"${list[@]}\"; do done  # If list is an array\n```\n\n#### SC2181: Check exit code directly\n\n```bash\n# Problem\nsome_command\nif [ $? -eq 0 ]; then\n    echo \"success\"\nfi\n\n# Solution\nif some_command; then\n    echo \"success\"\nfi\n```\n\n#### SC2015: Use if-then instead of && ||\n\n```bash\n# Problem\n[ -f \"$file\" ] && echo \"exists\" || echo \"not found\"\n\n# Solution - clearer intent\nif [ -f \"$file\" ]; then\n    echo \"exists\"\nelse\n    echo \"not found\"\nfi\n```\n\n#### SC2016: Expressions don't expand in single quotes\n\n```bash\n# Problem\necho 'Variable value: $VAR'\n\n# Solution\necho \"Variable value: $VAR\"\n```\n\n#### SC2009: Use pgrep instead of grep\n\n```bash\n# Problem\nps aux | grep -v grep | grep myprocess\n\n# Solution\npgrep -f myprocess\n```\n\n## Performance Optimization\n\n### Checking Multiple Files\n\n```bash\n#!/bin/bash\n\n# Sequential checking\nfor script in *.sh; do\n    shellcheck \"$script\"\ndone\n\n# Parallel checking (faster)\nfind . -name \"*.sh\" -print0 | \\\n    xargs -0 -P 4 -n 1 shellcheck\n```\n\n### Caching Results\n\n```bash\n#!/bin/bash\n\nCACHE_DIR=\".shellcheck_cache\"\nmkdir -p \"$CACHE_DIR\"\n\ncheck_script() {\n    local script=\"$1\"\n    local hash\n    local cache_file\n\n    hash=$(sha256sum \"$script\" | cut -d' ' -f1)\n    cache_file=\"$CACHE_DIR/$hash\"\n\n    if [[ ! -f \"$cache_file\" ]]; then\n        if shellcheck \"$script\" > \"$cache_file\" 2>&1; then\n            touch \"$cache_file.ok\"\n        else\n            return 1\n        fi\n    fi\n\n    [[ -f \"$cache_file.ok\" ]]\n}\n\nfind . -name \"*.sh\" | while read -r script; do\n    check_script \"$script\" || exit 1\ndone\n```\n\n## Output Formats\n\n### Default Format\n\n```bash\nshellcheck script.sh\n\n# Output:\n# script.sh:1:3: warning: foo is referenced but not assigned. [SC2154]\n```\n\n### GCC Format (for CI/CD)\n\n```bash\nshellcheck --format=gcc script.sh\n\n# Output:\n# script.sh:1:3: warning: foo is referenced but not assigned.\n```\n\n### JSON Format (for parsing)\n\n```bash\nshellcheck --format=json script.sh\n\n# Output:\n# [{\"file\": \"script.sh\", \"line\": 1, \"column\": 3, \"level\": \"warning\", \"code\": 2154, \"message\": \"...\"}]\n```\n\n### Quiet Format\n\n```bash\nshellcheck --format=quiet script.sh\n\n# Returns non-zero if issues found, no output otherwise\n```\n\n## Best Practices\n\n1. **Run ShellCheck in CI/CD** - Catch issues before merging\n2. **Configure for your target shell** - Don't analyze bash as sh\n3. **Document exclusions** - Explain why violations are suppressed\n4. **Address violations** - Don't just disable warnings\n5. **Enable strict mode** - Use `--enable=all` with careful exclusions\n6. **Update regularly** - Keep ShellCheck current for new checks\n7. **Use pre-commit hooks** - Catch issues locally before pushing\n8. **Integrate with editors** - Get real-time feedback during development\n\n## Resources\n\n- **ShellCheck GitHub**: https://github.com/koalaman/shellcheck\n- **ShellCheck Wiki**: https://www.shellcheck.net/wiki/\n- **Error Code Reference**: https://www.shellcheck.net/\n",
      "references": {},
      "assets": {}
    },
    {
      "name": "bats-testing-patterns",
      "description": "Master Bash Automated Testing System (Bats) for comprehensive shell script testing. Use when writing tests for shell scripts, CI/CD pipelines, or requiring test-driven development of shell utilities.",
      "plugin": "shell-scripting",
      "source_path": "plugins/shell-scripting/skills/bats-testing-patterns/SKILL.md",
      "category": "languages",
      "keywords": [
        "bash",
        "shell",
        "scripting",
        "automation",
        "posix",
        "shellcheck",
        "testing"
      ],
      "content": "---\nname: bats-testing-patterns\ndescription: Master Bash Automated Testing System (Bats) for comprehensive shell script testing. Use when writing tests for shell scripts, CI/CD pipelines, or requiring test-driven development of shell utilities.\n---\n\n# Bats Testing Patterns\n\nComprehensive guidance for writing comprehensive unit tests for shell scripts using Bats (Bash Automated Testing System), including test patterns, fixtures, and best practices for production-grade shell testing.\n\n## When to Use This Skill\n\n- Writing unit tests for shell scripts\n- Implementing test-driven development (TDD) for scripts\n- Setting up automated testing in CI/CD pipelines\n- Testing edge cases and error conditions\n- Validating behavior across different shell environments\n- Building maintainable test suites for scripts\n- Creating fixtures for complex test scenarios\n- Testing multiple shell dialects (bash, sh, dash)\n\n## Bats Fundamentals\n\n### What is Bats?\n\nBats (Bash Automated Testing System) is a TAP (Test Anything Protocol) compliant testing framework for shell scripts that provides:\n- Simple, natural test syntax\n- TAP output format compatible with CI systems\n- Fixtures and setup/teardown support\n- Assertion helpers\n- Parallel test execution\n\n### Installation\n\n```bash\n# macOS with Homebrew\nbrew install bats-core\n\n# Ubuntu/Debian\ngit clone https://github.com/bats-core/bats-core.git\ncd bats-core\n./install.sh /usr/local\n\n# From npm (Node.js)\nnpm install --global bats\n\n# Verify installation\nbats --version\n```\n\n### File Structure\n\n```\nproject/\n\u251c\u2500\u2500 bin/\n\u2502   \u251c\u2500\u2500 script.sh\n\u2502   \u2514\u2500\u2500 helper.sh\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 test_script.bats\n\u2502   \u251c\u2500\u2500 test_helper.sh\n\u2502   \u251c\u2500\u2500 fixtures/\n\u2502   \u2502   \u251c\u2500\u2500 input.txt\n\u2502   \u2502   \u2514\u2500\u2500 expected_output.txt\n\u2502   \u2514\u2500\u2500 helpers/\n\u2502       \u2514\u2500\u2500 mocks.bash\n\u2514\u2500\u2500 README.md\n```\n\n## Basic Test Structure\n\n### Simple Test File\n\n```bash\n#!/usr/bin/env bats\n\n# Load test helper if present\nload test_helper\n\n# Setup runs before each test\nsetup() {\n    export TMPDIR=$(mktemp -d)\n}\n\n# Teardown runs after each test\nteardown() {\n    rm -rf \"$TMPDIR\"\n}\n\n# Test: simple assertion\n@test \"Function returns 0 on success\" {\n    run my_function \"input\"\n    [ \"$status\" -eq 0 ]\n}\n\n# Test: output verification\n@test \"Function outputs correct result\" {\n    run my_function \"test\"\n    [ \"$output\" = \"expected output\" ]\n}\n\n# Test: error handling\n@test \"Function returns 1 on missing argument\" {\n    run my_function\n    [ \"$status\" -eq 1 ]\n}\n```\n\n## Assertion Patterns\n\n### Exit Code Assertions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Command succeeds\" {\n    run true\n    [ \"$status\" -eq 0 ]\n}\n\n@test \"Command fails as expected\" {\n    run false\n    [ \"$status\" -ne 0 ]\n}\n\n@test \"Command returns specific exit code\" {\n    run my_function --invalid\n    [ \"$status\" -eq 127 ]\n}\n\n@test \"Can capture command result\" {\n    run echo \"hello\"\n    [ $status -eq 0 ]\n    [ \"$output\" = \"hello\" ]\n}\n```\n\n### Output Assertions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Output matches string\" {\n    result=$(echo \"hello world\")\n    [ \"$result\" = \"hello world\" ]\n}\n\n@test \"Output contains substring\" {\n    result=$(echo \"hello world\")\n    [[ \"$result\" == *\"world\"* ]]\n}\n\n@test \"Output matches pattern\" {\n    result=$(date +%Y)\n    [[ \"$result\" =~ ^[0-9]{4}$ ]]\n}\n\n@test \"Multi-line output\" {\n    run printf \"line1\\nline2\\nline3\"\n    [ \"$output\" = \"line1\nline2\nline3\" ]\n}\n\n@test \"Lines variable contains output\" {\n    run printf \"line1\\nline2\\nline3\"\n    [ \"${lines[0]}\" = \"line1\" ]\n    [ \"${lines[1]}\" = \"line2\" ]\n    [ \"${lines[2]}\" = \"line3\" ]\n}\n```\n\n### File Assertions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"File is created\" {\n    [ ! -f \"$TMPDIR/output.txt\" ]\n    my_function > \"$TMPDIR/output.txt\"\n    [ -f \"$TMPDIR/output.txt\" ]\n}\n\n@test \"File contents match expected\" {\n    my_function > \"$TMPDIR/output.txt\"\n    [ \"$(cat \"$TMPDIR/output.txt\")\" = \"expected content\" ]\n}\n\n@test \"File is readable\" {\n    touch \"$TMPDIR/test.txt\"\n    [ -r \"$TMPDIR/test.txt\" ]\n}\n\n@test \"File has correct permissions\" {\n    touch \"$TMPDIR/test.txt\"\n    chmod 644 \"$TMPDIR/test.txt\"\n    [ \"$(stat -f %OLp \"$TMPDIR/test.txt\")\" = \"644\" ]\n}\n\n@test \"File size is correct\" {\n    echo -n \"12345\" > \"$TMPDIR/test.txt\"\n    [ \"$(wc -c < \"$TMPDIR/test.txt\")\" -eq 5 ]\n}\n```\n\n## Setup and Teardown Patterns\n\n### Basic Setup and Teardown\n\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Create test directory\n    TEST_DIR=$(mktemp -d)\n    export TEST_DIR\n\n    # Source script under test\n    source \"${BATS_TEST_DIRNAME}/../bin/script.sh\"\n}\n\nteardown() {\n    # Clean up temporary directory\n    rm -rf \"$TEST_DIR\"\n}\n\n@test \"Test using TEST_DIR\" {\n    touch \"$TEST_DIR/file.txt\"\n    [ -f \"$TEST_DIR/file.txt\" ]\n}\n```\n\n### Setup with Resources\n\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Create directory structure\n    mkdir -p \"$TMPDIR/data/input\"\n    mkdir -p \"$TMPDIR/data/output\"\n\n    # Create test fixtures\n    echo \"line1\" > \"$TMPDIR/data/input/file1.txt\"\n    echo \"line2\" > \"$TMPDIR/data/input/file2.txt\"\n\n    # Initialize environment\n    export DATA_DIR=\"$TMPDIR/data\"\n    export INPUT_DIR=\"$DATA_DIR/input\"\n    export OUTPUT_DIR=\"$DATA_DIR/output\"\n}\n\nteardown() {\n    rm -rf \"$TMPDIR/data\"\n}\n\n@test \"Processes input files\" {\n    run my_process_script \"$INPUT_DIR\" \"$OUTPUT_DIR\"\n    [ \"$status\" -eq 0 ]\n    [ -f \"$OUTPUT_DIR/file1.txt\" ]\n}\n```\n\n### Global Setup/Teardown\n\n```bash\n#!/usr/bin/env bats\n\n# Load shared setup from test_helper.sh\nload test_helper\n\n# setup_file runs once before all tests\nsetup_file() {\n    export SHARED_RESOURCE=$(mktemp -d)\n    echo \"Expensive setup\" > \"$SHARED_RESOURCE/data.txt\"\n}\n\n# teardown_file runs once after all tests\nteardown_file() {\n    rm -rf \"$SHARED_RESOURCE\"\n}\n\n@test \"First test uses shared resource\" {\n    [ -f \"$SHARED_RESOURCE/data.txt\" ]\n}\n\n@test \"Second test uses shared resource\" {\n    [ -d \"$SHARED_RESOURCE\" ]\n}\n```\n\n## Mocking and Stubbing Patterns\n\n### Function Mocking\n\n```bash\n#!/usr/bin/env bats\n\n# Mock external command\nmy_external_tool() {\n    echo \"mocked output\"\n    return 0\n}\n\n@test \"Function uses mocked tool\" {\n    export -f my_external_tool\n    run my_function\n    [[ \"$output\" == *\"mocked output\"* ]]\n}\n```\n\n### Command Stubbing\n\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Create stub directory\n    STUBS_DIR=\"$TMPDIR/stubs\"\n    mkdir -p \"$STUBS_DIR\"\n\n    # Add to PATH\n    export PATH=\"$STUBS_DIR:$PATH\"\n}\n\ncreate_stub() {\n    local cmd=\"$1\"\n    local output=\"$2\"\n    local code=\"${3:-0}\"\n\n    cat > \"$STUBS_DIR/$cmd\" <<EOF\n#!/bin/bash\necho \"$output\"\nexit $code\nEOF\n    chmod +x \"$STUBS_DIR/$cmd\"\n}\n\n@test \"Function works with stubbed curl\" {\n    create_stub curl \"{ \\\"status\\\": \\\"ok\\\" }\" 0\n    run my_api_function\n    [ \"$status\" -eq 0 ]\n}\n```\n\n### Variable Stubbing\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Function handles environment override\" {\n    export MY_SETTING=\"override_value\"\n    run my_function\n    [ \"$status\" -eq 0 ]\n    [[ \"$output\" == *\"override_value\"* ]]\n}\n\n@test \"Function uses default when var unset\" {\n    unset MY_SETTING\n    run my_function\n    [ \"$status\" -eq 0 ]\n    [[ \"$output\" == *\"default\"* ]]\n}\n```\n\n## Fixture Management\n\n### Using Fixture Files\n\n```bash\n#!/usr/bin/env bats\n\n# Fixture directory: tests/fixtures/\n\nsetup() {\n    FIXTURES_DIR=\"${BATS_TEST_DIRNAME}/fixtures\"\n    WORK_DIR=$(mktemp -d)\n    export WORK_DIR\n}\n\nteardown() {\n    rm -rf \"$WORK_DIR\"\n}\n\n@test \"Process fixture file\" {\n    # Copy fixture to work directory\n    cp \"$FIXTURES_DIR/input.txt\" \"$WORK_DIR/input.txt\"\n\n    # Run function\n    run my_process_function \"$WORK_DIR/input.txt\"\n\n    # Compare output\n    diff \"$WORK_DIR/output.txt\" \"$FIXTURES_DIR/expected_output.txt\"\n}\n```\n\n### Dynamic Fixture Generation\n\n```bash\n#!/usr/bin/env bats\n\ngenerate_fixture() {\n    local lines=\"$1\"\n    local file=\"$2\"\n\n    for i in $(seq 1 \"$lines\"); do\n        echo \"Line $i content\" >> \"$file\"\n    done\n}\n\n@test \"Handle large input file\" {\n    generate_fixture 1000 \"$TMPDIR/large.txt\"\n    run my_function \"$TMPDIR/large.txt\"\n    [ \"$status\" -eq 0 ]\n    [ \"$(wc -l < \"$TMPDIR/large.txt\")\" -eq 1000 ]\n}\n```\n\n## Advanced Patterns\n\n### Testing Error Conditions\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Function fails with missing file\" {\n    run my_function \"/nonexistent/file.txt\"\n    [ \"$status\" -ne 0 ]\n    [[ \"$output\" == *\"not found\"* ]]\n}\n\n@test \"Function fails with invalid input\" {\n    run my_function \"\"\n    [ \"$status\" -ne 0 ]\n}\n\n@test \"Function fails with permission denied\" {\n    touch \"$TMPDIR/readonly.txt\"\n    chmod 000 \"$TMPDIR/readonly.txt\"\n    run my_function \"$TMPDIR/readonly.txt\"\n    [ \"$status\" -ne 0 ]\n    chmod 644 \"$TMPDIR/readonly.txt\"  # Cleanup\n}\n\n@test \"Function provides helpful error message\" {\n    run my_function --invalid-option\n    [ \"$status\" -ne 0 ]\n    [[ \"$output\" == *\"Usage:\"* ]]\n}\n```\n\n### Testing with Dependencies\n\n```bash\n#!/usr/bin/env bats\n\nsetup() {\n    # Check for required tools\n    if ! command -v jq &>/dev/null; then\n        skip \"jq is not installed\"\n    fi\n\n    export SCRIPT=\"${BATS_TEST_DIRNAME}/../bin/script.sh\"\n}\n\n@test \"JSON parsing works\" {\n    skip_if ! command -v jq &>/dev/null\n    run my_json_parser '{\"key\": \"value\"}'\n    [ \"$status\" -eq 0 ]\n}\n```\n\n### Testing Shell Compatibility\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Script works in bash\" {\n    bash \"${BATS_TEST_DIRNAME}/../bin/script.sh\" arg1\n}\n\n@test \"Script works in sh (POSIX)\" {\n    sh \"${BATS_TEST_DIRNAME}/../bin/script.sh\" arg1\n}\n\n@test \"Script works in dash\" {\n    if command -v dash &>/dev/null; then\n        dash \"${BATS_TEST_DIRNAME}/../bin/script.sh\" arg1\n    else\n        skip \"dash not installed\"\n    fi\n}\n```\n\n### Parallel Execution\n\n```bash\n#!/usr/bin/env bats\n\n@test \"Multiple independent operations\" {\n    run bash -c 'for i in {1..10}; do\n        my_operation \"$i\" &\n    done\n    wait'\n    [ \"$status\" -eq 0 ]\n}\n\n@test \"Concurrent file operations\" {\n    for i in {1..5}; do\n        my_function \"$TMPDIR/file$i\" &\n    done\n    wait\n    [ -f \"$TMPDIR/file1\" ]\n    [ -f \"$TMPDIR/file5\" ]\n}\n```\n\n## Test Helper Pattern\n\n### test_helper.sh\n\n```bash\n#!/usr/bin/env bash\n\n# Source script under test\nexport SCRIPT_DIR=\"${BATS_TEST_DIRNAME%/*}/bin\"\n\n# Common test utilities\nassert_file_exists() {\n    if [ ! -f \"$1\" ]; then\n        echo \"Expected file to exist: $1\"\n        return 1\n    fi\n}\n\nassert_file_equals() {\n    local file=\"$1\"\n    local expected=\"$2\"\n\n    if [ ! -f \"$file\" ]; then\n        echo \"File does not exist: $file\"\n        return 1\n    fi\n\n    local actual=$(cat \"$file\")\n    if [ \"$actual\" != \"$expected\" ]; then\n        echo \"File contents do not match\"\n        echo \"Expected: $expected\"\n        echo \"Actual: $actual\"\n        return 1\n    fi\n}\n\n# Create temporary test directory\nsetup_test_dir() {\n    export TEST_DIR=$(mktemp -d)\n}\n\ncleanup_test_dir() {\n    rm -rf \"$TEST_DIR\"\n}\n```\n\n## Integration with CI/CD\n\n### GitHub Actions Workflow\n\n```yaml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install Bats\n        run: |\n          npm install --global bats\n\n      - name: Run Tests\n        run: |\n          bats tests/*.bats\n\n      - name: Run Tests with Tap Reporter\n        run: |\n          bats tests/*.bats --tap | tee test_output.tap\n```\n\n### Makefile Integration\n\n```makefile\n.PHONY: test test-verbose test-tap\n\ntest:\n\tbats tests/*.bats\n\ntest-verbose:\n\tbats tests/*.bats --verbose\n\ntest-tap:\n\tbats tests/*.bats --tap\n\ntest-parallel:\n\tbats tests/*.bats --parallel 4\n\ncoverage: test\n\t# Optional: Generate coverage reports\n```\n\n## Best Practices\n\n1. **Test one thing per test** - Single responsibility principle\n2. **Use descriptive test names** - Clearly states what is being tested\n3. **Clean up after tests** - Always remove temporary files in teardown\n4. **Test both success and failure paths** - Don't just test happy path\n5. **Mock external dependencies** - Isolate unit under test\n6. **Use fixtures for complex data** - Makes tests more readable\n7. **Run tests in CI/CD** - Catch regressions early\n8. **Test across shell dialects** - Ensure portability\n9. **Keep tests fast** - Run in parallel when possible\n10. **Document complex test setup** - Explain unusual patterns\n\n## Resources\n\n- **Bats GitHub**: https://github.com/bats-core/bats-core\n- **Bats Documentation**: https://bats-core.readthedocs.io/\n- **TAP Protocol**: https://testanything.org/\n- **Test-Driven Development**: https://en.wikipedia.org/wiki/Test-driven_development\n",
      "references": {},
      "assets": {}
    }
  ]
}